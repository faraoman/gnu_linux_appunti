#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Prontuario italiano a Linux
\end_layout

\begin_layout Author
Giuseppe Nebbione
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
thispagestyle{empty}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Copyright (c) 2016 gn è garantito il permesso di copiare, distribuire e/o
 modificare questo documento seguendo i termini della Licenza per Documentazione
 Libera GNU, Versione 1.1 o ogni versione successiva pubblicata dalla Free
 Software Foundation; senza Sezioni non Modificabili, nessun Testo Copertina,
 nessun Testo di Retro Copertina.
 Una copia della licenza è acclusa nella sezione intitolata "Licenza per
 Documentazione Libera GNU".
 
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagenumbering{roman}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagenumbering{arabic}
\end_layout

\begin_layout Plain Layout


\backslash
setcounter{page}{1}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Comandi di Base e Struttura di un sistema GNU/Linux
\end_layout

\begin_layout Subsection
Primi passi in sistemi GNU/Linux
\end_layout

\begin_layout Standard
The GNU userland has a special part called the "GNU Coreutils".
 This is a set of utilities that provide essential file and shell tools.
 Example components include rm, cat, ls, cp, etc.
 However, do not confuse "util-linux" with the GNU Coreutils.
 Both exist in the userland, but util-linux is not a part of the official
 GNU userland.
 Some tools that are part of util-linux include mcookie, kill, more, cfdisk,
 dmesg, etc.
\end_layout

\begin_layout Standard
The “GNU Binutils” is a collection of programming tools for binary/compiled
 programs.
\end_layout

\begin_layout Standard
The GNU build system (or Autotools) is a set of programming tools for setting
 up source code for Unixoid systems.
 Autotools is part of the GNU Toolchain.
 The GNU Toolchain is a large collection of programming tools such as the
 GNU Compiler Collection (GCC), GNU Debugger (GDB), GNU Binutils, and more.
 GCC is the compiler toolkit.
\end_layout

\begin_layout Standard
GNU uses glibc (GNU C Library) as an open-source alternative to the standard
 C library.
 Gnulib is an alternative to glibc that provides portability for other operating
 systems.
\end_layout

\begin_layout Standard
GNU Classpath is an open-source Java class library.
\end_layout

\begin_layout Standard
Ogni comando che eseguiamo da terminale può far parte di un programma esterno
 installato, o può essere una funzione da noi definita, o ad esempio un
 alias, o ancora uno 
\begin_inset Quotes eld
\end_inset

shell built-in
\begin_inset Quotes erd
\end_inset

, cioè comandi di base per la shell utilizzata che non potrebbero esistere
 senza la shell, vediamo ora una serie di comandi di base.
\end_layout

\begin_layout Paragraph
Pwd
\end_layout

\begin_layout Standard
Una volta all'interno di un terminale, possiamo capire in che directory
 siamo situati attraverso il comando 
\begin_inset Quotes eld
\end_inset

pwd
\begin_inset Quotes erd
\end_inset

, possiamo quindi semplicemente lanciare pwd e vedere a schermo il percorso
 della directory corrente.
\end_layout

\begin_layout Standard
There are two reasons why we could need to use this:
\end_layout

\begin_layout Enumerate
Our terminal doesn't show it
\end_layout

\begin_layout Enumerate
we want to see the original path and not a symbolic link, for this we could
 use 
\begin_inset Quotes eld
\end_inset

pwd -P
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Paragraph
Export
\end_layout

\begin_layout Standard
Questo comando serve a creare una variabile d'ambiente, vediamo un esempio:
\end_layout

\begin_layout Itemize
export nomeVariabile=valore //imposta una variabile d'ambiente
\end_layout

\begin_layout Standard
nota che una variabile può anche essere definita come:
\end_layout

\begin_layout Itemize
nomeVariabile=valore //imposta una variabile di shell, quindi una variabile
 valida solo all'interno del processo shell corrente
\end_layout

\begin_layout Standard
la differenza sta appunto che nel caso di 
\begin_inset Quotes eld
\end_inset

export
\begin_inset Quotes erd
\end_inset

 la variabile (d'ambiente) verrà passata ad ogni processo figlio chiamato
 dalla shell.
 export makes the variable available to sub-processes.
 That is, export name=value means that the variable name is available to
 any process you run from that shell process.
 If you want a process to make use of this variable, use export, and run
 the process from that shell.
\end_layout

\begin_layout Standard
name=value means the variable scope is restricted to the shell, and is not
 available to any other process.
 You would use this for (say) loop variables, temporary variables etc.
\end_layout

\begin_layout Standard
nel caso volessimo impostare una variabile con un valore permanente, allora
 possiamo aggiungere l'assegnazione del valore nei file indicati per la
 Bash\SpecialChar endofsentence

\end_layout

\begin_layout Subsubsection*
Type
\end_layout

\begin_layout Standard
All'inizio può essere utile capire mano a mano che incontriamo nuovi comandi
 di base capire se questi ultimi sono builtin della shell o se vengono da
 pacchetti installati al di fuori della shell, per questo possiamo usare
 il comando 
\begin_inset Quotes eld
\end_inset

type
\begin_inset Quotes erd
\end_inset

, infatti dando in pasto a questo comando il programma, lui capirà di che
 tipo è il programma in questione, ad esempio:
\end_layout

\begin_layout Itemize
type pwd //questo ci dirà di che tipologia è 
\begin_inset Quotes eld
\end_inset

pwd
\begin_inset Quotes erd
\end_inset

, scopriremo infatti che questo è uno shell built-in
\end_layout

\begin_layout Standard
le tipologie possibili sono:
\end_layout

\begin_layout Itemize
alias (command is shell alias): questi sono alias, su molti sistemi/distribuzion
i un comando di default già con alias è 
\begin_inset Quotes eld
\end_inset

ls
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
keyword (command is shell reserved word): queste sono keyword della shell,
 ad esempio keyword utilizzate per creare script come ad esempio 
\begin_inset Quotes eld
\end_inset

if
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
function (command is shell function): queste sono funzioni definite
\end_layout

\begin_layout Itemize
builtin (command is shell builtin): questi sono i comandi builtin della
 shell come ad esempio 
\begin_inset Quotes eld
\end_inset

pwd
\begin_inset Quotes erd
\end_inset

 o 
\begin_inset Quotes eld
\end_inset

cd
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
file (command is disk file): questi sono i comandi esterni, come ad esempio
 
\begin_inset Quotes eld
\end_inset

date
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
questo comando può essere utile anche per capire ad esempio quale file viene
 eseguito quando eseguiamo un programma, se ad esempio volessimo vedere
 il percorso del file che risponde al comando 
\begin_inset Quotes eld
\end_inset

date
\begin_inset Quotes erd
\end_inset

, allora eseguiamo:
\end_layout

\begin_layout Itemize
type -p date //mostra il percorso al comando date
\end_layout

\begin_layout Standard
se volessimo il tipo in una forma più corta 
\begin_inset Quotes eld
\end_inset

short form
\begin_inset Quotes erd
\end_inset

, allora facciamo:
\end_layout

\begin_layout Itemize
type -t date //mostra il tipo di comando in una forma short, ad esempio
 con la stringa 
\begin_inset Quotes eld
\end_inset

file
\begin_inset Quotes erd
\end_inset

 in questo esempio
\end_layout

\begin_layout Standard
per avere tutte le informazioni su un comando possiamo utilizzare il flag
 
\begin_inset Quotes eld
\end_inset

-a
\begin_inset Quotes erd
\end_inset

, ad esempio:
\end_layout

\begin_layout Itemize
type -a nomeComando //mostra tutte le informazioni sul comando 
\begin_inset Quotes eld
\end_inset

nomeComando
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
N.B.: Il comando 
\begin_inset Quotes eld
\end_inset

type
\begin_inset Quotes erd
\end_inset

 è un comando builtin, quindi questi parametri potrebbero cambiare da shell
 a shell, quelli qui riportati valgono per la bash.
\end_layout

\begin_layout Paragraph
Declare
\end_layout

\begin_layout Standard
Possiamo creare funzioni all'interno della command line con la sequenza
 di istruzioni:
\end_layout

\begin_layout Itemize
nome_funzione() {
\end_layout

\begin_layout Itemize
istruzione1
\end_layout

\begin_layout Itemize
istruzione2
\end_layout

\begin_layout Itemize
...
\end_layout

\begin_layout Itemize
istruzioneN
\end_layout

\begin_layout Itemize
}
\end_layout

\begin_layout Standard
una volta creata la funzione, questa può essere richiamata col comando:
\end_layout

\begin_layout Itemize
nome_funzione
\end_layout

\begin_layout Standard
nel caso volessimo visualizzare 
\begin_inset Quotes eld
\end_inset

cosa fa
\begin_inset Quotes erd
\end_inset

 questa funzione allora eseguiremo:
\end_layout

\begin_layout Itemize
declare -f nome_funzione //questo mostrerà il corpo della funzione
\end_layout

\begin_layout Standard
possiamo anche salvare funzioni create momentaneamente nel file di confugurazion
e della shell o nel file adibito alle funzioni definite a livello utente,
 andando a redirigere l'output in modalità 
\begin_inset Quotes eld
\end_inset

append
\begin_inset Quotes erd
\end_inset

, ad esempio:
\end_layout

\begin_layout Itemize
declare -f nome_funzione >> ~/.my_bash_functions
\end_layout

\begin_layout Standard
nel caso andassimo ad eseguire un semplice:
\end_layout

\begin_layout Itemize
declare //visualizza il corpo di tutte le funzioni definite e delle variabili
\end_layout

\begin_layout Paragraph
Help
\end_layout

\begin_layout Standard
Il comando help è utile per poter visualizzare la lista di comandi built-in
 della shell, e poter visualizzare il loro manuale, vediamo alcuni esempi:
\end_layout

\begin_layout Itemize
help //visualizza la lista dei comandi built-in della shell
\end_layout

\begin_layout Itemize
help -m nomeComandoBuilt-In //visualizza il manuale del comando built-in,
 ad esempio funziona con 
\begin_inset Quotes eld
\end_inset

cd
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

pushd
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

popd
\begin_inset Quotes erd
\end_inset

, eccetera...
\end_layout

\begin_layout Paragraph
Cd
\end_layout

\begin_layout Standard
Una volta all'interno del terminale possiamo muoverci all'interno delle
 directory con il comando 
\begin_inset Quotes eld
\end_inset

cd
\begin_inset Quotes erd
\end_inset

, questo programma è incluso nella shell, quindi non è possibile effettuare
 un 
\begin_inset Quotes eld
\end_inset

sudo cd
\begin_inset Quotes erd
\end_inset

 ad esempio, ma devo loggare con l'utente di root e arrivare al percorso
 desiderato; vediamo alcuni esempi applicativi:
\end_layout

\begin_layout Itemize
cd nomeDirectory //si sposta nella directory nomeDirectory
\end_layout

\begin_layout Itemize
cd !$ //si sposta nella directory che abbiamo elaborato nel comando precedente,
 cioè nel caso avessimo eseguito un mkdir, questo si sposta direttamente
 in quella directory
\end_layout

\begin_layout Itemize
cd - //si sposta nella directory precedente, se non mi sono ancora spostato
 almeno una volta non funziona
\end_layout

\begin_layout Standard
Se le directory (o in genere i file) hanno spazi nei loro nomi allora abbiamo
 due possibilità:
\end_layout

\begin_layout Itemize
scrivere il nome tra doppi apici 
\begin_inset Quotes eld
\end_inset

nome Dir
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
utilizzare la notazione con i backslah, ad esempio nome
\backslash
 Dir
\end_layout

\begin_layout Standard
N.B.: I filesystem di tipo ext3 hanno un limite sulla lunghezza dei nomi dei
 file che equivale a 255 caratteri.
\end_layout

\begin_layout Paragraph
Ls
\end_layout

\begin_layout Standard
Un altro comando molto utile per poter visualizzare il contenuto di una
 directory o le caratteristiche dei file è ls; alcuni esempi di applicazione
 comprendono:
\end_layout

\begin_layout Itemize
ls nomeDir //elenca il contenuto della directory nomeDir
\end_layout

\begin_layout Itemize
ls //elenca il contenuto della directory corrente
\end_layout

\begin_layout Itemize
ls -F nomeDir //elenca il contenuto di nomeDir, evidenziando le differenze
 tra i tipi di file:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
il simbolo '/' dietro al nome del file denota una directory
\end_layout

\begin_layout Itemize
il simbolo '@' dietro al nome del file denota un collegamento (link)
\end_layout

\begin_layout Itemize
nessun simbolo davanti al nome del file denota un file semplice
\end_layout

\end_deeper
\begin_layout Itemize
ls -R nomeDir //elencail contenuto di nomeDir e di tutti i file delle sottodirec
tory ricorsivamente, è utile nel caso volessi vedere anche il contenuto
 delle sotto-directory
\end_layout

\begin_layout Itemize
ls -al //elenca tutti i file, anche quelli nascosti e i puntatori 
\begin_inset Quotes eld
\end_inset

.
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

..
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
ls -Al //elenca tutti i file, anche quelli nascosti, ma senza 
\begin_inset Quotes eld
\end_inset

.
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

..
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
ls -Alh //elenca tutti i file, con le relative dimensioni in formato human
 readable
\end_layout

\begin_layout Itemize
ls -1 //elenca tutti i file su una sola colonna
\end_layout

\begin_layout Itemize
ls -t //elenca i file mostrando prima quelli modificati per ultimi
\end_layout

\begin_layout Itemize
ls -ltr //elenca i file mostrando prima quelli meno modificati
\end_layout

\begin_layout Itemize
ls -sSh //mostra i file in ordine decrescente di dimensione, nota che per
 le directory non viene fatto un resoconto delle dimensioni
\end_layout

\begin_layout Itemize
ls -li //visualizzo la lista file con relativo inode id
\end_layout

\begin_layout Itemize
ls -ld nomeDirectory //mostra informazioni solo sulla directory menzionata,
 senza il 
\begin_inset Quotes eld
\end_inset

-d
\begin_inset Quotes erd
\end_inset

 mi mostrerebbe il contenuto della directory specificata
\end_layout

\begin_layout Itemize
ls -I nomeFile1 //elenca i file, eccetto il file chiamato nomeFile1
\end_layout

\begin_layout Paragraph
Tree
\end_layout

\begin_layout Standard
Tree costituisce un comando molto utile nel momento in cui vogliamo visualizzare
 le directory con una struttura ad albero per capire come è strutturato
 il filesystem in uno specifico punto, non è installato di default, possiamo
 installarlo con:
\end_layout

\begin_layout Itemize
sudo apt-get install tree //installa il programma 
\begin_inset Quotes eld
\end_inset

tree
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
e possiamo utilizzarlo con:
\end_layout

\begin_layout Itemize
tree nomeDirectory | more //visualizza la struttura ad albero della directory,
 in un formato comodo da scorrere attraverso il programma more
\end_layout

\begin_layout Itemize
tree //visualizza la struttura ad albero della directory corrente
\end_layout

\begin_layout Paragraph
Cp
\end_layout

\begin_layout Standard
Cp è un comando molto versatile utilizzato per copiare generalmente, alcuni
 esempi di applicazione sono:
\end_layout

\begin_layout Itemize
cp file1 file2 //effettua una copia del file file1 e la chiama file2
\end_layout

\begin_layout Itemize
cp -i file1 file2 //in questo caso prima di effettuare la copia, controlla
 se nella directory esiste già un file chiamato file2, e se questo esiste
 allora prima chiede conferma dell'operazione di sovrascrizione
\end_layout

\begin_layout Itemize
cp -p file /otherdirectory/ //effettua una copia preservando il proprietario
 e i permessi anche nell'altro directory
\end_layout

\begin_layout Itemize
cp -u file file2 //in questo caso viene effettuata una riscrittura solo
 nel caso in cui il file file1 è più recente di file2, questo tipo di copia
 è detta anche copia in modalità 
\begin_inset Quotes eld
\end_inset

backup
\begin_inset Quotes erd
\end_inset

, perchè si comporta come un backup
\end_layout

\begin_layout Standard
Attenzione anche 
\begin_inset Quotes eld
\end_inset

cp
\begin_inset Quotes erd
\end_inset

 su molti sistemi copia solo file non nascosti, per copiare file nascosti
 utilizziamo:
\end_layout

\begin_layout Itemize
cp -R .* directoryScelta/ //copia tutti i file nascosti nella directory menzionat
a
\end_layout

\begin_layout Paragraph
Mv
\end_layout

\begin_layout Standard
Il comando 
\begin_inset Quotes eld
\end_inset

mv
\begin_inset Quotes erd
\end_inset

, ha una duplice funzione, può essere usato sia per spostare file che per
 rinominarli, alcuni esempi applicativi sono:
\end_layout

\begin_layout Itemize
mv mioFile tuoFile //rinomina il file mioFile in tuoFile
\end_layout

\begin_layout Itemize
mv mioFile /home/john/otherDir/tuo //sposta il file nella directory otherDir
 e lo rinomina col nome tuo
\end_layout

\begin_layout Itemize
mv -i mioFile tuoFile //rinomina il file, chiedendo conferma nel caso di
 sovrascrittura
\end_layout

\begin_layout Standard
N.B.:La flessibilità di linux può danneggiare il sisteam, infatti è buona
 norma sempre utilizzare i comandi mv e cp con il flag '-i', è anche possibile
 automatizzare l'operazione utilizzando degli alias.
\end_layout

\begin_layout Paragraph
Rm, shred ed Unlink
\end_layout

\begin_layout Standard
Il comando 
\begin_inset Quotes eld
\end_inset

rm
\begin_inset Quotes erd
\end_inset

, è utilizzato per rimuovere file (non nascosti), vediamo alcuni esempi:
\end_layout

\begin_layout Itemize
rm nomeFile //elimina il file chiamato nomeFile
\end_layout

\begin_layout Itemize
rm -r nomeDirectory //elimina la directory, il flag 
\begin_inset Quotes eld
\end_inset

-r
\begin_inset Quotes erd
\end_inset

 indica di utilizzare la modalità ricorsiva, in modo da eliminare directory
 e sottodirectory
\end_layout

\begin_layout Itemize
rm -rf (cancella tutti i file di configurazione) viene fatto in /etc per
 cancellare tutte le configurazioni del server
\end_layout

\begin_layout Standard
per rimuovere tutti i file nascosti possiamo utilizzare:
\end_layout

\begin_layout Itemize
rm -r .*
\end_layout

\begin_layout Standard
Per rimuovere un link ad un file o ad una directory utilizziamo il comando:
\end_layout

\begin_layout Itemize
unlink nomeFileODirectoryLink (rimuove il link)
\end_layout

\begin_layout Standard
per rimuovere un file in modo che non possa essere pià recuperato possiamo
 usare 
\begin_inset Quotes eld
\end_inset

shred
\begin_inset Quotes erd
\end_inset

 ad esempio:
\end_layout

\begin_layout Itemize
shred nomeFile //elimina un file in modo che non possa essere più recuperato
\end_layout

\begin_layout Paragraph
Mkdir
\end_layout

\begin_layout Standard
Il comando 
\begin_inset Quotes eld
\end_inset

mkdir
\begin_inset Quotes erd
\end_inset

 è utilizzato per creare directory, l'esempio classico di applicazione è:
\end_layout

\begin_layout Itemize
mkdir nomeDir //crea una directory chiamata nomeDir nella locazione corrente
\end_layout

\begin_layout Itemize
mkdir -p nomeDir1/nomeDir2 //crea la directory nomeDir2 e se nomeDir1 non
 esiste, quest'ultima viene creata
\end_layout

\begin_layout Itemize
mkdir -p work/{d1,d2}/{src,bin,bak} //crea un intero albero di directory
\end_layout

\begin_layout Paragraph
Time
\end_layout

\begin_layout Standard
Il comando 
\begin_inset Quotes eld
\end_inset

time
\begin_inset Quotes erd
\end_inset

 è utilizzato per cronometrare processi/applicazioni, l'esempio classico
 di applicazione è:
\end_layout

\begin_layout Itemize
time nomeProgramma//fornisce il tempo che ci ha messo il programma ad essere
 eseguito
\end_layout

\begin_layout Itemize
time read //questo è un cronometro, che può essere fermato con 
\begin_inset Quotes eld
\end_inset

Ctrl+d
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Il comando 
\begin_inset Quotes eld
\end_inset

time
\begin_inset Quotes erd
\end_inset

 ci fornirà tre risultati:
\end_layout

\begin_layout Itemize
real //tempo totale impiegato per portare a termine il programma, qui si
 tiene conto anche dei time slice usati da altri processi, o il tempo speso
 da stato 
\begin_inset Quotes eld
\end_inset

bloccato
\begin_inset Quotes erd
\end_inset

 (ad esempio se sta aspettando I/O), mentre negli altri due casi spiegati
 sotto, si tiene conto solo del tempo in esecuzione
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
The elapsed (real) time between invocation of utility and its termination.
\end_layout

\end_deeper
\begin_layout Itemize
user //tempo passato in user-space speso in esecuzione
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
The User CPU time, equivalent to the sum of the tms_utime and tms_cutime
 fields returned by the times() function defined in the System Interfaces
 volume of POSIX.1-2008 for the process in which utility is executed.
\end_layout

\end_deeper
\begin_layout Itemize
sys //tempo passato in kernel space speso in esecuzione
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
The System CPU time, equivalent to the sum of the tms_stime and tms_cstime
 fields returned by the times() function for the process in which utility
 is executed.
\end_layout

\end_deeper
\begin_layout Paragraph
Timeout
\end_layout

\begin_layout Standard
Il comando timeout, serve ad eseguire un comando e a terminarlo dopo uno
 specifico tempo se questo non termina prima, vediamo qualche esempio:
\end_layout

\begin_layout Itemize
timeout -s 9 60 "ls -lR /" //in questo caso viene eseguito il comando ls
 per elencare tutti i file sul filesystem, se questo non termina entro 60
 secondi, allora viene terminato con un segnale 
\begin_inset Quotes eld
\end_inset

-s
\begin_inset Quotes erd
\end_inset

 di tipo 
\begin_inset Quotes eld
\end_inset

9
\begin_inset Quotes erd
\end_inset

 cioè 
\begin_inset Quotes eld
\end_inset

kill
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Paragraph*
Touch
\end_layout

\begin_layout Standard
Il comando 
\begin_inset Quotes eld
\end_inset

touch
\begin_inset Quotes erd
\end_inset

 è utilizzato per creare file, vediamo alcuni esempi di applicazione è:
\end_layout

\begin_layout Itemize
touch nomeFile //crea un file chiamato 
\begin_inset Quotes eld
\end_inset

nomeFile
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
touch -a nomeFile //modifica la data dell'ultimo accesso a quando viene
 effettuato il comando
\end_layout

\begin_layout Itemize
touch -m nomeFile //modifica la data dell'ultima modifica a quando viene
 effettuato il comando
\end_layout

\begin_layout Itemize
touch -r referenceFile nomeFile //modifica i timestamps del file nomeFile
 impostandoli uguali a quelli del file referenceFile
\end_layout

\begin_layout Standard
N.B.: Per visualizzare i timestamps, possiamo utilizzare il comando 
\begin_inset Quotes eld
\end_inset

stat
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Paragraph
Stat
\end_layout

\begin_layout Standard
Il comando 
\begin_inset Quotes eld
\end_inset

stat
\begin_inset Quotes erd
\end_inset

 è utilizzato per visualizzare tutte le informazioni su un qualsiasi file,
 l'esempio classico di applicazione è:
\end_layout

\begin_layout Itemize
stat nomeFile //visualizza tutte le informazioni per il file 
\begin_inset Quotes eld
\end_inset

nomeFile
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Paragraph*
Su
\end_layout

\begin_layout Standard
Il comando su è utilizzato per cambiare utente (infatti su sta per switch
 user), veidiamo due classici esempi applicativi:
\end_layout

\begin_layout Itemize
su nomeutente (cambia utente, da quello attuale a nomeutente)
\end_layout

\begin_layout Itemize
su - nomeutente (cambia utente, da quello attuale a nomeutente, come se
 venisse fatto il login, quindi viene fatto un cd diretto alla home dell'utente
 con cui si logga), questo è anche utilizzato ogni qualvolta vengono effettuate
 delle modifiche sui gruppi, in modo da evitare il relogin dell'utente
\end_layout

\begin_layout Paragraph
Realpath e Readlink
\end_layout

\begin_layout Standard
Sono due comandi per visualizzare informazioni sul percorso di un file,
 nello specifico:
\end_layout

\begin_layout Itemize
realpath nomeFile.ogg //in questo caso visualizzaremo il percorso assoluto
 del file passato come parametro, o nel caso venisse passato un link, questo
 comando mostra il vero percorso del file originale
\end_layout

\begin_layout Itemize
readlink nomeFile.ogg //è equivalente al programma realpath ma mostra il
 percorso relativo del link simbolico
\end_layout

\begin_layout Itemize
readlink -f nomeFile.ogg //è equivalente al programma realpath
\end_layout

\begin_layout Paragraph
Sudo
\end_layout

\begin_layout Standard
Il comando sudo è utilizzato per eseguire comandi con i diritti di un altro
 utente, se ad esempio per avviare una determinata applicazione abbiamo
 bisogno momentaneamente dei diritti del proprietario dell'applicazione
 o dell'amministratore, allora il comando sudo è molto utile in questi casi;
 vediamone alcuni esempi applicativi:
\end_layout

\begin_layout Itemize
sudo comando //effettua un comando come se fossi un altro utente, caso tipico
 è quando si cerca di effettuare un comando con i diritti di root
\end_layout

\begin_layout Itemize
sudo !! //esegue il comando precedentemente eseguit con i comandi di root
\end_layout

\begin_layout Itemize
sudo su //sfrutta i permessi di root, per entrare nella shell dell'amministrator
e
\end_layout

\begin_layout Itemize
sudo -K //dimentica la passwordo di sudo immediatamente, utile per fare
 in modo che altri dopo di me non possano utilizzare il tempo di sudo messo
 a disposizione senza che io reinserisca la password
\end_layout

\begin_layout Itemize
visudo //apre il file /etc/sudoers con cui posso impostare la configurazione
 di sudo, una guida è 
\begin_inset CommandInset href
LatexCommand href
name "Sudoers Explanation"
target "http://cavepopo.hd.free.fr/wordpress/linux/sudo-command-sudoers-file-concepts-and-practical-examples/"

\end_inset


\end_layout

\begin_layout Standard
Il file /etc/sudoers serve a listare gli utenti che possono effettuare sudo,
 con le relative impostazioni.
 La differenza tra le RedHat based e le Debian based è che le Debian based
 hanno solo la categoria 
\begin_inset Quotes eld
\end_inset

sudo
\begin_inset Quotes erd
\end_inset

 per fare sudo mentre le RH usano il gruppo 
\begin_inset Quotes eld
\end_inset

wheel
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Paragraph*
W, id, groups, finger
\end_layout

\begin_layout Standard
Il comando w, è utilizzato per visualizzare tutti gli utenti che hanno effettuat
o il login su una macchina, si lancia semplicemente con:
\end_layout

\begin_layout Itemize
w //elenca tutti gli utenti loggati su una macchina
\end_layout

\begin_layout Itemize
id //mostra informazioni sui gruppi di appartenenza dell'utente loggato
\end_layout

\begin_layout Itemize
finger //se installato mostra informazioni sull'utente
\end_layout

\begin_layout Itemize
groups //mostra i gruppi di appartenenza senza menzionare il group id
\end_layout

\begin_layout Paragraph
Who
\end_layout

\begin_layout Standard
Mostra chi è loggato, possiamo usarlo come:
\end_layout

\begin_layout Itemize
who //mostra gli utenti loggati
\end_layout

\begin_layout Itemize
who -r //mostra il runlevel attuale della macchina
\end_layout

\begin_layout Paragraph*
Man, Info, Apropos, Help e –help
\end_layout

\begin_layout Standard
Questi sono due comandi utili per avere informazioni sui programmi.
\end_layout

\begin_layout Itemize
nomeprogramma –help //mi fornisce un tutorial del programma
\end_layout

\begin_layout Itemize
man comando //mi fornisce informazioni sul comando, e gli eventuali flag
 applicabili per l'avvio; a volte il man è applicabile anche a file di sistema
 come /etc/resolv.conf, anche se molte volte è solo un reference e non un
 vero e proprio tutorial o una vera guida
\end_layout

\begin_layout Itemize
man -k parolaChiave //molto utile nel momento in cui non conosciamo il comando
 utile per un'azione specifica, o quando in genere non conosciamo il nome
 del comando che ci serve, infatti attraverso il flag 
\begin_inset Quotes eld
\end_inset

-k
\begin_inset Quotes erd
\end_inset

 posso cercare per parole chiave (penso stia per 
\begin_inset Quotes eld
\end_inset

keyword
\begin_inset Quotes erd
\end_inset

), ad esempio 
\begin_inset Quotes eld
\end_inset

man -k sort
\begin_inset Quotes erd
\end_inset

 mi cercherà tutti i programmi che hanno nel loro man la parola 
\begin_inset Quotes eld
\end_inset

sort
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
man -k file | search //questo è molto comodo per cercare una determinata
 funzionalità, in questo caso sto cercando utility per cercare file o ad
 esempio cercare nei file e così via, posso usarlo anche con apropos
\end_layout

\begin_layout Itemize
man -K parolaChiave //molto utile in quanto cerca la parola menzionata in
 tutte le pagine di man, ma non guarda a differenza del flag 
\begin_inset Quotes eld
\end_inset

-k
\begin_inset Quotes erd
\end_inset

 solo nel titolo, ma anche all'interno della pagina di man, infatti questa
 è una more in-depth search by matching the keywords found in the whole
 articles
\end_layout

\begin_layout Itemize
man -s 7 -k ".*" //in questo modo vediamo la lista di tutte le pagine man
 della sezione 7
\end_layout

\begin_layout Itemize
man -t ascii | ps2pdf - > ascii.pdf //crea un pdf della pagina di manuale
\end_layout

\begin_layout Itemize
manpath //mostra il percorso in cui sono trovate le pagine di man, un'alternativ
a è 
\begin_inset Quotes eld
\end_inset

echo $MANPATH
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
man -f passwd //molto utile, in quanto mostra le varie pagine di man disponibili
 del comando 
\begin_inset Quotes eld
\end_inset

passwd
\begin_inset Quotes erd
\end_inset

, ad esempio a passwd possiamo accederci attraverso 
\begin_inset Quotes eld
\end_inset

man 1 passwd
\begin_inset Quotes erd
\end_inset

 o 
\begin_inset Quotes eld
\end_inset

man 1ssl passwd
\begin_inset Quotes erd
\end_inset

 oppure 
\begin_inset Quotes eld
\end_inset

man 5 passwd
\begin_inset Quotes erd
\end_inset

, vedere sotto per il significato dei numeri
\end_layout

\begin_layout Standard
Quando sono in man o in help, posso schiacciare il tasto slash seguito da
 una parola per cercare la parola all'interno del testo.
 Oppure se si vuole sfruttare la potenza di vim, possiamo salvare una funzione
 nel nostro file di configurazione shell (e.g., .bashrc, .zshrc) ad esempio:
\end_layout

\begin_layout Itemize
vman() { vim <(man $1); } //ora utilizzando 
\begin_inset Quotes eld
\end_inset

vman ls
\begin_inset Quotes erd
\end_inset

 ad esempio, possiamo visualizzare la pagina di man in vim
\end_layout

\begin_layout Itemize
man -P cat passwd > passwd_man_page.txt //questa tecnica permette di salvare
 la pagina di man in un file di testo
\end_layout

\begin_layout Standard
La pagine di man possono essere referenziate da un numero, potremo ad esempio
 trovare 
\begin_inset Quotes eld
\end_inset

ls(1)
\begin_inset Quotes erd
\end_inset

 o 
\begin_inset Quotes eld
\end_inset

route(8)
\begin_inset Quotes erd
\end_inset

, questi numeri rappresentano la categoria del comando, infatti i numeri
 significano:
\end_layout

\begin_layout Enumerate
User Commands
\end_layout

\begin_layout Enumerate
System Calls
\end_layout

\begin_layout Enumerate
Higher-Level Unix programming library documentation
\end_layout

\begin_layout Enumerate
Device interface and driver information
\end_layout

\begin_layout Enumerate
File descriptions (system configuration files)
\end_layout

\begin_layout Enumerate
Games
\end_layout

\begin_layout Enumerate
File formats, conventions, and encodings (ASCII, suffixes,ecc...)
\end_layout

\begin_layout Enumerate
System commands and servers
\end_layout

\begin_layout Standard
Possiamo ad esempio selezionare una pagina man dalla sezione, infatti 
\begin_inset Quotes eld
\end_inset

man passwd
\begin_inset Quotes erd
\end_inset

 potrebbe essere ambiguo, in quanto potrebbe sia riferirsi al comando 
\begin_inset Quotes eld
\end_inset

passwd
\begin_inset Quotes erd
\end_inset

 utilizzato per impostare una password, oppure potrebbe riferirsi al file
 
\begin_inset Quotes eld
\end_inset

/etc/passwd
\begin_inset Quotes erd
\end_inset

, il file dove sono contenute le informazioni sugli utenti, il comando man
 di default visualizza la prima pagina man trovata, per evitare questo comportam
ento possiamo specificare la pagina di man attraverso:
\end_layout

\begin_layout Itemize
man 5 passwd //visualizza il man con la spiegazione del file /etc/passwd,
 in questo caso abbiamo specificato 5, facendo capire al sistema che ci
 stiamo riferendo al file e non al comando, infatti un 
\begin_inset Quotes eld
\end_inset

man passwd
\begin_inset Quotes erd
\end_inset

 avrebbe visualizzato la prima pagina di man trovata che sarebbe stata quella
 del comando e cioè passwd(1)
\end_layout

\begin_layout Itemize
man -f passwd //mostra tutte le possibili pagine consultabili sotto il nome
 
\begin_inset Quotes eld
\end_inset

passwd
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Per quanto riguarda la 
\begin_inset Quotes eld
\end_inset

synopsis
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Standard
The synopsis section usually gives some example use-cases.
 Sometimes sub-commands have different options, so several examples might
 be shown.
 
\end_layout

\begin_layout Itemize
Brackets [] always denote optional switches, arguments, options, etc.
 
\end_layout

\begin_layout Itemize
the pipe | means 
\begin_inset Quotes eld
\end_inset

or
\begin_inset Quotes erd
\end_inset

, particularly when inside brackets or parenthesis.
 
\end_layout

\begin_layout Itemize
Brackets in brackets just means that the second part is dependent on the
 first, and also itself optional.
 Some switches you can use on their own or add a value to them.
 
\end_layout

\begin_layout Itemize
Commas at the start of a bracket would indicate there can be multiple comma
 separated values, e.g., [-m system[,...]]
\end_layout

\begin_layout Itemize
They lean on Regex concepts, but are meant to be human readable so don't
 follow all the escaping rules etc.
\end_layout

\begin_layout Standard
Poi da less, è comodo utilizzare i marker, cioè possiamo salvare una posizione
 nella pagina con 
\begin_inset Quotes eld
\end_inset

 m lettera 
\begin_inset Quotes erd
\end_inset

, e dopo ritornare a quel marker con 
\begin_inset Quotes eld
\end_inset

 ' lettera 
\begin_inset Quotes eld
\end_inset

.
\end_layout

\begin_layout Standard
Qualche tempo fa, il progetto GNU mostrò poco piacere nei confronti delle
 pagine man, e creò una propria utility per mostrare la documentazione,
 chiamata 
\begin_inset Quotes eld
\end_inset

info
\begin_inset Quotes erd
\end_inset

, che talvolta può essere più completa e più complessa, per lanciarlo possiamo
 eseguire:
\end_layout

\begin_layout Itemize
info nomeComando //mostra la documentazione info per il comando, possiamo
 provarlo ad esempio col comando 
\begin_inset Quotes eld
\end_inset

find
\begin_inset Quotes erd
\end_inset

 per vedere quanto è più completo rispetto al comando 
\begin_inset Quotes eld
\end_inset

man
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Alcuni programmi non rendono disponibile una documentazione disponibile
 attraverso 
\begin_inset Quotes eld
\end_inset

man
\begin_inset Quotes erd
\end_inset

 o 
\begin_inset Quotes eld
\end_inset

info
\begin_inset Quotes erd
\end_inset

, in questo caso dobbiamo andare a cercarla nella directory 
\begin_inset Quotes eld
\end_inset

/usr/share/doc/
\begin_inset Quotes erd
\end_inset

 oppure online attraverso internet.
\end_layout

\begin_layout Standard
Il man ha un output non colorato, una utility che ci può facilitare la vita
 rendendo l'output più user friendly è 
\begin_inset Quotes eld
\end_inset

most
\begin_inset Quotes erd
\end_inset

, possiamo installarlo e poi impostarlo come pager principale, in quanto
 di default, man usa 
\begin_inset Quotes eld
\end_inset

less
\begin_inset Quotes erd
\end_inset

 come pager, per impostarlo come pager principale in sistemi Debian-based
 eseguiamo:
\end_layout

\begin_layout Itemize
sudo update-alternatives –set pager /usr/bin/most //imposta most come pager
 di default, molto utile per una lettura più user-fiendly delle pagine di
 man
\end_layout

\begin_layout Standard
in realtà generalmente (senza dover imparare questo comando valido solo
 per le debian based) ci basta impostare una variabile d'ambiente chiamata
 
\begin_inset Quotes eld
\end_inset

PAGER
\begin_inset Quotes erd
\end_inset

, questo vale su tutti i sistemi Linux e anche su FreeBSD (non so se pure
 sugli altri BSD), possiamo quindi cambiare pager eseguendo:
\end_layout

\begin_layout Itemize
export PAGER=most //il pager viene settato a 
\begin_inset Quotes eld
\end_inset

most
\begin_inset Quotes erd
\end_inset

, possiamo eseguire 
\begin_inset Quotes eld
\end_inset

man man
\begin_inset Quotes erd
\end_inset

 per verificare il risultato, ovviamente dobbiamo ricordarci di imporlo
 nel file di configurazione della shell utilizzata
\end_layout

\begin_layout Standard
Un'altro modo comodo per cercare comandi è utilizzando:
\end_layout

\begin_layout Itemize
apropos stringaDaCercare //in questo caso vengono cercati tutti i comandi
 relativi alla stringa 
\begin_inset Quotes eld
\end_inset

stringaDaCercare
\begin_inset Quotes erd
\end_inset

, ad esempio possiamo provare 
\begin_inset Quotes eld
\end_inset

apropos disk
\begin_inset Quotes erd
\end_inset

, e verranno mostrati tutti i comandi che hanno nella descrizione generale
 la parola 
\begin_inset Quotes eld
\end_inset

disk
\begin_inset Quotes erd
\end_inset

, è analogo a 
\begin_inset Quotes eld
\end_inset

man -k
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
apropos -a keyword1 keyword2 //effettua una ricerca facendo una and delle
 stringhe menzionate, per effettuare ricerche più avanzate, a differenza
 di un semplice 
\begin_inset Quotes eld
\end_inset

man -k
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Apropos è aggiornato attraverso il comando 
\begin_inset Quotes eld
\end_inset

mandb
\begin_inset Quotes erd
\end_inset

, che a differenza della configurazione può essere aggiornato con un cron
 job, o manualmente o quando avvengono aggiornamenti, possiamo comunque
 forzare l'aggiornamento eseguendo:
\end_layout

\begin_layout Itemize
mandb //Aggiorna il database delle pagine di manuale per apropos
\end_layout

\begin_layout Standard
N.B.: A volte se siamo in cerca di esempio e non li troviamo nelle pagine
 di 
\begin_inset Quotes eld
\end_inset

man
\begin_inset Quotes erd
\end_inset

 e di 
\begin_inset Quotes eld
\end_inset

info
\begin_inset Quotes erd
\end_inset

, possiamo cercarli all'interno della directory 
\begin_inset Quotes eld
\end_inset

/usr/share/doc
\begin_inset Quotes erd
\end_inset

 al suo interno dobbiamo cercare il nome del pacchetto e al suo interno
 a volte esiste una directory chiamata 
\begin_inset Quotes eld
\end_inset

examples
\begin_inset Quotes erd
\end_inset

, qui possiamo trovare degli esempi di applicazione.
\end_layout

\begin_layout Standard
N.B: se evidenziamo una parola e poi premiamo 
\begin_inset Quotes eld
\end_inset

Shift+k
\begin_inset Quotes erd
\end_inset

 possiamo andare alla pagina di man relativa alla parola selezionata.
\end_layout

\begin_layout Standard
Per i comandi builtin della shell, non esiste una pagina di man, per questi
 possiamo eseguire il comando 
\begin_inset Quotes eld
\end_inset

help
\begin_inset Quotes erd
\end_inset

 in bash, ad esempio:
\end_layout

\begin_layout Itemize
help cd //mostra informazioni per il comando cd
\end_layout

\begin_layout Itemize
help -m cd //mostra informazioni per il comando cd in un formato 
\begin_inset Quotes eld
\end_inset

man page
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
help //mostra la lista dei comandi builtin
\end_layout

\begin_layout Subsubsection*
Pagine Man degne di nota
\end_layout

\begin_layout Standard
Noteworthy manpages
\end_layout

\begin_layout Standard
Here follows a non-exhaustive list of noteworthy pages that might help you
 understand a lot of things more in-depth.
 Some of them might serve as a good reference (like the ascii table).
 
\end_layout

\begin_layout Itemize
ascii(7) 
\end_layout

\begin_layout Itemize
boot(7) 
\end_layout

\begin_layout Itemize
charsets(7) 
\end_layout

\begin_layout Itemize
chmod(1) 
\end_layout

\begin_layout Itemize
credentials(7) 
\end_layout

\begin_layout Itemize
fstab(5) 
\end_layout

\begin_layout Itemize
hier(7) 
\end_layout

\begin_layout Itemize
systemd(1) 
\end_layout

\begin_layout Itemize
locale(1P)(5)(7) 
\end_layout

\begin_layout Itemize
printf(3) 
\end_layout

\begin_layout Itemize
proc(5) 
\end_layout

\begin_layout Itemize
regex(7) 
\end_layout

\begin_layout Itemize
signal(7) 
\end_layout

\begin_layout Itemize
term(5)(7) 
\end_layout

\begin_layout Itemize
termcap(5) 
\end_layout

\begin_layout Itemize
terminfo(5) 
\end_layout

\begin_layout Itemize
utf-8(7)
\end_layout

\begin_layout Paragraph
Clear
\end_layout

\begin_layout Standard
E' un comando utilizzato per spostare il cursore ad inizio pagina, in modo
 da avere una visualizzazione pulita del terminale, si può eseguire con:
\end_layout

\begin_layout Itemize
clear //sposta il cursore del terminale
\end_layout

\begin_layout Paragraph
Less
\end_layout

\begin_layout Standard
E' un programma di paging, utile per leggere file e cercare all'interno
 di essi, possiamo lanciarlo con:
\end_layout

\begin_layout Itemize
less nomeFile
\end_layout

\begin_layout Standard
un'opzione utile è quella di non tagliare le linee, e fornire a less un
 modalità di navigazione oltre che verticale anche orizzontale, questo è
 possibile tramite:
\end_layout

\begin_layout Itemize
less -S nomeFile
\end_layout

\begin_layout Standard
un utile comando da dare a less, per fare in modo di avere una visualizzazione
 real time del file (uguale alla modalità -f del comando 
\begin_inset Quotes eld
\end_inset

tail
\begin_inset Quotes erd
\end_inset

) è premere 
\begin_inset Quotes eld
\end_inset

-F
\begin_inset Quotes erd
\end_inset

 quando stiamo visualizzando il file
\end_layout

\begin_layout Paragraph
Reset
\end_layout

\begin_layout Standard
E' un comando simile a 
\begin_inset Quotes eld
\end_inset

clear
\begin_inset Quotes erd
\end_inset

 ma cancella anche le istruzioni, resettando la shell, risulta utile anche
 quando i caratteri della shell possono inquinarsi con l'utilizzo di determinati
 caratteri:
\end_layout

\begin_layout Itemize
reset //resetta il terminale
\end_layout

\begin_layout Paragraph
Spegnere e Riavviare il sistema
\end_layout

\begin_layout Standard
Vediamo alcuni esempi di comandi:
\end_layout

\begin_layout Itemize
shutdown -h now //spegne il sistema ora, può anche essere usato poweroff
\end_layout

\begin_layout Itemize
shutdown -r now //riavvia il sistema ora, può anche essere usato reboot
\end_layout

\begin_layout Itemize
shutdown -h 20:01//spegne la macchina alle 20:01
\end_layout

\begin_layout Itemize
shutdown -h +5 //spegne la macchina tra 5 minuti
\end_layout

\begin_layout Paragraph
Il parametro 
\begin_inset Quotes eld
\end_inset

–
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
In alcuni comandi possiamo vedere il parametro 
\begin_inset Quotes eld
\end_inset

–
\begin_inset Quotes erd
\end_inset

 questo sta solo a significare che la lista di parametri passata ad un comando
 è finita, e i prossimi sono argomenti utili del programma come file, questo
 parametro esiste in quanto su linux è possibile dare nomi a file che iniziano
 col carattere 
\begin_inset Quotes eld
\end_inset

-
\begin_inset Quotes erd
\end_inset

, facciamo alcuni esempi:
\end_layout

\begin_layout Itemize
touch -al 
\end_layout

\begin_deeper
\begin_layout Itemize
non creerà il file chiamato -al ma darà errore
\end_layout

\end_deeper
\begin_layout Standard
invece 
\end_layout

\begin_layout Itemize
touch – -al 
\end_layout

\begin_deeper
\begin_layout Itemize
creerà il file chiamato -al
\end_layout

\end_deeper
\begin_layout Standard
oppure 
\end_layout

\begin_layout Itemize
ls -al 
\end_layout

\begin_deeper
\begin_layout Itemize
mostrerà ls con le opzioni 
\begin_inset Quotes eld
\end_inset

-a
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

-l
\begin_inset Quotes erd
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
mentre 
\end_layout

\begin_layout Itemize
ls -al – -al //mostrerà informazioni sul file 
\begin_inset Quotes eld
\end_inset

-al
\begin_inset Quotes erd
\end_inset

, in quanto il primo 
\begin_inset Quotes eld
\end_inset

-al
\begin_inset Quotes erd
\end_inset

 indica proprio le opzioni 
\begin_inset Quotes eld
\end_inset

-a
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

-l
\begin_inset Quotes erd
\end_inset

 mentre l'ultimo siccome è posizionato dopo 
\begin_inset Quotes eld
\end_inset

–
\begin_inset Quotes erd
\end_inset

 indica il nome di un file.
\end_layout

\begin_layout Paragraph
Il parametro 
\begin_inset Quotes eld
\end_inset

-
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Questo parametro lasciato da solo, può non voler dire nulla, ma alcuni programmi
 lo usano per indicare al programma di leggere dati dallo standard input,
 quindi ad esempio viene usato spesso nei comandi utilizzanti la pipe 
\begin_inset Quotes eld
\end_inset

|
\begin_inset Quotes erd
\end_inset

.
 Un esempio potrebbe essere:
\end_layout

\begin_layout Itemize
cat videoName.mp4 | vlc - //in questo caso indichiamo al programma vlc di
 leggere dallo standard input
\end_layout

\begin_layout Standard
comunque non per tutti i programmi questo comportamento è valido, infatti
 alcuni programmi considereranno il parametro 
\begin_inset Quotes eld
\end_inset

-
\begin_inset Quotes erd
\end_inset

 come nome di un file, o verrà utilizzato comunque per altri scopi.
 N.B.: For traditional UNIX programs that behave as filters the - is superfluous.
\end_layout

\begin_layout Subsection
Directory principali in un sistema GNU/Linux
\end_layout

\begin_layout Standard
Le funzioni relative alle directory di un filesystem utilizzato su macchine
 GNU/Linux viene specificato all'interno del documento chiamato FHS (Filesystem
 Hierarchy Standard), oppure da terminale attraverso il comando 
\begin_inset Quotes eld
\end_inset

man hier
\begin_inset Quotes erd
\end_inset

; di seguito viene riportato lo scopo delle principali directory:
\end_layout

\begin_layout Itemize
/boot 
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Contiene informazioni e file per fare il boot della macchina, solitamente
 questa directory risiede su una partizione a parte, ed è importante non
 avere una partizione troppo piccola di boot, in quanto, quando viene compilato
 un nuovo kernel i file vengono messi all'interno di questa directory
\end_layout

\end_deeper
\begin_layout Itemize
/bin 
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
E' la directory in cui sono contenuti gli eseguibili
\end_layout

\end_deeper
\begin_layout Itemize
/sbin 
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
E' la directory in cui sono contenuti i 
\begin_inset Quotes eld
\end_inset

system binaries
\begin_inset Quotes erd
\end_inset

 la maggior parte di questi programmi sono eseguibili solo dall'amministratore
 di sistema (root), in quanto riguardo il 
\begin_inset Quotes eld
\end_inset

system management
\begin_inset Quotes erd
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
/lib 
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
E' dove sono collocate le librerie shared, mentre in /usr/lib sono contenute
 sia quelle static che quelle shared
\end_layout

\end_deeper
\begin_layout Itemize
/opt 
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
E' la directory dove vengono installati i programmi che non sono inclusi
 nei repository, o cosiddetti 
\begin_inset Quotes eld
\end_inset

third-party software
\begin_inset Quotes erd
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
/media
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
E' dove vengono montati automaticamente dispositivi 
\begin_inset Quotes eld
\end_inset

media
\begin_inset Quotes erd
\end_inset

 rimovibili, come floppy disk, CD-ROM, DVD, USB Disk Drives, etc...
\end_layout

\end_deeper
\begin_layout Itemize
/usr 
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
E' dove risiedono la maggior parte dei programmi appartenenti all userland,
 tutto quello che installiamo dai repository della nostra distro va qui,
 eccetto probabili casi particolari, contiene una struttura simile a quella
 di /, infatti possiamo vedere directory come 
\begin_inset Quotes eld
\end_inset

/usr/bin
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

/usr/sbin
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

/usr/lib
\begin_inset Quotes erd
\end_inset

, ecc...
\end_layout

\end_deeper
\begin_layout Itemize
/usr/local
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
E' dove risiedono i programmi compilati manualmente sulla macchina
\end_layout

\end_deeper
\begin_layout Itemize
/usr/share/man
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
E' dove risiedono le pagine di man e la documentazione
\end_layout

\end_deeper
\begin_layout Itemize
/usr/share/info
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Simile alla precedente
\end_layout

\end_deeper
\begin_layout Itemize
/usr/include
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
E' dove risiedono gli header file utilizzati dal compilatore C
\end_layout

\end_deeper
\begin_layout Itemize
/usr/lib 
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
E' dove sono contenuti i moduli (o driver) che possono essere caricati (o
 che vengono caricati) dal kernel, i cosiddetti 
\begin_inset Quotes eld
\end_inset

loadable kernel modules
\begin_inset Quotes erd
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
/mnt
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
E' dove vengono effettuate le mount manuali, di filesystem di rete, o partizioni
 fisse sul nostro sistema
\end_layout

\end_deeper
\begin_layout Itemize
/root 
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
E' la home directory per l'utente root
\end_layout

\end_deeper
\begin_layout Itemize
/var 
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
E' una directory adibita a:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
file di log 
\end_layout

\begin_layout Itemize
file di mail
\end_layout

\begin_layout Itemize
file di cache
\end_layout

\begin_layout Itemize
mysql
\end_layout

\begin_layout Itemize
librerie
\end_layout

\begin_layout Itemize
directory di default per l'installazione di siti web
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
/tmp 
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
E' una directory temporanea ed è utilizzata dai programmi per scrivere ed
 elaborare dati temporaneamente, di default solitamente viene automaticamente
 svuotata tra i vari reboot di sistema
\end_layout

\end_deeper
\begin_layout Itemize
/var/tmp
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
E' simile a 
\begin_inset Quotes eld
\end_inset

/tmp
\begin_inset Quotes erd
\end_inset

 solo che non viene ripulita tra i reboot di sistema
\end_layout

\end_deeper
\begin_layout Itemize
/mnt 
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
E' è una directory adibita a quando si montano le partizioni
\end_layout

\end_deeper
\begin_layout Itemize
/dev 
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
E' un filesystem dinamico che risiede in RAM, le sue entrate sono create
 e rimosse dal kernel e da udev; in questa directory sono presenti tutti
 i file che rappresentano dispositivi hardware, in linux ogni componente
 hardware viene rappresentato da un file, vari comandi possono essere mandati
 ai dispositivi o si può leggere da essi, ad esempio:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
cat /dev/random > somefile.txt //scriverà delle cose casuali all'interno
 del file somefile.txt
\end_layout

\end_deeper
\begin_layout Itemize
N.B.: E' da notare che nonostante sia /dev che /sys operano col kernel, in
 realtà /sys è ad un livello d'astrazione più basso e generalmente quello
 che vediamo in /dev è fornito da un'elaborazione di quello che c'è in /sys
\end_layout

\end_deeper
\begin_layout Itemize
/sys
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
E' un filesystem virtuale che risiede in RAM, fornisce strutture dati dal
 kernel e loro attributi e i collegamenti che hanno allo userspace, per
 poter effetuare un tuning dell'hardware con maggiore flessibilità
\end_layout

\end_deeper
\begin_layout Itemize
/proc 
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
E' un filesystem virtuale che risiede in RAM, praticamente effettua delle
 richieste di informazioni al kernel, ed è adibito a contenere informazioni
 sul sistema linux, la distribuzione e l'hardware, questo filesystem viene
 creato da linux; seguendo il concetto del 
\begin_inset Quotes eld
\end_inset

tutto è un file
\begin_inset Quotes erd
\end_inset

, all'interno di questo filesystem virtuale troviamo informazioni su:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Componenti Hardware
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
/proc/cpuinfo – informazioni sulla cpu
\end_layout

\begin_layout Itemize
/proc/meminfo – informazioni sulla memoria
\end_layout

\begin_layout Itemize
/proc/loadavg – average system load
\end_layout

\begin_layout Itemize
/proc/version – current linux version
\end_layout

\end_deeper
\begin_layout Itemize
Informazioni sui processi attivi sul sistema: sono strutturati secondo directory
 che prendono il nome dall'identificativo del processo (PID) e contengono:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
cwd – link alla directory di lavoro del processo
\end_layout

\begin_layout Itemize
exe – link all'eseguibile
\end_layout

\begin_layout Itemize
root – directory del processo padre
\end_layout

\begin_layout Itemize
environ – variabili d'ambiente lette dal processo
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Possiamo usarlo anche per vedere che file ha aperto un processo, infatti
 in ogni cartella relativa ai processi esiste una directory chiamata 
\begin_inset Quotes eld
\end_inset

fd
\begin_inset Quotes erd
\end_inset

, questa contiene i file aperti, possiamo quindi capire quali file apre
 un processo, o se un processo effettivamente spia dei file
\end_layout

\end_deeper
\begin_layout Itemize
/var/log 
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
E' dove vengono salvati i log
\end_layout

\end_deeper
\begin_layout Itemize
/etc/init.d 
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
E' la directory dove vengono inseriti programmi o servizi che possono essere
 riavviati, avviati o bloccati, inoltri sono contenuti i processi che vengono
 avviati subito dopo l'inizializzazione del kernel.
 Nello specifico i file contenuti in questa directory sono script che rispondono
 a comandi di start, stop, restart e (quando supportato) reload.
 Questi script possono essere invocati direttamente o più comunemente attraverso
 altri trigger costituiti da link simbolici nelle directory 
\begin_inset Quotes eld
\end_inset

/etc/rc?.d
\begin_inset Quotes erd
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
N.B.: La 
\begin_inset Quotes eld
\end_inset

.d
\begin_inset Quotes erd
\end_inset

 alla fine del nome di un file sta ad indicare che quel file è una directory
 che contiene file di configurazione o script per una particolare situazione.
\end_layout

\begin_layout Standard
N.B.2: Le directory /sys e /proc sembrano simili, ma in realtà la prima riguarda
 più parametri e file operanti sull'hardware mentre la seconda si occupa
 delle stesse cose, però riguardanti i processi; /dev e /sys sono state
 seprate in quanto questo permette un tuning dell'hardware più fine e pulito.
\end_layout

\begin_layout Standard
N.B.3: Il kernel è situato in un file chiamato 
\begin_inset Quotes eld
\end_inset

vmlinuz
\begin_inset Quotes erd
\end_inset

, o anticamente 
\begin_inset Quotes eld
\end_inset

vmlinux
\begin_inset Quotes erd
\end_inset

, ed è collocato o in /vmlinuz o più comunemente in 
\begin_inset Quotes eld
\end_inset

/boot/vmlinuz
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Section
Gestione degli Utenti e dei Gruppi
\end_layout

\begin_layout Paragraph*
Useradd
\end_layout

\begin_layout Itemize
useradd nomeutente //crea un utente
\end_layout

\begin_layout Itemize
useradd username -m //il flag 
\begin_inset Quotes eld
\end_inset

-m
\begin_inset Quotes erd
\end_inset

 mi crea la home directory per l'utente username, dovrebbe essere l'opzione
 di default
\end_layout

\begin_layout Itemize
useradd username -m -G video,wheel,audio //il flag 
\begin_inset Quotes eld
\end_inset

-G
\begin_inset Quotes erd
\end_inset

 mi setta i gruppi di appartenenza dell'utente username
\end_layout

\begin_layout Itemize
useradd username -M //crea uno username chiamato username ma non crea la
 directory home per questo utente
\end_layout

\begin_layout Itemize
useradd username -m -k /etc/skelTech //crea un utente chiamato username
 e copia nella home directory il contenuto della directory 
\begin_inset Quotes eld
\end_inset

skelTech
\begin_inset Quotes erd
\end_inset

, è da ricordare che di default, se non viene specificato il flag 
\begin_inset Quotes eld
\end_inset

-k
\begin_inset Quotes erd
\end_inset

 i file che vengono copiati nella nuova home sono contenuti in 
\begin_inset Quotes eld
\end_inset

/etc/skel/
\begin_inset Quotes erd
\end_inset

.
 Questo flag è molto utile in quanto mi permette di creare dei template
 di utenti
\end_layout

\begin_layout Itemize
useradd -c Antonio -e 2013-12-31 nomeUtente //crea un nuovo utente di nome
 nomeUtente, con full name 
\begin_inset Quotes eld
\end_inset

Antonio
\begin_inset Quotes erd
\end_inset

 attraverso il flag 
\begin_inset Quotes eld
\end_inset

-c
\begin_inset Quotes erd
\end_inset

 e con data di scadenza impostata al 2013-12-31 attraverso il flag 
\begin_inset Quotes eld
\end_inset

-e
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Le impostazioni di default del comando useradd sono contenute all'interno
 del file 
\begin_inset Quotes eld
\end_inset

/etc/default/useradd
\begin_inset Quotes erd
\end_inset

, questo file contiene informazioni come, dove salvare la home directory,
 la directory scheletro, la data di scadenza eccetera.
\end_layout

\begin_layout Paragraph*
Passwd
\end_layout

\begin_layout Itemize
passwd nomeutente //cambia o imposta la password
\end_layout

\begin_layout Itemize
passwd -l nomeUtente //disabilita l'utente nomeUtente
\end_layout

\begin_layout Itemize
passwd -u nomeUtente //riabilita l'utente nomeUtente eviene reimpostata
 la password che aveva in precedenza
\end_layout

\begin_layout Standard
Esistono un paio di file nella directory /etc di interesse:
\end_layout

\begin_layout Itemize
/etc/passwd
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
contiene la lista degli utenti, con informazioni relative ad essi come l'id
 dell'utente, l'id del gruppo, se la password è 
\begin_inset Quotes eld
\end_inset

shadowed
\begin_inset Quotes erd
\end_inset

, la posizione della home directory (che è la directory in cui veniamo reindiriz
zati quando effettuiamo il login) e il tipo di shell che utilizzano, questo
 è il luogo perfetto per cercare degli utenti sulla macchina o capire quanti
 utenti esistono.
 Per rendere un account utente inutilizzabile potremo mettere al posto di
 
\begin_inset Quotes eld
\end_inset

/bin/bash
\begin_inset Quotes erd
\end_inset

 il percorso al nologin, che di solito è 
\begin_inset Quotes eld
\end_inset

/usr/sbin/nologin
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_deeper
\begin_layout Itemize
/etc/shadow
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
il file shadow, contiene le password criptate degli utenti, in realtà ogni
 riga è composta da 9 campi separati dal simbolo 
\begin_inset Quotes eld
\end_inset

:
\begin_inset Quotes erd
\end_inset

 che contengono:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
user name:nome di login dell'utente
\end_layout

\begin_layout Enumerate
password: campo contenente la password sottoposta ad un algorithm di hashing
 dell'utente più altre informazioni, infatti questo campo può essere suddiviso
 in tre sottocampi divisi dal carattere 
\begin_inset Quotes eld
\end_inset

$
\begin_inset Quotes erd
\end_inset

, il primo campo è l'algoritmo usato per l'hashing, infatti le possibili
 soluzioni per questo campo sono:
\end_layout

\begin_deeper
\begin_layout Enumerate
$1 = MD5 hashing algorithm
\end_layout

\begin_layout Enumerate
$2 =Blowfish Algorithm 
\end_layout

\begin_layout Enumerate
$2a=eksblowfish Algorithm 
\end_layout

\begin_layout Enumerate
$5 =SHA-256 Algorithm 
\end_layout

\begin_layout Enumerate
$6 =SHA-512 Algorithm
\end_layout

\begin_layout Standard
il secondo campo è il valore del 
\begin_inset Quotes eld
\end_inset

salt
\begin_inset Quotes erd
\end_inset

, mentre il terzo campo è l'hash di salt+password
\end_layout

\end_deeper
\begin_layout Enumerate
last password change: data in cui è stata modificata la password l'ultima
 volta
\end_layout

\begin_layout Enumerate
minimum validity: il minimo numero di giorni richiesti per poter cambiare
 la password
\end_layout

\begin_layout Enumerate
maximum validity: il massimo numero di giorni per cui la password è valida,
 dopo questo numero di giorni l'utente è forzato a cambiare la sua password
\end_layout

\begin_layout Enumerate
warn: numero di giorni prima della scadenza della password, durante i quali
 l'utente viene avvisato della necessità di cambiarla
\end_layout

\begin_layout Enumerate
inactive: durata massima di validità dell'utenza dopo che la password è
 scaduta
\end_layout

\begin_layout Enumerate
expire: data di scadenza dell'utenza
\end_layout

\begin_layout Enumerate
reserved: campo riservato per usi futuri
\end_layout

\begin_layout Standard
E' da notare che le date sono espresse in numero di giorni a partire dal
 1/1/1970, e che per garantire sicurezza il file shadow dovrebbe appartenere
 all'utente root e si abbia esclusivamente il permesso di lettura per il
 proprietario (0400).
\end_layout

\end_deeper
\end_deeper
\begin_layout Paragraph
Userdel
\end_layout

\begin_layout Itemize
userdel nomeUtente //cancella l'utente, quindi non potrà più essere effettuato
 il login a nome suo, ma i suoi file rimangono intatti, quindi la home directory
 non viene cancellata, è da ricordare che se l'utente è loggato, la cancellazion
e non può avvenire
\end_layout

\begin_layout Itemize
userdel -f nomeUtente //cancella l'utente anche se è loggato, alcune distro
 non permettono questa operazione
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
per rimuovere correttamente un utente loggato, basta uccidere il processo
 indicato quando si prova a rimuoverlo con userdel nomeUtente, una volta
 ucciso il processo possiamo procedere con una rimozione normale
\end_layout

\end_deeper
\begin_layout Itemize
userdel -r nomeUtente //cancella l'utente e due sue directory, nello specifico,
 la sua home directory, e il suo spool di mail, eccetera, questo avviene
 attraverso il flag 
\begin_inset Quotes eld
\end_inset

-r
\begin_inset Quotes erd
\end_inset

, è da ricordare che però file al di fuori di queste directory appartenenti
 a nomeUtente non vengono eliminati, è il comando adatto per rimuovere del
 tutto un utente da un sistema
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
quello che viene fatto quando viene avviato questo comando è cancellare
 le voci relastive all'utente nei fil 
\begin_inset Quotes eld
\end_inset

/etc/passwd
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

/etc/shadow
\begin_inset Quotes erd
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
N.B.:Alcune distro hanno anche i comandi 
\begin_inset Quotes eld
\end_inset

deluser
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

adduser
\begin_inset Quotes erd
\end_inset

 che non sono altro che degli script creati per rendere più user-friendly
 e interattive le operazioni di cancellazione e creazione degli utenti.
\end_layout

\begin_layout Paragraph
Chfn
\end_layout

\begin_layout Standard
Questo comando è utile nel momento in cui voglio cambiare le informazioni
 aggiuntive sull'utente come nome completo 
\begin_inset Quotes eld
\end_inset

fullname
\begin_inset Quotes erd
\end_inset

, numero di telefono, interno, ecc...
\end_layout

\begin_layout Itemize
chfn //avvia la procedura guidata di sostituzione dati aggiuntivi
\end_layout

\begin_layout Paragraph
Chsh
\end_layout

\begin_layout Standard
Questo comando è utile per cambiare il tipo di shell dell'utente
\end_layout

\begin_layout Itemize
chsh //avvia la procedura guidata per cambiare il tipo di shell
\end_layout

\begin_layout Paragraph*
Usermod
\end_layout

\begin_layout Itemize
usermod -G wheel,video nomeUtente //imposta i gruppi 
\begin_inset Quotes eld
\end_inset

wheel
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

video
\begin_inset Quotes erd
\end_inset

 come gruppi secondari all'utente nomeUtente, ATTENZIONE, quando si vogliono
 aggiungere utenti secondari è sempre meglio aggiungerli, in append, vedi
 esempio successivo
\end_layout

\begin_layout Itemize
usermod -a -G wheel,video nomeUtente //aggiunge i gruppi 
\begin_inset Quotes eld
\end_inset

wheel
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

video
\begin_inset Quotes erd
\end_inset

 come gruppi secondari all'utente nomeUtente
\end_layout

\begin_layout Itemize
usermod -g nomeGruppo nomeUtente //imposta all'utente nomeUtente il gruppo
 primario nomeGruppo, il gruppo primario è il gruppo attivato appena l'utente
 effettua il login
\end_layout

\begin_layout Itemize
usermod -l nomeUtenteNuovo nomeUtente //cambia il nome di login di un utente,
 è molto utile, in quanto non dobbiamo eliminare e ricreare l'utente in
 caso di rinomina del nome utente, tutti i file di appartenenza a nomeUtente
 apparterranno a nomeUtenteNuovo e anche le informazioni nel passwd vengono
 aggiornate, la home directory rimane la stessa ma può essere cambiata col
 flag 
\begin_inset Quotes eld
\end_inset

-d
\begin_inset Quotes erd
\end_inset

, come nell'esempio successivo
\end_layout

\begin_layout Itemize
usermod -d /home/homeAlternativaUtente nomeUtente //cambia la directory
 home dell'utente nomeUtente, è da ricordare che la directory home costituisce
 anche la directory d'accesso quando viene effettuato il login, questo andrà
 automaticamente a modificare il file 
\begin_inset Quotes eld
\end_inset

passwd
\begin_inset Quotes erd
\end_inset

 con la nuova home
\end_layout

\begin_layout Itemize
usermod -L nomeUtente //blocca l'account nomeUtente, è un'alternativa a
 passwd -l nomeUtente, sono analoghi
\end_layout

\begin_layout Itemize
usermod -U nomeUtente //sblocca l'account nomeUtente, è un'alternativa a
 passwd -u nomeUtente, sono analoghi
\end_layout

\begin_layout Subsection
Gpasswd
\end_layout

\begin_layout Itemize
gpasswd -d username nomeGruppo //rimuove l'utente chiamato 
\begin_inset Quotes eld
\end_inset

username
\begin_inset Quotes erd
\end_inset

 dal gruppo chiamato 
\begin_inset Quotes eld
\end_inset

nomeGruppo
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Paragraph
Chage
\end_layout

\begin_layout Standard
E' un programma molto utile su sistemi con molti utenti, per gestire le
 politiche di mantenimento delle password e di validità degli account, ma
 ha le stesse potenzialità di programmi già visti come useradd e usermod,
 vediamo alcuni esempi applicativi:
\end_layout

\begin_layout Itemize
chage -E date nomeUtente //imposta la data in cui scadrà la password dell'utente
 nomeUtente
\end_layout

\begin_layout Itemize
chage -I nroGiorni nomeUtente //imposta il numero di giorni di inattività
 che deve passare prima di bloccare un account
\end_layout

\begin_layout Itemize
chage -m nroGiorni nomeUtente //imposta il numero minimo di giorni per cui
 una password non può essere cambiata
\end_layout

\begin_layout Itemize
chage -M nroGiorni nomeUtente //imposta il numero massimo di giorni per
 cui una password è valida
\end_layout

\begin_layout Paragraph*
Groups
\end_layout

\begin_layout Itemize
groups nomeutente //mi fa vedere i gruppi di afferenza di un account
\end_layout

\begin_layout Standard
Quando si parla di gruppi è molto utile è il file 
\begin_inset Quotes eld
\end_inset

/etc/groups
\begin_inset Quotes erd
\end_inset

 che contiene la lista dei gruppi con le varie proprietà del gruppo e la
 lista utenti per ogni gruppo, è analogo al file 
\begin_inset Quotes eld
\end_inset

/etc/passwd
\begin_inset Quotes erd
\end_inset

 usato per gli utenti.
 Per convenzione si parla di gruppi o utenti 
\begin_inset Quotes eld
\end_inset

di sistema
\begin_inset Quotes erd
\end_inset

 se l'id è minore o uguale a 500, anche se in alcune distro recenti il numero
 è diventato 1000, probabilmente per ragioni dovute al significativo quantitativ
o di gruppi o utenti di sistema.
 Recapitolando utenti o gruppi con id numerico oltre la costante (500 o
 1000 a differenza della distro) sono considerati utenti o gruppi 
\begin_inset Quotes eld
\end_inset

normali
\begin_inset Quotes erd
\end_inset

 viceversa si parla di 
\begin_inset Quotes eld
\end_inset

utenza di sistema
\begin_inset Quotes erd
\end_inset

.
 E' importante ricordare che quando avvengono modifiche sui gruppi, ad esempio
 quando vengono aggiunti gruppi ad utenti, le modifiche vengono apportate
 al prossimo login.
\end_layout

\begin_layout Paragraph*
Groupadd
\end_layout

\begin_layout Itemize
groupadd nomeGruppo //aggiunge un gruppo chiamato nomegruppo
\end_layout

\begin_layout Itemize
groupadd -g id nomeGruppo //aggiunge un nuovo gruppo con un numero group
 id specificato al posto di 
\begin_inset Quotes eld
\end_inset

id
\begin_inset Quotes erd
\end_inset

, se non viene inserito il flag 
\begin_inset Quotes eld
\end_inset

-g
\begin_inset Quotes erd
\end_inset

, il sistema stabilisce automaticamente il group id del gruppo
\end_layout

\begin_layout Itemize
groupadd -f nomeGruppo //forza la creazione del gruppo nomeGruppo anche
 se questo già esiste
\end_layout

\begin_layout Standard
To add a group called myGroup we just do
\end_layout

\begin_layout Itemize
addgroup myGroup
\end_layout

\begin_layout Paragraph
Groupmod
\end_layout

\begin_layout Itemize
groupmod -g id nomeGruppo //modifica l'id numerico del gruppo nomeGruppo
\end_layout

\begin_layout Itemize
groupmod -o -g id nomeGruppo //modifica l'id numerico del gruppo nomeGruppo,
 il flag 
\begin_inset Quotes eld
\end_inset

-o
\begin_inset Quotes erd
\end_inset

 permette di impostare l'id di nomeGruppo indipendentemente dal fatto che
 ci siano altri gruppi con lo stesso id, quindi è possibile avere più gruppi
 con lo stesso id
\end_layout

\begin_layout Itemize
groupmod -n nomeGruppoNuovo nomeGruppo //modifica il nome del gruppo nomeGruppo
 in nomeGruppoNuovo
\end_layout

\begin_layout Paragraph
Groupdel
\end_layout

\begin_layout Itemize
groupdel nomeGruppo //elimina il gruppo nomeGruppo
\end_layout

\begin_layout Paragraph*
Chgrp
\end_layout

\begin_layout Standard
Per cambiare gruppo ad una directory o ad un file possiamo effettuare:
\end_layout

\begin_layout Itemize
chgrp nomeGruppo nomeFile //associa al file nomeFile il gruppo nomeGruppo
\end_layout

\begin_layout Standard
Per effettuarlo ricorsivamente (nel caso di directory) aggiungiamo un -R,
 quindi avremo:
\end_layout

\begin_layout Itemize
chgrp -R nomeGruppo nomeDirectory //associa alla directory nomeDirectory
 il gruppo nomeGruppo
\end_layout

\begin_layout Paragraph*
Newgrp 
\end_layout

\begin_layout Standard
Imposta tutti i file creati dal momento in cui viene lanciato in poi appartenent
i ad uno specifico gruppo, o in altri termini permette ad un utente di switchare
 su un altro gruppo, è da ricordare infatti che un utente ha un gruppo principal
e e poi una serie di gruppi secondari, per switchare ad un gruppo secondario
 si utilizza quindi questo comando, ad esempio:
\end_layout

\begin_layout Itemize
newgrp myGroup //tutti i file che verranno creati dopo l'avvio di questo
 comando apparterranno al gruppo myGroup 
\end_layout

\begin_layout Itemize
newgrp - gruppoAppenaAggiunto //questo comando è utile quando vengono effettuate
 modifiche ai gruppi (ad esempio viene aggiunto un gruppo secondario ad
 un utente) e non si vuole rifare il login per vedere applicate le nuove
 modifiche
\end_layout

\begin_layout Section
Gestione dei Permessi
\end_layout

\begin_layout Subsection
Permessi e Impostazioni
\end_layout

\begin_layout Standard
Per ogni file su GNU/Linux è possibile gestire i permessi di lettura, scrittura
 ed esecuzione da parte degli utenti.
 In questa sezione verranno presentati una serie di comandi per poter gestire
 e modificare questi permessi.
 Innanzitutto per poter visualizzare i permessi presenti su un file, è possibile
 farlo attraverso: 
\end_layout

\begin_layout Itemize
ls -l nomeFile //visualizza i permessi presenti sul file nomeFile
\end_layout

\begin_layout Itemize
ls -l //visualizza tutti i file coi relativi permessi all'interno della
 directory corrente
\end_layout

\begin_layout Itemize
ls -l nomeDir //visualizza i permessi di tutti i file all'interno della
 directory nomeDir
\end_layout

\begin_layout Standard
I permessi vengono presentati nella forma 
\begin_inset Quotes eld
\end_inset

xxx-xxx-xxx
\begin_inset Quotes erd
\end_inset

, dove con tre gruppi di caratteri da tre lettere l'uno rappresento i permessi
 di lettura, scrittura ed esecuzione per tre gruppi di utenti.
 Le lettere possono essere 'r' (lettura), 'w' (scrittura) e 'x' (esecuzione).
 Per quanto riguarda i tre gruppi di caratteri:
\end_layout

\begin_layout Itemize
il primo gruppo rappresenta i diritti del proprietario del file
\end_layout

\begin_layout Itemize
il secondo gruppo rappresenta i permessi dei membri del gruppo del proprietario
\end_layout

\begin_layout Itemize
il terzo gruppo rappresenta i permessi del resto degli utenti
\end_layout

\begin_layout Standard
Inoltre davanti ai tre gruppi di caratteri è presente un'altro carattere
 che rappresenta la natura del file e può essere:
\end_layout

\begin_layout Itemize
'-' significa, questo è un file
\end_layout

\begin_layout Itemize
'd' significa, questa è una directory
\end_layout

\begin_layout Itemize
'l' significa, questo è un link
\end_layout

\begin_layout Standard
Il significato dei permessi: lettura, scrittura ed esecuzione, varia se
 stiamo operando con una directory o con un file semplice, infatti:
\end_layout

\begin_layout Itemize
Per i file semplici:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
lettura 'r': significa poter leggere il file
\end_layout

\begin_layout Itemize
scrittura 'w': significa poter modificare il file o poterlo generalmente
 sovrascrivere
\end_layout

\begin_layout Itemize
esecuzione 'x': significa poterlo eseguire
\end_layout

\end_deeper
\begin_layout Itemize
Per le directory:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
lettura 'r': significa poter leggere il contenuto di una directory, quindi
 eseguire comandi come 
\begin_inset Quotes eld
\end_inset

ls
\begin_inset Quotes erd
\end_inset

 ad esempio
\end_layout

\begin_layout Itemize
scrittura 'w': significa poter creare, cancellare o modificare i file (anche
 sotto-directory) all'interno della directory
\end_layout

\begin_layout Itemize
esecuzione 'x': significa poter attraversare una directory, ad esempio col
 comando 
\begin_inset Quotes eld
\end_inset

cd
\begin_inset Quotes erd
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
N.B.: Se un utente possiede i permessi di sola esecuzione per una directory,
 allora può accedere ai file all'interno della directory se e solo se ne
 conosce il nome, in quanto non può avere una lista dei file, ovviamente
 deve avere anche i diritti di lettura per i file all'interno della directory.
\end_layout

\begin_layout Standard
Vediamo ora alcuni comandi preliminari sulla gestione del proprietario di
 un file e dei permessi:
\end_layout

\begin_layout Itemize
usermod -g myGroup jeff //inserisce l'utente jeff nel gruppo myGroup
\end_layout

\begin_layout Itemize
chown -R jeff.wheel nomeDirectory //il proprietario della directory diventa
 jeff, e il gruppo proprietario (a cui è associato il secondo gruppo di
 caratteri rwx) diventa wheel, col flag -R questa operazione viene associata
 alla directory e a tutti i file all'interno (quindi anche eventuali sotto-direc
tory)
\end_layout

\begin_layout Standard
Per poter modificare i permessi relativi ad un file, esistono generalmente
 due modalità:
\end_layout

\begin_layout Itemize
Modalità Simbolica
\end_layout

\begin_layout Itemize
Modalità Numerica
\end_layout

\begin_layout Paragraph
Modalità simbolica
\end_layout

\begin_layout Standard
Una comoda modalità per settare i permessi, è quella di utilizzare la modalità
 simbolica.
 In questa modalità, si usano le lettere per riferirsi ai gruppi di utenti,
 infatti:
\end_layout

\begin_layout Itemize
'u': indica l'utente proprietario del file
\end_layout

\begin_layout Itemize
'g': indica il gruppo proprietario
\end_layout

\begin_layout Itemize
'o': indica il resto degli utenti
\end_layout

\begin_layout Itemize
'a': indica 'all', cioè tutti gli utenti, se non viene specificata una lettera,
 all è l'opzione di default
\end_layout

\begin_layout Standard
e dei caratteri chiave :
\end_layout

\begin_layout Itemize
'+' //aggiunge permessi a quelli pre-esistenti
\end_layout

\begin_layout Itemize
'-' //rimuove permessi a quelli pre-esistenti
\end_layout

\begin_layout Itemize
'=' //imposta permessi cancellando la configurazione precedente
\end_layout

\begin_layout Standard
Vediamo ora alcuni comandi per gestire i permessi in modalità simbolica:
\end_layout

\begin_layout Itemize
chmod o+r nomeFile //aggiunge (o elimina nel caso del '-') i diritti di
 lettura o toglierli al resto degli utenti al di fuori del proprietario
 e del gruppo del proprietario
\end_layout

\begin_layout Itemize
chmod g-r -R nomeDirectory //rimuove i permessi di lettura al gruppo proprietari
o a tutta la directory nomeDirectory, il flag -R viene usato ogni qualvolta
 dobbiamo gestire i permessi di una directory e tutto il suo contenuto,
 nel caso non mettessimo il flag -R, il comando è ancora valido, ma vengono
 settati solo i permessi della directory e non dei file all'interno
\end_layout

\begin_layout Itemize
chmod +x nomeFile //imposta i diritti di esecuzione per tuti gli utenti
\end_layout

\begin_layout Itemize
chmod go+w nomeFile //fornisce i diritti di scrittura sul file sia al gruppo
 proprietario che al resto del mondo 
\end_layout

\begin_layout Itemize
chmod a=rw nomeFile //cancella tutta la configurazione precedente di diritti
 e assegna esattamente i diritti di scrittura e lettura per tutti gli utenti
\end_layout

\begin_layout Itemize
chmod u+r,g-w filename //aggiunge all'utente proprietario del file i diritti
 di lettura, e toglie al gruppo proprietario i diritti di scrittura
\end_layout

\begin_layout Itemize
chmod –reference file1 file2 //in realtà questo esempio non appartiene a
 nessuna modalità, serve a copiare i permessi che ha il file 1 e applicarli
 al file2
\end_layout

\begin_layout Paragraph
Modalità Numerica
\end_layout

\begin_layout Standard
Un'altra modalità per settare i permessi all'interno di un sistema GNU/Linux,
 è costituito dalla modalità numerica.
 Vengono utilizzati dei numeri per rappresentare i permessi, nello specifico,
 abbiamo:
\end_layout

\begin_layout Itemize
1 -> esecuzione
\end_layout

\begin_layout Itemize
2 -> scrittura
\end_layout

\begin_layout Itemize
4 -> lettura
\end_layout

\begin_layout Standard
Infatti attraverso un sistema di numerazione ottale si riescono a rappresentare
 tutti i permessi:
\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
#
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Permessi
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
rwx
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
lettura+scrittura+esecuzione
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4+2+1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
lettura+scrittura
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4+2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
lettura+esecuzione
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4+1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
lettura
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
scrittura+esecuzione
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2+1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
scrittura
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
esecuzione
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
nessun permesso
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Permessi Numerici
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Quindi con gruppi da 3 cifre riusciamo anche in questa modalità a impostare
 i diritti, dove il primo numero rappresenta i diritti del proprietario
 del file, il secondo numero rappresenta i diritti del gruppo proprietario
 del file e il terzo numero rappresenta i diritti del resto degli utenti.
 Vediamo ora alcuni esempi di applicazione della modalità numerica per le
 impostazioni dei permessi:
\end_layout

\begin_layout Itemize
chmod 644 nomeFile //cambia i diritti del file nomeFile, impostando lettura+scri
ttura per il proprietario, e sola lettura per il gruppo proprietario e per
 il resto degli utenti
\end_layout

\begin_layout Itemize
chmod 771 -R nomeDir //cambia i diritti della directory nomeDir, e di tutto
 il suo contenuto, impostando i permessi di lettura+scrittura+esecuzione
 per il proprietario e per il gruppo del proprietario e i permessi di sola
 esecuzione per il resto degli utenti
\end_layout

\begin_layout Itemize
chmod 707 -R nomeDir //cambia i diritti della directory nomeDir e di tutto
 il suo contenuto, impostando i permessi di lettura+scrittura+esecuzione
 per il proprietario e per il resto degli utenti al di fuori del gruppo
 proprietario, mentre il gruppo proprietario non ha nessun diritto sulla
 directory e il suo contenuto
\end_layout

\begin_layout Paragraph
Special Permission Bits
\end_layout

\begin_layout Standard
Le modalità finora discusse sono quelle più utilizzate nella maggior parte
 dei casi, ad ogni modo esistono dei cosiddetti 
\begin_inset Quotes eld
\end_inset

special permission bits
\begin_inset Quotes erd
\end_inset

 che rappresentano modalità operative aggiuntive più avanzate delle semplici
 r, w ed x.
 Queste modalità speciali sono:
\end_layout

\begin_layout Itemize
SUID (Set User ID): identificato in modalità simbolica con 's', e in modalità
 numerica con '4'; mi permette di eseguire un file come se fossi il proprietario
 del file, ad esempio se questo file richiama o modifica file in cui non
 ho nessun permesso (ad esempio nella directory /etc/), in questo caso non
 avrò errori nell'esecuzione in quanto mi verranno dati gli stessi permessi
 del proprietario su tutti i file su cui opera il file in questione al momento
 dell'esecuzione
\end_layout

\begin_layout Itemize
SGID (Set Group ID): anche in questo caso identificato in modalità simbolica
 con 's', e in modalità numerica con '2'; mi permette di eseguire un file
 come se appartenessi al gruppo proprietario del file, ad esempio se questo
 file richiama o modifica file in cui non ho nessun permesso (ad esempio
 nella directory /etc/), in questo caso non avrò errori nell'esecuzione
 in quanto mi verranno dati gli stessi permessi del gruppo proprietario
 su tutti i file su cui opera il file in questione al momento dell'esecuzione
\end_layout

\begin_layout Itemize
t (sticky flag): identificato in modalità simbolica con 't' e in modalità
 numerica con '1'; è un flag applicabile a directory, quindi non può essere
 utilizzato su file semplici, se settato rende impossibile la cancellazione
 dei file all'interno di una directory e della directory stessa, infatti
 un utente potrebbe anche avere tutti i permessi (lettura+scrittura+esecuzione)
 per i file all'interno della cartella, ma se questo è settato, non può
 eliminare nulla.
\end_layout

\begin_layout Standard
E' da notare che per utilizzare la modalità numerica, dobbiamo usare una
 notazione a 4 cifre anzichè 3, dove la prima cifra rappresenta gli special
 permission bits settati e gli altri 3 rappresentano le classiche cifre
 dei permessi spiegate nella sezione precedente.
 Una tabella riassuntiva dei valori che può assumere la prima cifra può
 essere visionata qui sotto.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
#
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Permessi
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
rwx
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SUID+SGID+Sticky Flag
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4+2+1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SUID+SGID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4+2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SUID+Sticky Flag
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4+1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SUID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sticky Flag+SGID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2+1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SGID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sticky Flag
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
nessun permesso speciale
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Permessi Numerici Speciali
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Vediamo ora alcuni esempi di applicazione sia in modalità simbolica che
 in modalità numerica dei special permission bits:
\end_layout

\begin_layout Itemize
chmod u+s myFile //in questo modo imposto su ON il SUID, cioè tutti gli
 utenti possono eseguire il file come se il fosse il proprietario a lanciarlo
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
un esempio presente di default sui sistemi GNU/Linux è il comando 
\begin_inset Quotes eld
\end_inset

passwd
\begin_inset Quotes erd
\end_inset

 che deve operare col file /etc/passwd
\end_layout

\end_deeper
\begin_layout Itemize
chmod 4666 myFile //in questo caso imposto ON il SUID e i diritti di lettura+scr
ittura per tutti gli utenti
\end_layout

\begin_layout Itemize
chmod 6644 myFile //in questo caso imposto ON sia SUID che SGID e i diritti
 di lettura+scrittura per il proprietario del file e i diritti di sola lettura
 per il resto degli utenti
\end_layout

\begin_layout Itemize
chmod u-s myFile //in questo modo imposto su OFF il SUID, cioè se tutti
 gli utenti prima potevano lanciare il file come il proprietario, dopo questo
 comando non possono più
\end_layout

\begin_layout Itemize
chmod g+s myFile //in questo modo imposto su ON il GUID, cioè tutti gli
 utenti possono eseguire il file come se appartenessero al gruppo proprietario
\end_layout

\begin_layout Itemize
chmod g-s myFile //in questo modo imposto su OFF il GUID, cioè se tutti
 gli utenti prima potevano lanciare il file come il appartenenti al gruppo
 proprietario, dopo questo comando non possono più
\end_layout

\begin_layout Itemize
chmod +t myDirectory //aggiunge lo sticky flag sulla directory myDirectory,
 è da ricordare che questo flag non può essere applicato a semplici file
 ma solo a directory
\end_layout

\begin_layout Itemize
chmod 1444 myDirectory //aggiungo lo sticky flag alla directory myDirectory
 e imposto i diritti di lettura per tutti gli utenti
\end_layout

\begin_layout Standard
Per visualizzare i permessi, valgono le modalità precedenti, quindi con
 
\begin_inset Quotes eld
\end_inset

ls -l
\begin_inset Quotes erd
\end_inset

, li visualizzo, ad ogni modo è da notare che:
\end_layout

\begin_layout Itemize
il flag 'T' sostituirà la 'x' nel gruppo di utenti 'o' (resto degli utenti)
\end_layout

\begin_layout Itemize
il flag 'S' per SUID sostituirà la 'x' nel gruppo di caratteri del proprietario
\end_layout

\begin_layout Itemize
il flag 'S' per SGID sostituirà la 'x' nel gruppo di caratteri del gruppo
 proprietario
\end_layout

\begin_layout Subsection
Permessi di Default, ossia Umask
\end_layout

\begin_layout Standard
Quando un utente crea un file (o una directory) vengono settati dei permessi
 di default relativi alla possibilità di lettura, scrittura o esecuzione
 del file in questione da parte degli utente.
 I permessi di default possono essere cambiati (o generalmente gestiti)
 attraverso il comando umask.
 Lanciando solamente il comando 
\begin_inset Quotes eld
\end_inset

umask
\begin_inset Quotes erd
\end_inset

 senza parametri, visualizzo un insieme di cifre che rappresenta i permessi
 di default sul sistema.
 Questo gruppo di cifre non è altro che una maschera a cui dobbiamo sottrarre
 dei valori.
 Di default i permessi sui file sono settati al valore 
\begin_inset Quotes eld
\end_inset

0666
\begin_inset Quotes erd
\end_inset

 e i permessi sulle directory sono settati al valore 
\begin_inset Quotes eld
\end_inset

0777
\begin_inset Quotes erd
\end_inset

, e il valore di umask predefinito è 
\begin_inset Quotes eld
\end_inset

0022
\begin_inset Quotes erd
\end_inset

.
 In questa configurazione predefinita, sottraendo ai permessi di default
 di file e cartelle il valore di umask, possiamo capire i permessi che verranno
 attribuiti ai file o alle directory appena create; infatti nel nostro caso
 dovremo sottrarre sia per i file che per le cartelle il valore di umask,
 e otteniamo:
\end_layout

\begin_layout Itemize
umask - valoriDiDefaultPerFile = 0666-0022=0644
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
cioè per ogni file creato verranno utilizzati i permessi 0644, cioè nessun
 special permission bits settato, permessi di lettura+scrittura per il proprieta
rio e per il gruppo proprietario e permessi di sola lettura per il resto
 degli utenti
\end_layout

\end_deeper
\begin_layout Itemize
umask - valoriDiDefaultPerDirectory = 0777-0022=0755
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
cioè per ogni directory creata verranno utilizzati i permessi 0755, cioè
 nessun special permission bits settato, permessi di lettura+scrittura+esecuzion
e per il proprietario e per il gruppo proprietario e permessi di sola lettura+es
ecuzione per il resto degli utenti
\end_layout

\end_deeper
\begin_layout Standard
Nel caso volessimo cambiare il valore di umask, possiamo lanciare il comando
 umask col codice che preferiamo per la maschera, ad esempio:
\end_layout

\begin_layout Itemize
umask 0014 //in questo caso ho cambiato la maschera a 0014, quindi avrò
 di default per i file i permessi
\begin_inset Quotes eld
\end_inset

0652
\begin_inset Quotes erd
\end_inset

 e per le directory 
\begin_inset Quotes eld
\end_inset

0763
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Due comode umask molto gettonate sono:
\end_layout

\begin_layout Enumerate
umask 022 //utilizzata per fare in modo che tutti gli utenti possano vedere
 i file e le directory che creo
\end_layout

\begin_layout Enumerate
umask 077 //utilizzata per fare in modo che tutti gli altri utenti non possano
 vedere i file e le directory che creo
\end_layout

\begin_layout Standard
dobbiamo mettere la umask in uno degli startup files per fare in modo che
 la modifica sia persistente.
\end_layout

\begin_layout Subsection
Gestione Avanzata dei Permessi (ACL)
\end_layout

\begin_layout Standard
Access Control Lists (ACLs) are a way to assign fine tuned permissions in
 Linux apart from using the chmod command.
 When the chmod command is used only one owner and one group can be assigned
 permissions on a file or directory.
 If multiple users need access to a resource we need to place them in a
 group and then give that group the necessary permissions.
 But with File ACLs in Linux we can assign fine grained permissions to each
 user and group on a file and even deny access to a particular user even
 if the file has world permissions.
 This tutorial on Linux File ACL will explain the usage of the commands
 getfacl and setfacl.
\end_layout

\begin_layout Standard
If you get a command not found error for getfacl and setfacl it means the
 acl package is not installed, so use yum or apt-get according to your operating
 system to install the package:
\end_layout

\begin_layout Itemize
sudo apt-get install acl
\end_layout

\begin_layout Itemize
sudo yum install acl
\end_layout

\begin_layout Standard
Solitamente ci accorgiamo che su un file sono impostati dei permessi ACL
 attraverso il simbolo + davanti alla stringa dei permessi quando eseguiamo
 ad esempio 
\begin_inset Quotes eld
\end_inset

ls -Al
\begin_inset Quotes erd
\end_inset

, se ad esempio notiamo una stringa del tipo 
\begin_inset Quotes eld
\end_inset

drw-r–r–+
\begin_inset Quotes erd
\end_inset

 questo significa che quel file è affetto da permessi ACL.
\end_layout

\begin_layout Standard
Per ricavare i permessi ACL di un file/directory eseguiamo:
\end_layout

\begin_layout Itemize
getfacl nomeFileODirectory //mostra i permessi sul file includendo anche
 quelli ACL
\end_layout

\begin_layout Standard
Per impostare dei permessi ACL eseguiamo:
\end_layout

\begin_layout Itemize
setfacl -m -u:nomeUtente:rwx nomeFile //imposta i diritti per l'utente chiamato
 nomeUtente abilitando lettura, scrittura ed esecuzione sul file menzionato
\end_layout

\begin_layout Itemize
setfacl -R -m u:username:rwx /path/to/directory //imposta i diritti per
 l'utente chiamato username su una directory, infatti il flag 
\begin_inset Quotes eld
\end_inset

-R
\begin_inset Quotes erd
\end_inset

 è utilizzato per applicare ricorsivamente i permessi sulle directory
\end_layout

\begin_layout Itemize
setfacl -m g:groupname:r-x /path/to/filename //imposta i diritti per il
 gruppo chiamato groupname abilitando lettura ed esecuzione sul file menzionato
\end_layout

\begin_layout Itemize
setfacl -m:user1:- /path/to/file //nega tutti i permessi (lettura, scrittura
 ed esecuzione) per l'utente chiamato user1 sul file menzionato
\end_layout

\begin_layout Itemize
setfacl -x u:username /path/to/file //elimina la entry ACL relativa all'utente
 menzionato
\end_layout

\begin_layout Itemize
setfacl -b nomeFile //elimina tutti i permessi ACL applicati al file menzionato
\end_layout

\begin_layout Standard
Su alcuni filesystem potrebbe non essere possibile effettuare il comando
 setfacl, questo è dovuto al fatto che deve essere attivata un'opzione sul
 filesystem su cui vogliamo applicare i permessi ACL.
 
\end_layout

\begin_layout Standard
Consultare le man page di getfacl e setfacl per ulteriori informazioni molto
 ben dettagliate.
\end_layout

\begin_layout Subsubsection
Sulla mia partizione è possibile usare il sistema di permessi ACL ?
\end_layout

\begin_layout Standard
Possiamo vedere se l'opzione per i permessi ACL è impostata o meno sul filesyste
m prima eseguiamo:
\end_layout

\begin_layout Itemize
mount | column -t //visualizza i filesystem correntemente montati con le
 relative opzioni, attenzione alcune opzioni potrebbero essere attive anche
 se non mostrate col comando mount, queste sono chiamate 
\begin_inset Quotes eld
\end_inset

opzioni di default
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
se l'opzione 
\begin_inset Quotes eld
\end_inset

acl
\begin_inset Quotes erd
\end_inset

 non è visualizzata allora controlliamo le opzioni implicite di default,
 per poterle visualizzare eseguiamo:
\end_layout

\begin_layout Itemize
tune2fs -l /dev/sdaX //in questo output cerchiamo una voce che dice 
\begin_inset Quotes eld
\end_inset

Default mount options
\begin_inset Quotes erd
\end_inset

 o qualcosa di simile
\end_layout

\begin_layout Standard
Nel caso in qui anche con questo comando manca la stringa 
\begin_inset Quotes eld
\end_inset

acl
\begin_inset Quotes erd
\end_inset

 tra le opzioni di mount di default, allora dobbiamo impostarli usando il
 file 
\begin_inset Quotes eld
\end_inset

/etc/fstab
\begin_inset Quotes erd
\end_inset

 e andando ad aggiungere l'opzione 
\begin_inset Quotes eld
\end_inset

acl
\begin_inset Quotes erd
\end_inset

 al filesystem interessato, ad esempio:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

/dev/sda2	/	ext4    acl,errors=remount-ro	0	1
\end_layout

\end_inset


\end_layout

\begin_layout Section
Hardware
\end_layout

\begin_layout Standard
Nella storia di Linux, ci sono stati molti cambiamenti su come il kernel
 presenta l'hardware all'utente.
 Attualmente il sistema che si occupa di abilitare i programmi nello user-space
 per la configurazione e l'utilizzo dei dispositivi hardware è chiamato
 
\begin_inset Quotes eld
\end_inset

udev
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsection
Device Files
\end_layout

\begin_layout Standard
E' facile manipolare la maggior parte dei device su Linux in quanto, il
 kernel presenta l'interfaccia di I/O dei device ai processi utente attraverso
 dei file; questi file sono chiamati 
\begin_inset Quotes eld
\end_inset

device nodes
\begin_inset Quotes erd
\end_inset

.
 Alcuni device sono completamente operabili atraverso questi file, ma non
 tutti.
 I device files sono contenuti nella directory 
\begin_inset Quotes eld
\end_inset

/dev
\begin_inset Quotes erd
\end_inset

.
 Per identificare un device con i relativi permessi possiamo utilizzare
 un classico 
\begin_inset Quotes eld
\end_inset

ls -l
\begin_inset Quotes erd
\end_inset

 nella directory 
\begin_inset Quotes eld
\end_inset

/dev
\begin_inset Quotes erd
\end_inset

.
 I device nodes si contraddistinguono, in quanto il primo carattere può
 essere:
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

b
\begin_inset Quotes erd
\end_inset

: Indica un Block Device
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Sono device in cui possiamo scrivere solo per chunk di dimensione prefissata,
 questi device hanno inoltre una dimensione definita
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

c
\begin_inset Quotes erd
\end_inset

: sta per Character Device
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Sono device in cui possiamo leggere o scrivere caratteri, non hanno un dimension
e definita come i Block Device
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

p
\begin_inset Quotes erd
\end_inset

: sta per Pipe Device
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
I Pipe Device o Named Pipe sono come Character Device, solo che al posto
 di scrivere ad un driver del kernel, il destinatario è un altro processo,
 quindi possiamo usarlo come mezzo di comunicazione tra due processi (IPC)
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

s
\begin_inset Quotes erd
\end_inset

: sta per Socket Device
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
I Socket sono interfacce special purpose frequentemente utilizzate per l'IPC
 (interprocess communication), anche se in realtà questi non sono collocati
 nella directory /dev, Unlike named pipes sockets are fully duplex-capable.
\end_layout

\end_deeper
\begin_layout Standard
I numeri che vengono mostrati nel momento in cui eseguiamo un 
\begin_inset Quotes eld
\end_inset

ls -l
\begin_inset Quotes erd
\end_inset

, rappresentano rispettivamente il 
\begin_inset Quotes eld
\end_inset

major number
\begin_inset Quotes erd
\end_inset

 ed il 
\begin_inset Quotes eld
\end_inset

minor number
\begin_inset Quotes erd
\end_inset

, questi due numeri aiutano il kernel ad identificare i dispositivi, e dispositi
vi simili avranno solitamente lo stesso major number.
\end_layout

\begin_layout Standard
E' utile notare che non tutti i dispositivi hardware sono presenti nella
 directory 
\begin_inset Quotes eld
\end_inset

/dev
\begin_inset Quotes erd
\end_inset

, in quanto non tutti i device possono essere propriamente descritti con
 una delle categorie sopra descritte, un esempio è dato dalle interfacce
 di rete, che non hanno device files.
\end_layout

\begin_layout Subsection
Linux e Casualità, /dev/random e /dev/urandom
\end_layout

\begin_layout Standard
The files /dev/random and /dev/urandom provide an interface to Kernel’s
 Random Number Generator.
 The Random Number Generator gathers environmental noise from device drivers
 and other sources into entropy pool.
 It also keeps an estimate of Number of bits of noise in entropy pool.
 It is from this entropy pool, random numbers are generated
\end_layout

\begin_layout Standard
/dev/random It will only return Random bytes from entropy pool.
 If entropy pool is empty, reads to /dev/random will be blocked until additional
 environmental noise is gathered.
 This is suited to high quality randomness, such as one-time pad or key
 generation.
\end_layout

\begin_layout Standard
TIP: Issue the command ‘cat /dev/random’ into your terminal without quotes.
 Move the mouse or type anything on the keyboard to see random characters
 being generated.
 Press CTRL+C to exit the situation.
\end_layout

\begin_layout Standard
/dev/urandom It will return as many random bytes as requested.
 But if the entropy pool is empty, it will generate data using SHA, MD5
 or any other algorithm.
 It never blocks the operation.
 Due to this, the values are vulnerable to theoretical cryptographic attack,
 though no known methods exist.
\end_layout

\begin_layout Standard
TIP: Issue the command ‘cat /dev/urandom’ into your terminal without quotes.
 Sit and watch random characters being generated, while you do nothing.
 Press CTRL+C to exit the situation.
\end_layout

\begin_layout Standard
Both the files /dev/random and /dev/urandom are used to generate randomness,
 but
\end_layout

\begin_layout Standard
/dev/urandom is best used when:
\end_layout

\begin_layout Itemize
You just want a large file with random data for some kind of testing
\end_layout

\begin_layout Itemize
You are using the dd command to wipe data off a disk by replacing it with
 random data.
 
\end_layout

\begin_layout Itemize
Almost everywhere else where you don’t have a really good reason to use
 /dev/random instead
\end_layout

\begin_layout Standard
/dev/random is likely to be the better choice when:
\end_layout

\begin_layout Itemize
Randomness is critical to the security of cryptography in your application
 – one-time pads, key generation.
 
\end_layout

\begin_layout Standard
In pratica Una controparte di /dev/random è /dev/urandom (sorgente causale
 non bloccata "unlocked") che riusa il pool interno per produrre bit pseudocasua
li aggiuntivi.
 Questo significa che la richiesta non si blocca, ma il risultato potrebbe
 contenere meno entropia rispetto a /dev/random.
 Nonostante sia un generatore di numeri pseudocasuali adatto per la maggior
 parte delle applicazioni crittografiche, non è raccomandato per la generazione
 di chiavi crittografiche a lunga scadenza.
\end_layout

\begin_layout Standard
Vediamo alcuni esempi per generare password su linux con alcune che fanno
 uso di random:
\end_layout

\begin_layout Itemize
date +%s | sha256sum | base64 | head -c 32 ; echo
\end_layout

\begin_layout Itemize
< /dev/urandom tr -dc _A-Z-a-z-0-9 | head -c${1:-32};echo;
\end_layout

\begin_layout Itemize
openssl rand -base64 32
\end_layout

\begin_layout Itemize
< /dev/urandom tr -dc _A-Z-a-z-0-9 | head -c6
\end_layout

\begin_layout Itemize
randpw(){ < /dev/urandom tr -dc _A-Z-a-z-0-9 | head -c${1:-16};echo;} //here
 we define a function
\end_layout

\begin_layout Subsubsection
Create /dev/random and /dev/urandom if absent
\end_layout

\begin_layout Standard
Creating /dev/random & /dev/urandom, if your System doesn’t have them 
\end_layout

\begin_layout Standard
Minor Device number of /dev/random – 1 
\end_layout

\begin_layout Standard
Major Device number of /dev/random – 8 
\end_layout

\begin_layout Standard
Minor Device number of /dev/urandom – 1 
\end_layout

\begin_layout Standard
Major Device number of /dev/urandom – 9
\end_layout

\begin_layout Standard
STEP1: Creating character file with mode/permission as 644 # mknod -m 644
 /dev/random 1 8
\end_layout

\begin_layout Standard
STEP2: Creating character file with mode/permission as 644 # mknod -m 644
 /dev/urandom 1 9
\end_layout

\begin_layout Standard
STEP3: Changing ownership & group of created devices to ‘root’ # chown root:root
 /dev/random /dev/urandom
\end_layout

\begin_layout Standard
STEP4: Done
\end_layout

\begin_layout Subsection
Il filesystem sysfs
\end_layout

\begin_layout Standard
La directory /dev è molto comoda per i processi utente per fare riferimento
 all'hardware supportato dal kernel, ma fornisce uno schema molto semplicistico
 rispetto alla realtà.
 Infatti questi nomi all'interno di /dev ci dicono davvero molto poco del
 device a cui fanno riferimento.
 Un'altro problema è che il kernel assegna i nomi ai device in base all'ordine
 in cui li trova al boot, quindi potrei avere nomi diversi per lo stesso
 device a diversi reboot.
\end_layout

\begin_layout Standard
Per fornire una visione uniforma dei dispositivi collegati in funzione dei
 loro effettivi attributi, il kernel linux offre l'interfaccia denominata
 
\begin_inset Quotes eld
\end_inset

sysfs
\begin_inset Quotes erd
\end_inset

 attraverso un filesystem di file e directory.
 La directory base che contiene i device è 
\begin_inset Quotes eld
\end_inset

/sys/devices
\begin_inset Quotes erd
\end_inset

.
 Facciamo un esempio, il device /dev/sda potrebbe risiedere all'indirizzo
 
\begin_inset Quotes eld
\end_inset

/sys/devices/pci0000:00/0000:00:1f.2/host0/target0:0:0/0:0:0:0/block/sda
\begin_inset Quotes erd
\end_inset

, anche se l'indirizzo non è molto user-friendly, questi due file hanno
 scopi diversi, in quanto il primo è utilizzato per fornire un'interfaccia
 al device per i processi utente, mentre il secondo è utilizzato per visualizzar
e informazioni e gestire il device.
 All'interno della directory del device possiamo trovare all'interno del
 file 
\begin_inset Quotes eld
\end_inset

dev
\begin_inset Quotes erd
\end_inset

 il major e il minor number ad esempio 
\begin_inset Quotes eld
\end_inset

8:0
\begin_inset Quotes erd
\end_inset

 starà ad indicare un major number = a 8 ed un minor number = a 0.
\end_layout

\begin_layout Standard
E' molto utile sapere che nella directory sys, ci sono molti shortcut, ad
 esempio 
\begin_inset Quotes eld
\end_inset

/sys/block
\begin_inset Quotes erd
\end_inset

 sarà la directory contenente tutti gli shortcut ai block devices del sistema,
 questi sono contenuti anche all'interno di qualche directory in 
\begin_inset Quotes eld
\end_inset

/sys/devices
\begin_inset Quotes erd
\end_inset

, ma questo sistema di shortcut, permette a sysfs di essere più facilmente
 percorribile.
 Per rivelare il vero percorso di un block device contenuto ad esempio in
 /sys/block (ad esempio sda) possiamo effettuare un:
\end_layout

\begin_layout Itemize
ls -l /sys/block //mostra i percorsi reali dei vari block device presenti
 sul sistema
\end_layout

\begin_layout Standard
Può essere difficile trovare la posizione di un determinato device che vediamo
 in /dev all'interno del filesystem sysfs.
 Possiamo usare il comando 
\begin_inset Quotes eld
\end_inset

udevadm
\begin_inset Quotes erd
\end_inset

 (contenuto in /sbin) per mostrare il path e vari attributi, ad esempio:
\end_layout

\begin_layout Itemize
udevadm info –query=all –name=/dev/sda //mostra il percorso completo del
 device /dev/sda all'interno di sysfs con relative informazioni
\end_layout

\begin_layout Subsection
Hard Disks
\end_layout

\begin_layout Standard
La maggior parte degli Hard Disk collegati ad un sistema Linux viene chiamato
 col prefisso 
\begin_inset Quotes eld
\end_inset

sd
\begin_inset Quotes erd
\end_inset

, quindi potremo avere nel caso di due hard disk 
\begin_inset Quotes eld
\end_inset

/dev/sda
\begin_inset Quotes erd
\end_inset

 ed 
\begin_inset Quotes eld
\end_inset

/dev/sdb
\begin_inset Quotes erd
\end_inset

.
 Questi device file rappresentano l'intero disco, mentre per le partizioni
 separate all'interno della stessa partitione vengono chiamate 
\begin_inset Quotes eld
\end_inset

/dev/sda1
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

/dev/sda2
\begin_inset Quotes erd
\end_inset

, ecc...
\end_layout

\begin_layout Standard
La nomenclatura non è casuale, infatti richiede una spiegazione; la porzione
 
\begin_inset Quotes eld
\end_inset

sd
\begin_inset Quotes erd
\end_inset

 sta per SCSI disk.
 SCSI sta per 
\begin_inset Quotes eld
\end_inset

Small Computer System Interface
\begin_inset Quotes erd
\end_inset

 e fu originariamente un sistema hardware con relativo protocollo per le
 comunicazioni tra i dispositivi come dischi e altre periferiche.
 Nonostante lo SCSI hardware non è utilizzate nelle macchine moderne, il
 protocollo SCSI è invece utilizzato frequentemente, grazie alla sua adattabilit
à.
 Quindi è utile ricordare che SCSI può intendere:
\end_layout

\begin_layout Itemize
Hardware (ormai obsoleto)
\end_layout

\begin_layout Itemize
Protocollo (utilizzato frequentemente)
\end_layout

\begin_layout Standard
Ad esempio le periferiche USB utilizzano il protocollo SCSI per comunicare,
 per quanto riguarda gli Hard Disk SATA, la questione è più complessa ma
 il kernel Linux alla fine utilizza comandi del protocollo SCSI per comunicare
 con loro.
 Per elencare i dispositivi SCSI e visualizzare informazioni su di essi,
 bisognerebbe navigare nel sysfs, ma per fortuna esistono programmi che
 fanno questo per noi, uno dei più famosi è 
\begin_inset Quotes eld
\end_inset

lsscsi
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Itemize
lsscsi //mostra le periferiche SCSI, la prima colonna identifica l'indirizzo
 della periferica all'interno del sistema, la seconda identifica il tipo
 di dispositivo, le successive informazioni del produttore e l'ultima indica
 il percorso al device file
\end_layout

\begin_layout Standard
Tradizionalmente la nomenclatura dell'hardware ha spesso causato problemi,
 per via del fatto che se ho tre HDD, 
\begin_inset Quotes eld
\end_inset

/dev/sda
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

/dev/sdb
\begin_inset Quotes erd
\end_inset

 ed 
\begin_inset Quotes eld
\end_inset

/dev/sdc
\begin_inset Quotes erd
\end_inset

, e mi si spacca un HDD, ad esempio /dev/sdb, allora in questo caso /dev/sdc
 diventerà /dev/sdb, e tutte le regole che avevo impostato per /dev/sdb
 saranno applicate automaticamente a quest'ultimo HDD, per evitare questi
 problemi i sistemi Linux utilizzano l'UUID (Universally Unique Identifier)
 per una nomenclatura persistente degli HDD.
\end_layout

\begin_layout Subsection
CD e DVD
\end_layout

\begin_layout Standard
Linux riconosce la maggior parte dei drive ottici come dispositivi SCSI;
 ad ogni modo se il dispositivo è molto vecchio potrebbe essere riconosciuto
 come dispositivo PATA.
 I dispositivi ottici indicati con la nomenclatura 
\begin_inset Quotes eld
\end_inset

/dev/sr*
\begin_inset Quotes erd
\end_inset

 che sta per SCSI read sono di sola lettura, e sono dispositivi ottici da
 cui possiamo solo leggere; invece i dispositivi su cui possiamo scrivere
 sono indicati con 
\begin_inset Quotes eld
\end_inset

/dev/sg*
\begin_inset Quotes erd
\end_inset

, dove sg sta per SCSI generic.
\end_layout

\begin_layout Subsection
PATA Hard Disk
\end_layout

\begin_layout Standard
I device indicati con 
\begin_inset Quotes eld
\end_inset

/dev/hd*
\begin_inset Quotes erd
\end_inset

, sono comuni su kernel e dispositivi hardware molto vecchi.
 A volte potrebbe capitare di trovare un HDD SATA riconosciuto come PATA,
 questo significa che l'HDD SATA sta funzionando in 
\begin_inset Quotes eld
\end_inset

compatibility mode
\begin_inset Quotes erd
\end_inset

, questo abbassa le performance del dispositivo ed era una modalità utilizzata
 tempo fa per questioni di retro-compatibilità.
 Possiamo cambiare questa impostazione della 
\begin_inset Quotes eld
\end_inset

compatibility mode
\begin_inset Quotes erd
\end_inset

 dalle impostazioni di BIOS, riportando il device in 
\begin_inset Quotes eld
\end_inset

native mode
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsection
Approfondimento su SCSI
\end_layout

\begin_layout Standard
DA FARE
\end_layout

\begin_layout Subsection
Terminali
\end_layout

\begin_layout Standard
I terminali sono dispositivi utilizzati per spostare caratteri tra un processo
 utente e un dispositvo di I/O, solitamente per l'output del testo in uno
 schermo.
 Possiamo invece definire come 
\begin_inset Quotes eld
\end_inset

pseudoterminali
\begin_inset Quotes erd
\end_inset

 quei device che emulano i terminali che capiscono l'I/O dei veri terminali.
 Invece di parlare di un vero e proprio hardware in realtà il kernel fa
 riferimento ad un software, che è costituito dalla shell del isstema operativo.
 Due comuni terminal devices sono 
\begin_inset Quotes eld
\end_inset

/dev/tty1
\begin_inset Quotes erd
\end_inset

 che costituisce la prima console virtuale, e 
\begin_inset Quotes eld
\end_inset

/dev/pts0
\begin_inset Quotes erd
\end_inset

 che è il primo pseudoterminale.
 In pratica, i 
\begin_inset Quotes eld
\end_inset

/dev/tty*
\begin_inset Quotes erd
\end_inset

 sono i terminali a cui accedo solitamente con la combinazione di tasti
 
\begin_inset Quotes eld
\end_inset

Ctrl+Alt+Fx
\begin_inset Quotes erd
\end_inset

, dove 
\begin_inset Quotes eld
\end_inset

Fx
\begin_inset Quotes erd
\end_inset

 rappresenta uno qualsiasi dei tasti funzione, mentre i terminali 
\begin_inset Quotes eld
\end_inset

pts
\begin_inset Quotes erd
\end_inset

 rappresentano gli emulatori di terminale.
 Tutti gli emulatori di terminale possono essere visualizzati nella directory
 
\begin_inset Quotes eld
\end_inset

/dev/pts
\begin_inset Quotes erd
\end_inset

, in questa directory troverò un file per ogni emulatore di terminale aperto;
 in realtà questa directory è un filesystem dedicato.
 Potrei ad esempio aperto un emulatore di terminale e scoperto quale id
 gli è stato assegnato (ad esempio con ps, o andando nella directory /dev/pts
 per vedere il nuovo file creato), eseguire:
\end_layout

\begin_layout Itemize
cd /dev/pts ; echo "ciao" > 20 //stampa 
\begin_inset Quotes eld
\end_inset

ciao
\begin_inset Quotes erd
\end_inset

 sul terminal emulator con ID 20
\end_layout

\begin_layout Standard
possiamo visualizzare a video l'identificativo dell'attuale terminale attraverso
 un semplice:
\end_layout

\begin_layout Itemize
ps //visualizza informazioni sul processo corrente e quindi sul terminale
 attivo
\end_layout

\begin_layout Itemize
tty //mostra l'identificativo del terminale corrente
\end_layout

\begin_layout Subsection
Display Modes
\end_layout

\begin_layout Standard
Linux ha due cosiddette 
\begin_inset Quotes eld
\end_inset

display modes
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Itemize
Text Mode
\end_layout

\begin_layout Itemize
X Window System server (modalità grafica)
\end_layout

\begin_layout Standard
Oggigiorno normalmente il boot in molte distribuzioni, suprattutto 
\begin_inset Quotes eld
\end_inset

user-friendly
\begin_inset Quotes erd
\end_inset

 si avvia in automatico in modalità grafica attraverso un display manager.
 Tuttavia Linux supporta le cosiddette 
\begin_inset Quotes eld
\end_inset

console virtuali
\begin_inset Quotes erd
\end_inset

, cioè con una determinata combinazione di tasti tipo 
\begin_inset Quotes eld
\end_inset

Ctrl+Alt+F1
\begin_inset Quotes erd
\end_inset

 possiamo passare ad un altro terminale (solitamente col processo 
\begin_inset Quotes eld
\end_inset

getty
\begin_inset Quotes erd
\end_inset

 attivo, quello che ci chiede il login, per intenderci), questo avviene
 per multiplexare il display.
 Ognuna di queste schermate è chiamata 
\begin_inset Quotes eld
\end_inset

consolve virtuale
\begin_inset Quotes erd
\end_inset

.
 Nel caso dovessimo avere problemi ad accedere ad una determinata console,
 possiamo farlo anche col comando:
\end_layout

\begin_layout Itemize
chvt 1 //in questo caso switchiamo alla console 1
\end_layout

\begin_layout Subsection
Porte Seriali
\end_layout

\begin_layout Standard
Dispositivi che si collegano a porte seriali di tipo RS-232 e simili sono
 speciali tipi di device terminale.
 Non possiamo fare molto da command-line, in quanto ci sarebbero troppe
 impostazioni da settare manualmente come il Baud rate o il flow control.
 Questi device vengono indicati con la nomenclatura 
\begin_inset Quotes eld
\end_inset

/dev/ttyS*
\begin_inset Quotes erd
\end_inset

, mentre i dispositivi adattatori seriali USB si presentano con i nomi 
\begin_inset Quotes eld
\end_inset

/dev/ttyUSB*
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

/dev/ttyACM*
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsection
Porte Parallele
\end_layout

\begin_layout Standard
Questi device sono oggigiorno largamente sostituiti dai dispositivi USB,
 le porte parallele unidirezionali hanno nomenclatura 
\begin_inset Quotes eld
\end_inset

/dev/lp*
\begin_inset Quotes erd
\end_inset

, mentre le porte parallele bidirezionali hanno nomenclatura 
\begin_inset Quotes eld
\end_inset

/dev/parport
\begin_inset Quotes erd
\end_inset

.
 Solitamente a questo tipo di device sono associate stampanti, è utile sapere
 che possiamo idealmente anche mandare direttamente i file da stampare ad
 una stampante attraverso un semplice cat, come ad esempio:
\end_layout

\begin_layout Itemize
cat fileDiTesto > /dev/lp0 //in questo caso stampo il file menzionato attraverso
 la stampante lp0
\end_layout

\begin_layout Standard
anche se solitamente è necessario fornire alla stampante qualche parametro
 in più; infatti server di stampa come CUPS sono fatti appositamente per
 gestire il processo di stampa e le stampanti.
\end_layout

\begin_layout Subsection
Dispositivi Audio
\end_layout

\begin_layout Standard
Linux has two sets of audio devices.
 There are separate devices for the Advanced Linux Sound Architecture (ALSA)
 system interface and the older Open Sound System (OSS).
 The ALSA devices are in the /dev/snd directory, but it’s difficult to work
 with them directly.
 Linux systems that use ALSA support OSS backward- compatible devices if
 the OSS kernel support is currently loaded.
 Some rudimentary operations are possible with the OSS dsp and audio devices.
 For example, the computerplays any WAV file that you send to /dev/dsp.
 However, the hardware may not do what you expect due to frequency mismatches.
 Furthermore, on most systems, the device is often busy as soon as you log
 in.
\end_layout

\begin_layout Subsection
Creare Device File
\end_layout

\begin_layout Standard
In modern Linux systems, you do not create your own device files; this is
 done with devtmpfs and udev (see 3.5 udev).
 However, it is instructive to see how it was once done, and on a rare occasion,
 you might need to create a named pipe.
 Il comando 
\begin_inset Quotes eld
\end_inset

mknod
\begin_inset Quotes erd
\end_inset

 è utilizzato per creare device file, ad esempio:
\end_layout

\begin_layout Itemize
mknod /dev/sda1 b 8 2 //crea un device file chiamato 
\begin_inset Quotes eld
\end_inset

/dev/sda1
\begin_inset Quotes erd
\end_inset

 di tipo block 
\begin_inset Quotes eld
\end_inset

b
\begin_inset Quotes erd
\end_inset

, con major number 8 e minor number 2
\end_layout

\begin_layout Standard
Questo comando è stato utilizzato in passato anche per creare i file dei
 device mancanti nella single-user mode nelle operazioni di system recovery.
 In passato a nuovi aggiornamenti del kernel era sempre problematico aggiornare
 la directory /dev, in quanto la quantità di device supportata aumentava
 e quindi la manutenzione dei device file non era affatto banale, oggi è
 tutto molto più semplice grazie all'utilizzo di 
\begin_inset Quotes eld
\end_inset

udev
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

devtmpfs
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsection
udev
\end_layout

\begin_layout Standard
Il kernel linux può mandare notifiche ad un processo nello user-space chiamato
 
\begin_inset Quotes eld
\end_inset

udevd
\begin_inset Quotes erd
\end_inset

 quando rileva un nuovo dispositivo sul sistema (ad esempio quando qualcuno
 collega una periferica USB al sistema).
 Questo process nello user-space esamina le caratteristiche del nuovo hardware,
 crea un device file e performa tutte le eventuali operazioni di inizializzazion
e.
 Questa è la teoria dietro 
\begin_inset Quotes eld
\end_inset

udevd
\begin_inset Quotes erd
\end_inset

, purtroppo nella realtà alcuni device file sono necessari al boot, e quindi
 
\begin_inset Quotes eld
\end_inset

udevd
\begin_inset Quotes erd
\end_inset

 deve essere caricato molto presto, non deve fare da collo di bottiglia
 ed inoltre udevd non può essere creato da un altro device file che lui
 stesso dovrebbe creare; per risolvere questo problema è stato creato 
\begin_inset Quotes eld
\end_inset

devtmpfs
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsection
devtmpfs
\end_layout

\begin_layout Standard
Questo filesystem è la risposta ai problemi citati di 
\begin_inset Quotes eld
\end_inset

udevd
\begin_inset Quotes erd
\end_inset

, in quanto il kernel crea i device file necessari per la fase di boot,
 e notifica ad udevd i nuovi dispositivi rilevati; una volta ricevute le
 notifiche, udev non deve più ricreare i device file, ma si occupa solo
 dell'inizializzazione dei vari device e delle notifiche ai processi.
 Inoltre udevd si occupa di creare un numero di link simbolici all'interno
 di /dev per una identificazione più accurata dei dispositivi; ad esempio
 /dev/disk, dove ogni disco collegato ha una o più entry.
\end_layout

\begin_layout Subsection
udevd nel dettaglio: Operazioni e Configurazioni
\end_layout

\begin_layout Standard
Il demone 
\begin_inset Quotes eld
\end_inset

udevd
\begin_inset Quotes erd
\end_inset

 opera in questo modo:
\end_layout

\begin_layout Enumerate
Il kernel manda una notifica chiamata 
\begin_inset Quotes eld
\end_inset

uevent
\begin_inset Quotes erd
\end_inset

 attraverso un link di rete interno ad udevd
\end_layout

\begin_layout Enumerate
udevd carica tutti gli attributi menzionati nell'uevent
\end_layout

\begin_layout Enumerate
udevd fa il parsing delle cosiddette 
\begin_inset Quotes eld
\end_inset

rules
\begin_inset Quotes erd
\end_inset

, e opera secondo queste regole
\end_layout

\begin_layout Standard
Le regole sono contenute nelle seguenti directory:
\end_layout

\begin_layout Itemize
/lib/udev/rules.d
\end_layout

\begin_layout Itemize
/etc/udev/rules.d
\end_layout

\begin_layout Subsubsection
Stesura di Regole per udev
\end_layout

\begin_layout Standard
Generalmente le regole sono composte da condizioni che devono essere soddisfatte
, che riconosceremo attraverso il simbolo 
\begin_inset Quotes eld
\end_inset

==
\begin_inset Quotes erd
\end_inset

 e dichiarazioni che verranno applicate se le condizioni sono soddisfatte,
 per le dichiarazioni si usa il simbolo 
\begin_inset Quotes eld
\end_inset

=
\begin_inset Quotes erd
\end_inset

, ora preso un device possiamo vedere i propri attributi andando prima a
 capire qual'è il percorso corrispettivo di un device che vediamo attraverso
 ad esempio 
\begin_inset Quotes eld
\end_inset

lsusb
\begin_inset Quotes erd
\end_inset

 o 
\begin_inset Quotes eld
\end_inset

lsscsi
\begin_inset Quotes erd
\end_inset

 o 
\begin_inset Quotes eld
\end_inset

lspci
\begin_inset Quotes erd
\end_inset

 in 
\begin_inset Quotes eld
\end_inset

/dev
\begin_inset Quotes erd
\end_inset

 , una volta trovato questo percorso in dev, possiamo eseguire:
\end_layout

\begin_layout Itemize
udevadm info –name=/dev/bus/usb/002/003 –attribute-walk | less //in questo
 modo vediamo i vari attributi settati per il device nel percorso menzionato,
 attenzione: ci interessa solo il primo blocco, in quanto i successivi ripercorr
ono tutti i parent device, che a noi la maggior parte delle volte potrebbero
 non interessare
\end_layout

\begin_layout Standard
ora ad esempio possiamo vedere tra gli attributi:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

ATTR{idProduct}=="a02f"
\end_layout

\begin_layout Plain Layout

ATTR{idVendor}=="12bd"
\end_layout

\end_inset


\end_layout

\begin_layout Standard
e poi un altro interessante è:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SUBSYSTEM=="usb"
\end_layout

\begin_layout Plain Layout

DRIVER=="usb"
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Questi attributi ci possono essere utili per identificare il device in modo
 fine, in tal modo siamo sicuri che quando applicheremo le nostre regole
 non ci sbagliamo con altri device appartenenti ad altri sottosistemi, ora
 possiamo provare a scrivere una regola, che andrà in 
\begin_inset Quotes eld
\end_inset

/etc/udev/rules.d/nomeRegola.rules
\begin_inset Quotes erd
\end_inset

, vediamo alcuni esempi di regole che possiamo applicare:
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SUBYSTEM=="usb", ATTR{idVendor}=="12bd", ATTR{idProduct}=="a02f", ACTION=="add",
 MODE="0666"
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
in questo caso quando la regola verrà applicata sul device ci saranno permessi
 di lettura e scrittura per tutti gli utenti, in questo caso abbiamo solo
 applicato una regola sui permessi, inoltre la condizione 
\begin_inset Quotes eld
\end_inset

ACTION==
\begin_inset Quotes erd
\end_inset

add
\begin_inset Quotes erd
\end_inset

 indica appunto che la regola deve essere eseguita se il device è stato
 inserito, mentre al posto di add possiamo anche mettere 
\begin_inset Quotes eld
\end_inset

remove
\begin_inset Quotes erd
\end_inset

; questo indicherà delle possibili azioni da effetuare se il device viene
 rimosso, ad ogni modo ora dobbiamo riavviare le regole di udev affinchè
 la nuova configurazione abbia effetto, questo è possibile con:
\end_layout

\begin_layout Itemize
sudo udevadm control –reload-rules //ricarica le regole
\end_layout

\begin_layout Itemize
dobbiamo scollegare e ricollegare il device o riavviare
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SUBSYSTEM=="usb", ATTR{idVendor}=="12bd", ATTR{idProduct}=="a02f", ACTION=="add"
, OWNER="root", GROUP="usbgroup", MODE="0660" 
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
in questo caso impostiamo il proprietario del device e il gruppo di appartenenza
 oltre ai diritti sul device
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SUBSYSTEM=="usb", ATTR{idVendor}=="12bd", ATTR{idProduct}=="a02f", ACTION=="add"
, OWNER="root", GROUP="usbgroup", MODE="0660", SYMLINK+="ilMioJoyPad", RUN+="/us
r/bin/myScript.sh"
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
in questo caso, oltre ad imporre il proprietario, il gruppo e i permessi,
 creiamo un link simbolico al device che potremo trovare in 
\begin_inset Quotes eld
\end_inset

/dev/ilMioJoyPad
\begin_inset Quotes erd
\end_inset

, e indichiamo uno script da eseguire situato in 
\begin_inset Quotes eld
\end_inset

/usr/bin/myScript.sh
\begin_inset Quotes erd
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SUBSYSTEM=="usb", ATTR{idVendor}=="12bd", ATTR{idProduct}=="a02f", ACTION=="add"
, OWNER="root", GROUP="usbgroup", MODE="0660", ATTR{authorized}="0"
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
in questo caso effettuiamo un 
\begin_inset Quotes eld
\end_inset

blacklist
\begin_inset Quotes erd
\end_inset

 del device, questo può essere utile per diversi motivi, ad esempio vogliamo
 scrivere driver o installare driver/moduli diversi da quelli esistenti
 e quindi prevenire che il sistema in automatico carichi i driver una volta
 collegato il device, oppure più semplicemente disabilitare completamente
 un device
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

BUS=="usb", OPTIONS+="ignore_device"
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
in questo caso vengono disabilitate tutte le porte USB
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

BUS=="usb", SUBSYSTEM=="block", OPTIONS+="ignore_device"
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
in questo caso vengono disabilitate tutti i dispositivi USB che fungono
 da block device
\end_layout

\end_deeper
\begin_layout Standard

\end_layout

\begin_layout Standard
N.B.: Le regole udev non contemplano le andate a capo, quindi ad ogni linea,
 corrisponde una ed una sola regola udev.
 Inoltre ricordare sempre di ricaricare le regole e scollegare e riattaccare
 il device per vedere se le modifiche sono effettive o meno.
\end_layout

\begin_layout Standard
Per effettuare un debugging e capire quali regole vengono applicate da chi,
 possiamo trovare il path corrispettivo del device nel filesystem sys, questo
 possiamo farlo attraverso:
\end_layout

\begin_layout Itemize
udevadm info –name=/dev/bus/usb/002/003 –attribute-walk | less //vediamo
 il percorso nel sysfs
\end_layout

\begin_layout Itemize
udevadm info -a -n /dev/myDevice //analogo al precedente ma più semplice
\end_layout

\begin_layout Standard
una volta trovato questo percorso possiamo effettuare:
\end_layout

\begin_layout Itemize
udevadm test /devices/pci0000:00/0000:00:1d.0/usb2/2-1/2-1.1 //questo ci farà
 vedere le varie regole applicate da udev quali file vengono letti, può
 anche essere usato direttamente
\end_layout

\begin_layout Subsubsection
Capire cosa è stato collegato e ricavare informazioni
\end_layout

\begin_layout Standard
Per capire cosa è stato collegato, possiamo effettuare le seguenti operazioni,
 partiamo dal device interessato sconnesso, ed eseguiamo in un terminale:
\end_layout

\begin_layout Itemize
udevadm monitor //monitora lo stato di udev
\end_layout

\begin_layout Standard
ora colleghiamo il nostro device, e vedremo delle righe a schermo, tra queste
 ci sarà un percorso che corrisponderà al percorso all'interno del filesystem
 
\begin_inset Quotes eld
\end_inset

sysfs
\begin_inset Quotes erd
\end_inset

 del nostro device, una volta visto il percorso, (attenzione nel percorso
 non vedremo la directory iniziale 
\begin_inset Quotes eld
\end_inset

/sys
\begin_inset Quotes erd
\end_inset

, quindi è relativo a partire dall'interno di 
\begin_inset Quotes eld
\end_inset

/sys
\begin_inset Quotes erd
\end_inset

) possiamo ricavare informazioni sul device eseguendo:
\end_layout

\begin_layout Itemize
udevadm info /sys/percorso/menzionato/colComando/precedente –attribute-walk
 //questo mostrerà informazioni come anche relativi node files creati all'intern
o della directory 
\begin_inset Quotes eld
\end_inset

/dev
\begin_inset Quotes erd
\end_inset

, una volta
\end_layout

\begin_layout Standard
dobbiamo ricordarci che se abbiamo il percorso in /dev a disposizione allora
 useremo nel comando 
\begin_inset Quotes eld
\end_inset

udevadm info
\begin_inset Quotes erd
\end_inset

 l'opzione 
\begin_inset Quotes eld
\end_inset

–name
\begin_inset Quotes erd
\end_inset

 e specificheremo il percorso in 
\begin_inset Quotes eld
\end_inset

/dev
\begin_inset Quotes erd
\end_inset

, mentre se abbiamo solo il percorso in 
\begin_inset Quotes eld
\end_inset

/sys
\begin_inset Quotes erd
\end_inset

 all-ora non dobbiamo mettere l'opzione 
\begin_inset Quotes eld
\end_inset

–name
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsection
udevadm
\end_layout

\begin_layout Standard
Il programma udevadm costituisce il tool di gestione per udevd.
 Possiamo ad esempio ricaricare le regole di udev oppure innescare eventi,
 ma forse la più potente delle caratteristiche di questo programma è la
 capacità di poter cercare ed esplorare i dispositivi di sistema e l'abilità
 di monitorare gli uevents, quando udevd li riceve dal kernel.
\end_layout

\begin_layout Standard
Vediamo alcuni esempi:
\end_layout

\begin_layout Itemize
udevadm info –query=all –name=/dev/sda //mostra tutte le informazioni, gli
 attributi e le regole per il device file /dev/sda
\end_layout

\begin_layout Itemize
udevadm monitor //monitora i vari eventi, qui vedremo la sezione 
\begin_inset Quotes eld
\end_inset

kernel
\begin_inset Quotes erd
\end_inset

 che rappresenta i messaggi che arrivano dal kernel e la sezione 
\begin_inset Quotes eld
\end_inset

udev
\begin_inset Quotes erd
\end_inset

 relativa a quello che udev invia ai vari processi
\end_layout

\begin_layout Itemize
udevadm monitor –kernel //mostra solo i messaggi kernel
\end_layout

\begin_layout Itemize
udevadm monitor –udev //mostra solo i messaggi udev
\end_layout

\begin_layout Itemize
udevadm monitor –property //mostra informazioni aggiuntive sui vari messaggi
 come ad esempio gli attributi, questo mi permette anche di visualizzare
 i file che vengono creati in /dev quando inserisco un nuovo device nel
 computer
\end_layout

\begin_layout Standard
C'è molto da sapere su udev, ad esempio possiamo anche filtrare i messaggi
 per device, inoltre è utile sapere che il D-Bus (Desktop Bus) system utilizzato
 per l'interprocess communication (IPC) ha un demone chiamato 
\begin_inset Quotes eld
\end_inset

udisks-daemon
\begin_inset Quotes erd
\end_inset

 che rimane in ascolto dei vari messaggi mandati da udevd per montare dischi
 in automatico o notificare altri processi del desktop della presenza dei
 nuovi dischi rilevati.
\end_layout

\begin_layout Section
Installare programmi su GNU/Linux e i Gestori di Pacchetti
\end_layout

\begin_layout Standard
A differenza della distro utilizzata si hanno diversi manager dei pacchetti
 (o delle installazioni più in generale).
 
\end_layout

\begin_layout Itemize
Le Debian based utilizzano:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
APT: Per installare pacchetti da repository
\end_layout

\begin_layout Itemize
DPKG: Per installare pacchetti locali con estensione 
\begin_inset Quotes eld
\end_inset

.deb
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Aptitude: E' uno strumento aggiuntivo per installare i pacchetti da repository
 ormai non più molto usato
\end_layout

\end_deeper
\begin_layout Itemize
Le RedHat based utilizzano:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
YUM: Per installare pacchetti da repository
\end_layout

\begin_layout Itemize
RPM: Per installare pacchetti locali con estensione 
\begin_inset Quotes eld
\end_inset

.rpm
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Yumdownloader & Rpm2cpio: Sono strumenti aggiuntivi per gestire i pacchetti
\end_layout

\end_deeper
\begin_layout Itemize
Le Arch based utilizzano:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Pacman
\end_layout

\end_deeper
\begin_layout Itemize
Le Gentoo based utilizzano:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Portage: Costituisce un sistema più complesso, su questo tipo di distro
 si compilano i codici sorgenti anche se qualche pacchetto binario esiste.
\end_layout

\end_deeper
\begin_layout Standard
Comandi comuni a tutte le distro per avere delle informazioni sui programmi
 installati sono whereis e which.
 N.B.: E' possibile convertire un pacchetto 
\begin_inset Quotes eld
\end_inset

.rpm
\begin_inset Quotes erd
\end_inset

 in 
\begin_inset Quotes eld
\end_inset

.deb
\begin_inset Quotes erd
\end_inset

 o viceversa attraverso un programma chiamato alien.
 Un comodo reference per vedere le differenze tra un package manager e l'altro
 è 
\begin_inset CommandInset href
LatexCommand href
name "Differenze principali tra Package Manager"
target "https://wiki.archlinux.org/index.php/Pacman_Rosetta"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Whereis
\end_layout

\begin_layout Standard
Il programma whereis cerca i file relativi ad un programma installato, ha
 delle directory predefinite dove cercare.
 Mi fornirà la locazione dei binari (eseguibili), delle librerie relative
 al programma e delle pagine man del programma; questo comando è quindi
 utilizzato per localizzare i programmi installati nelle loro directory.
\end_layout

\begin_layout Itemize
whereis apache2 //mi fornisce tutte le locazioni riguardanti il pacchetto
 apache2
\end_layout

\begin_layout Subsubsection
Which
\end_layout

\begin_layout Standard
Il programma 
\begin_inset Quotes eld
\end_inset

which
\begin_inset Quotes erd
\end_inset

 mi dice il percorso assoluto del comando/programma esistente su un computer
 e sui eventuali alias.
\end_layout

\begin_layout Itemize
which nomecomando //mi fornisce il percorso dell'eseguibile e la lista degli
 alias associati a questo eseguibile
\end_layout

\begin_layout Standard
Un'altra differenza tra which e whereis sta nel fatto che which cerca gli
 eseguibili solo nelle directory elencate nella variabile d'ambiente $PATH,
 mentre whereis cerca gli eseguibili in tutto il filesystem.
 We have to understand that we can run programs without 
\begin_inset Quotes eld
\end_inset

./programName
\begin_inset Quotes erd
\end_inset

 but only with 
\begin_inset Quotes eld
\end_inset

programName
\begin_inset Quotes erd
\end_inset

 if the program is located in one of the positions of the shell variable
 
\begin_inset Quotes eld
\end_inset

$PATH
\begin_inset Quotes erd
\end_inset

\SpecialChar endofsentence

\end_layout

\begin_layout Subsubsection
Informazioni generali sui pacchetti
\end_layout

\begin_layout Standard
Quando vediamo un pacchetto tipo:
\end_layout

\begin_layout Itemize
nano-2.2.6-1.i386.rpm
\end_layout

\begin_layout Standard
Allora le informazioni sono separate dai trattini, sto installando il pacchetto
 chiamato 
\begin_inset Quotes eld
\end_inset

nano
\begin_inset Quotes erd
\end_inset

 della versione 2.2.6 della build 1 per l'architettura CPU i386.
\end_layout

\begin_layout Subsubsection
Installazione di programmi portable
\end_layout

\begin_layout Standard
Può capitare a volte di scaricare programmi per cui viene è disponibile
 la directory con gli eseguibili, quindi non possiamo installare questo
 programma con un gestore pacchetti ma ci basta avviarlo (una volta assicurati
 di avere i permessi di avvio 
\begin_inset Quotes eld
\end_inset

chmod +x nomepgm
\begin_inset Quotes erd
\end_inset

) con 
\begin_inset Quotes eld
\end_inset

./nomepgm
\begin_inset Quotes erd
\end_inset

.
 Per rendere eseguibile un programma avviandolo direttamente da terminale
 con 
\begin_inset Quotes eld
\end_inset

nomepgm
\begin_inset Quotes erd
\end_inset

 come se avviassimo un programma normale allora è buona norma installare
 il programma nella directory 
\begin_inset Quotes eld
\end_inset

/opt/directoryPgm
\begin_inset Quotes erd
\end_inset

 e poi creare un soft link nella directory 
\begin_inset Quotes eld
\end_inset

/usr/bin
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsubsection
Type & Alias
\end_layout

\begin_layout Standard
Type mi dice come viene interpretato un comando, quindi posso vedere se
 quello che sto eseguendo è un alias.
\end_layout

\begin_layout Itemize
type ls //mi dice come viene eseguito ls e se è un alias a cosa si riferisce
\end_layout

\begin_layout Standard
Gli alias sono una struttura comoda per automatizzare dei flag con dei comandi
 o generalmente per riferirmi a comandi lunghi con nomi più corti; da terminale
 posso eseguire:
\end_layout

\begin_layout Itemize
alias //mi mostra tutti gli alias in uso dall'utente
\end_layout

\begin_layout Itemize
alias nomeComando //mi mostra l'alias associato al comando, vedasi 
\begin_inset Quotes eld
\end_inset

alias ls
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
alias name='unix command with options' //mi setta name al comando tra singoli
 apici
\end_layout

\begin_layout Itemize
unalias nomeComando //elimina l'alias associato al comando 
\begin_inset Quotes eld
\end_inset

nomeComando
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
unalias -a //elimina tutti gli alias
\end_layout

\begin_layout Itemize
alias edu=
\begin_inset Quotes erd
\end_inset

/home/myDirectory/myInterestedDir
\begin_inset Quotes erd
\end_inset

 //usata per fare shortcut a directory, dopo posso usare la notazione 
\begin_inset Quotes eld
\end_inset

cd $edu
\begin_inset Quotes erd
\end_inset

 o generalmente 
\begin_inset Quotes eld
\end_inset

$edu
\begin_inset Quotes erd
\end_inset

 per riferirmi al percorso creato, soluzione non utilizzata, nella realtà
 si usano le variabili per queste cose, in quanto gli alias vengono utilizzati
 più per i comandi, quindi creo una variabile e poi mi riferisco con la
 notazione 
\begin_inset Quotes eld
\end_inset

$nomeVariabile
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Nota bene che gli alias variano da utente ad utente, e vengono cancellati
 dopo il logout, per rendere un alias permenente dobbiamo salvare il comando
 alias all'interno del file 
\begin_inset Quotes eld
\end_inset

~/.bashrc
\begin_inset Quotes erd
\end_inset

 o in caso di alias globale (che vale per tutti gli utenti) in 
\begin_inset Quotes eld
\end_inset

/etc/bash.bashrc
\begin_inset Quotes erd
\end_inset

; anche se non è rara in alcuni casi la presenza di un file chiamato 
\begin_inset Quotes eld
\end_inset

.bash_aliases
\begin_inset Quotes erd
\end_inset

, fatto appositamente per gli alias, comunque possiamo capire se questo
 file viene letto dal file 
\begin_inset Quotes eld
\end_inset

.bashrc
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsection
APT Package Manager (High Level)
\end_layout

\begin_layout Standard
apt-get is a high-level package manager for Debian and derivatives, and
 provides a simple way to retrieve and install packages, including dependency
 resolution, from multiple sources using the command line.
 Unlike dpkg, apt-get does not work directly with *.deb files, but with the
 package proper name.
\end_layout

\begin_layout Standard
In /etc/apt/sources.list contiene i repository, è sempre meglio installare
 i programmi esclusivamente dal repository e aggiungere al repository sorgenti
 fidate.
 Con: 
\end_layout

\begin_layout Itemize
apt-get update //aggiorno le informazioni dei repository.
 
\end_layout

\begin_layout Itemize
apt-cache search apache2 //cerca tutti i pacchetti relazionati ad apache2
\end_layout

\begin_layout Itemize
apt-cache search "web server" //mi elenca tutti i pacchetti che hanno nella
 descrizione quel nome
\end_layout

\begin_layout Itemize
apt-cache show apache2 //mostra informazioni sul pacchetto chiamato 
\begin_inset Quotes eld
\end_inset

apache2
\begin_inset Quotes erd
\end_inset

, come dimensioni del pacchetto, descrizione ed altro
\end_layout

\begin_layout Itemize
apt-cache show apache2 | grep -i 
\begin_inset Quotes eld
\end_inset

installed-size
\begin_inset Quotes erd
\end_inset

 //mostra le dimensioni del pacchetto
\end_layout

\begin_layout Itemize
apt-get install apache2 //installa apache2, o se apache2 è già installato,
 lo aggiorna all'ultima versione, in questo caso viene aggiornato solo il
 pacchetto apache2
\end_layout

\begin_layout Itemize
apt-get remove apache2 –purge //disinstalla un pacchetto, l'opzione –purge
 si assicura di effettuare un complete removal
\end_layout

\begin_layout Itemize
apt-get purge apache2 //effettua la stessa cosa del precedente
\end_layout

\begin_layout Itemize
apt-get clean //pulisce i file temporanei delle installazioni effettuate.
 i 
\begin_inset Quotes eld
\end_inset

.deb
\begin_inset Quotes erd
\end_inset

 ad esempio
\end_layout

\begin_layout Itemize
apt-get autoclean //toglie i file nel repository che non sono più disponibili
 
\begin_inset Quotes eld
\end_inset

i vecchi .deb
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
apt-get -t wheezy-backports nomePacchetto //installa un pacchetto da un
 repository da noi specificato, ad esempio utilizzato quando si usano repository
 stable e backports
\end_layout

\begin_layout Itemize
apt-get install -s php5 //fa una simulazione elencando i file che installerebbe
 quelli che rimuoverebbe e qualli modificati
\end_layout

\begin_layout Itemize
apt-get install -y php5 //conferma con 
\begin_inset Quotes eld
\end_inset

yes
\begin_inset Quotes erd
\end_inset

 a tutte le domande
\end_layout

\begin_layout Itemize
apt-get install —show-progress perl5 //mostra il progresso del processo
 con delle percentuali
\end_layout

\begin_layout Itemize
apt-get install –fix-broken //mette a posto pacchetti broken, con dipendenze
 mancanti
\end_layout

\begin_layout Itemize
sudo apt-get –no-install-recommends install //installa un pacchetto senza
 quelli raccomandati, questo è utile quando si installa ad esempio un desktop
 environment e non si vuole installare tutta la marea di pacchetti di base
 che vengono solitamente installati con questi
\end_layout

\begin_layout Itemize
apt-get install –only-upgrade nomepacchetto //aggiorna solo il pacchetto
 chiamato nomepacchetto
\end_layout

\begin_layout Itemize
apt-get install –install-suggests //mi installa anche i pacchetti suggeriti,
 utili con alcuni pacchetti che una volta installati ci sembra che ancora
 manchi qualcosa, ad esempio nella mia esperienza (lyx, qtcreator, ecc...)
\end_layout

\begin_layout Itemize
apt-get install 
\end_layout

\begin_layout Itemize
apt-get source php5 //scarica il pacchetto coi file sorgenti nella directory
 presente
\end_layout

\begin_layout Itemize
apt-get download nomepgm //mi scarica il .deb del pgm
\end_layout

\begin_layout Itemize
apt-get download package; dpkg -i --force-not-root --root=$HOME package.deb
 //installa un pacchetti a livello utente, molto utile, nel momento in cui
 non vogliamo sporcare le directory di sistema
\end_layout

\begin_layout Itemize
apt-get upgrade //aggiorna tutti i pacchetti, lasciando i pacchetti alla
 versione corrente ancora installati, e non aggiorna i pacchetti che richiedono
 la rimozione di altri pacchetti
\end_layout

\begin_layout Itemize
apt-get build-dep -d nomepacchetto //scarica tutti i pacchetti dipendenza
 del pacchetto menzionato, questa opzioni è molto utile nel momento in cui
 dobbiamo passare un pacchetto ad un server offline che non ha accesso ad
 alcun repository su internet o a cui è stata privata la connettività, attenzion
e sarà ovviamente necessario scaricare anche il pacchetto interessato con
 un 
\begin_inset Quotes eld
\end_inset

apt-get download nomepacchetto
\begin_inset Quotes erd
\end_inset

, inoltre i pacchetti saranno trovati nella directory 
\begin_inset Quotes eld
\end_inset

/var/cache/apt/archives/
\begin_inset Quotes erd
\end_inset

, è l'analogo di 
\begin_inset Quotes eld
\end_inset

yumdownloader –resolve
\begin_inset Quotes erd
\end_inset

 delle distro RH-Based
\end_layout

\begin_layout Itemize
apt-get dist-upgrade //aggiorna tutti i pacchetti, e a differenza di un
 normale 
\begin_inset Quotes eld
\end_inset

apt-get upgrade
\begin_inset Quotes erd
\end_inset

 rimuove le versioni correnti dei programmi, e gestisce in modo intelligente
 l'aggiornamento dell'intero sistema, solitamente questo costituisce un
 aggiornamento della distro ,(The command upgrade keeps a package at its
 installed obsolete version if upgrading would need an extra package to
 be installed, for a new dependency to be satisfied.
 The dist-upgrade command is less conservative.) 
\end_layout

\begin_layout Itemize
apt-get dist-upgrade -d; sudo apt-get dist-upgrade –no-download //in this
 case we first only download the packages and then we upgrade from the packages
 in the cache
\end_layout

\begin_layout Itemize
apt-cache stats //fornisce statistiche
\end_layout

\begin_layout Itemize
apt-cache depends apache2 //mi dice le dipendenze del pacchetto apache2
\end_layout

\begin_layout Itemize
apt-cache pkgnames //mi lista tutti i pacchetti con | wc -l mi dice anche
 il numero (word count)
\end_layout

\begin_layout Itemize
apt-cache unmet //mi lista le dipendenze non soddisfatte all'interno del
 repo
\end_layout

\begin_layout Itemize
apt-get install –only-upgrade nomepacchetto //aggiorna solo il pacchetto
 menzionato, e solo se quest'ultimo è già installato sul sistema, nel caso
 il pacchetto non sia installato sul sistema, allora nessun aggiornamento
 verrà eseguito e nessun pacchetto verrà installato
\end_layout

\begin_layout Itemize
apt-mark hold pkg //holda un pacchetto, cioè fa in modo che non venga aggiornato
/rimosso da successive installazioni/aggiornamenti
\end_layout

\begin_layout Itemize
apt-mark unhold pkg //rimuove l'hold dal pacchetto menzionato
\end_layout

\begin_layout Itemize
cat /etc/apt/preferences //visualizza i pacchetti messi in hold
\end_layout

\begin_layout Standard
La directory 
\begin_inset Quotes eld
\end_inset

/var/cache/apt/archives
\begin_inset Quotes erd
\end_inset

 che contiene gli archivi scaricati dei pacchetti .deb, in pratica quando
 faccio clean ed autoclean il package manager rimuove i pacchetti scaricati
 in questa directory.
 Se mi dovesse servire un programma da portare su un altro computer, potrei
 installarlo e poi andare a prendere da qui tutti i pacchetti con le dipendenze.
 E' possibile capire in quale pacchetto è contenuto un certo comando attraverso
 l'utility 
\begin_inset Quotes eld
\end_inset

apt-file
\begin_inset Quotes erd
\end_inset

, che deve essere installato, facciamo quindi:
\end_layout

\begin_layout Itemize
apt-get install apt-file //installa apt-file
\end_layout

\begin_layout Itemize
apt-file update //aggiorna la cache apt-file
\end_layout

\begin_layout Itemize
apt-file search nomeComando //cerca in quali pacchetti è contenuto il comando
 
\begin_inset Quotes eld
\end_inset

nomeComando
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
whereis cal; apt-file search /usr/bin/cal | grep -w cal //molto utile quando
 accoppiato al comando whereis, per vedere da dove viene un determinato
 eseguibile
\end_layout

\begin_layout Itemize
apt-file search convert | grep -iw "/usr/bin/commandName" //cerca a quale
 pacchetto appartiene il comando col percorso specificato
\end_layout

\begin_layout Paragraph
Altre utility per il package management
\end_layout

\begin_layout Standard
Se dobbiamo gestire i programmi compilati, può essere utile utilizzare 
\begin_inset Quotes eld
\end_inset

checkinstall
\begin_inset Quotes erd
\end_inset

, che mantiene nel repository i programmi compilati.
 
\end_layout

\begin_layout Itemize
checkinstall is a program that tracks all files installed by "make install"
 (or equivalent), creates a Debian (or other) package with those files,
 and adds it to the installed packages database, allowing for easy package
 removal or distribution.
 http://asic-linux.com.mx/~izto/checkinstall/
\end_layout

\begin_layout Itemize
stow is a nifty program used to manage a /usr/local/ hierarchy.
 It keeps all the programs separate, so you can install and remove them
 without playing the "which program does that file belong to" game; ask
 me about
\end_layout

\begin_layout Subsection
DPKG (Low Level)
\end_layout

\begin_layout Standard
dpkg is a low-level package manager for Debian-based systems.
 It can install, remove, provide information about and build *.deb packages
 but it can’t automatically download and install their corresponding dependencie
s.
\end_layout

\begin_layout Itemize
dpkg -i nomepacchetto //installa il pacchetto, è da notare che solitamente
 darà errori dovuti alla mancanza delle dipendenze, questo evento viene
 registrato dal nostro sistema e dovremo solo lanciare un 
\begin_inset Quotes eld
\end_inset

apt-get update
\begin_inset Quotes erd
\end_inset

 seguito da un 
\begin_inset Quotes eld
\end_inset

apt-get -f upgrade
\begin_inset Quotes erd
\end_inset

 per installare o aggiornare i pacchetti richiesti; se il pacchetto è già
 installato, questo viene aggiornato
\end_layout

\begin_layout Itemize
dpkg –get-selection //lista tutti i pacchetti installati
\end_layout

\begin_layout Itemize
dpkg -l //elenca tutti i pacchetti installati con le relative versioni,
 utile anche per fare report del software installato in un sistema
\end_layout

\begin_layout Itemize
dpkg -L nomepgm //lista tutti i file installati da quel programma.
\end_layout

\begin_layout Itemize
dpkg-reconfigure nomepgm //mi riconfigura il programma, se ho sbagliato
 qualcosa nella configurazione; molto utile dopo aggiornamenti se dovessi
 avere problemi (mi è capitato ad esempio con un programma di virtualizzazione
 dopo degli aggiornamenti), in pratica è il comando adatto ogniqualvolta
 vogliamo effettuare delle reinstallazioni, in quanto pur eliminando un
 programma con 
\begin_inset Quotes eld
\end_inset

apt-get purge nomeProgramma
\begin_inset Quotes erd
\end_inset

 e reinstallandolo non avrebbe lo stesso effetto, questo comportamento è
 causato da configurazioni di default usate da debconf, che ci porteranno
 ad utilizzare le stesse confiugurazioni precedenti nel momento in cui non
 viene lanciato un dpkg-reconfigure
\end_layout

\begin_layout Itemize
dpkg –remove nomepgm //rimuove il programma ma lascia intatti i file di
 ocnfigurazione
\end_layout

\begin_layout Itemize
dpkg –purge nomepgm //rimuove qualsiasi cosa (anche file di config) relativa
 al pgm indicato, nel caso dovessimo avere problemi con un remove normale,
 questo costituisce un remove più a basso livello
\end_layout

\begin_layout Itemize
dpkg -S /usr/bin/nomeProgramma //indica il pacchetto da cui è stato installato
 il programma nomeProgramma
\end_layout

\begin_layout Itemize
dpkg -s nomePacchetto | grep Status //mi dice se un programma è installato
 o meno
\end_layout

\begin_layout Itemize
dpkg -S /path/to/file //indica il pacchetto da cui è stato installato il
 determinato file, uguale a 
\begin_inset Quotes eld
\end_inset

dpkg –search filename
\begin_inset Quotes erd
\end_inset

, un'alternativa più fast è dlocate
\end_layout

\begin_layout Itemize
dpkg –purge `dpkg -l | egrep "^rc" | cut -d' ' -f3` //rimuove i file di
 configurazione di programmi che sono stati rimossi ma hanno lasciato i
 loro file di configurazione, MOLTO UTILE
\end_layout

\begin_layout Itemize
apt-get download package; dpkg -i --force-not-root --root=$HOME package.deb
 //installa un pacchetti a livello utente, molto utile, nel momento in cui
 non vogliamo sporcare le directory di sistema
\end_layout

\begin_layout Itemize
dlocate -S filename //uguale a 
\begin_inset Quotes eld
\end_inset

dpkg -S /path/to/file
\begin_inset Quotes erd
\end_inset

, ma più veloce, attenzione questi ultimi due comandi funzionano solo per
 file già presenti sul sistema
\end_layout

\begin_layout Itemize
zgrep foo Contents-ARCH.gz //in questo caso cerchiamo file o parole chiave
 all'interno di pacchetti non installati, se non troviamo ad esempio il
 file /etc/fileAcaso.conf, e non sappiamo come si chiama il pacchetto che
 lo installa, possiamo usare questo comando, al posto di 
\begin_inset Quotes eld
\end_inset

ARCH
\begin_inset Quotes erd
\end_inset

, dobbiamo mettere l'architettura desiderata
\end_layout

\begin_layout Itemize
dpkg –status nomePacchetto //indica molte informazioni sul pacchetto e anche
 le dipendenze opzionali consigliate, (molto importanti, se il programma
 installato non si comporta come ci aspettiamo), ad esempio lyx
\end_layout

\begin_layout Itemize
dpkg-query -Wf '${Installed-Size}
\backslash
t${Package}
\backslash
n' | sort -n //check biggest packages, un'altra opzione sarebbe installare
 wajig
\end_layout

\begin_layout Standard
posso verificare la corretta disinstallazione di un programma, dopo averlo
 disinstallato con: 
\end_layout

\begin_layout Itemize
which nomepgm 
\end_layout

\begin_layout Standard
o con
\end_layout

\begin_layout Itemize
dpkg –get-selections | grep nomepgm
\end_layout

\begin_layout Subsection
Aptitude (High Level)
\end_layout

\begin_layout Standard
aptitude is another high-level package manager for Debian-based systems,
 and can be used to perform management tasks (installing, upgrading, and
 removing packages, also handling dependency resolution automatically) in
 a fast and easy way.
 It provides the same functionality as apt-get and additional ones, such
 as offering access to several versions of a package.
\end_layout

\begin_layout Standard
Aptitude è un'altra interfaccia ad alto livello per gestire pacchetti:
\end_layout

\begin_layout Itemize
aptitude search nomepgm //mi fornisce una lista dei pacchetti affini a nomepgm
\end_layout

\begin_layout Itemize
aptitude install nomepgm //installa il programma nomepgm
\end_layout

\begin_layout Itemize
aptitude hold package_name //locka un pacchetto alla versione corrente
\end_layout

\begin_layout Itemize
aptitude unhold package_name //unlocka un pacchetto 
\end_layout

\begin_layout Itemize
aptitude //richiama l'interfaccia grafica, da qui possiamo anche settare
 i pacchetti che non voglio aggiornare, posso schiacciare 
\begin_inset Quotes eld
\end_inset

?
\begin_inset Quotes erd
\end_inset

 per avere un help
\end_layout

\begin_layout Itemize
aptitude update //aggiorna il repository
\end_layout

\begin_layout Standard
La maggior parte dei comandi per APT esiste anche per Aptitude.
\end_layout

\begin_layout Subsection
YUM (High Level)
\end_layout

\begin_layout Standard
yum adds the functionality of automatic updates and package management with
 dependency management to RPM-based systems.
 As a high-level tool, like apt-get or aptitude, yum works with repositories.
\end_layout

\begin_layout Standard
Yum nasce con la distribuzione GNU/Linux Yellowdog è l'analogo di apt-get
 di debian.
 Il file di configurazione è 
\begin_inset Quotes eld
\end_inset

/etc/yum.conf
\begin_inset Quotes erd
\end_inset

, e non va toccato se non per modificare i repository.
 Abbiamo anche un altro file dove è possibile settare i repository, il posto
 è 
\begin_inset Quotes eld
\end_inset

/etc/yum.repos.d/
\begin_inset Quotes erd
\end_inset

 in questa directory ho una lista di file con estensione 
\begin_inset Quotes eld
\end_inset

.repo
\begin_inset Quotes erd
\end_inset

 che rappresentano i repository.
 Alcuni esempi di applicazione di yum:
\end_layout

\begin_layout Itemize
yum update //aggiorna il database dei repository
\end_layout

\begin_layout Itemize
yum search nomepgm //cerca il pacchetto nomepgm
\end_layout

\begin_layout Itemize
yum check-update //controlla se sono disponibili aggiornamenti
\end_layout

\begin_layout Itemize
yum install nomepacchetto //installa il pacchetto nomepacchetto
\end_layout

\begin_layout Itemize
yum check-update nomepgm //controlla se ci sono aggiornamenti per il programma
 nomepgm
\end_layout

\begin_layout Itemize
yum remove nomegpm //rimuove il programma
\end_layout

\begin_layout Itemize
yum upgrade //è uguale ad update ma rimuove dal database i pacchetti obsoleti
\end_layout

\begin_layout Itemize
yum list nomepgm //elenca le caratteristiche del pacchetto nomepgm
\end_layout

\begin_layout Itemize
yum info nomepgm //è equivalente a rpm -qi su un programma installato
\end_layout

\begin_layout Itemize
yum deplist nomepgm //elenca le dipendenze di nomepgm
\end_layout

\begin_layout Itemize
yum clean packages //rimuove i pacchetti nella cache
\end_layout

\begin_layout Itemize
yum repolist //elenca gli attuali repository
\end_layout

\begin_layout Itemize
yum provides nomeComando //mi indica quale pacchetto mi fornisce un determinato
 eseguibile, utile nel momento in cui dobbiamo installare su un'altra macchina
 determinati programmi
\end_layout

\begin_layout Itemize
yum clean all //rimuove tutto dalla cache (pacchetti, headers, metadata,
 plugins, ecc...)
\end_layout

\begin_layout Itemize
yum grouplist //elenca tutti i gruppi di pacchetti disponibili
\end_layout

\begin_layout Itemize
yum grouplist 
\begin_inset Quotes eld
\end_inset

Development Tools
\begin_inset Quotes erd
\end_inset

 //elenca i gruppi di pacchetti che hanno nel nome la stringa indicata
\end_layout

\begin_layout Itemize
yum groupinfo 
\begin_inset Quotes eld
\end_inset

Development Tools
\begin_inset Quotes erd
\end_inset

 //visualizza informazioni e i pacchetti compresi nel group 
\begin_inset Quotes eld
\end_inset

Development Tools
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
yum groupinstall 
\begin_inset Quotes eld
\end_inset

Development Tools
\begin_inset Quotes erd
\end_inset

 //installa il gruppo chiamato 
\begin_inset Quotes eld
\end_inset

Development Tools
\begin_inset Quotes erd
\end_inset

 che contiene tutti i tool richiesti per la compilazione
\end_layout

\begin_layout Standard
Per poter visualizzare la lista di file installati da un pacchetto dobbiamo
 installare il programma yum-utils, attraverso:
\end_layout

\begin_layout Itemize
yum install yum-utils
\end_layout

\begin_layout Standard
Una volta installato, nel momento in cui volessimo vedere i file installati
 dal pacchetto di nome 
\begin_inset Quotes eld
\end_inset

nomePacchetto
\begin_inset Quotes erd
\end_inset

, eseguiamo un:
\end_layout

\begin_layout Itemize
repoquery -l 
\begin_inset Quotes eld
\end_inset

nomePacchetto
\begin_inset Quotes erd
\end_inset

 // il flag 
\begin_inset Quotes eld
\end_inset

-l
\begin_inset Quotes erd
\end_inset

 è equivalente all'opzione 
\begin_inset Quotes eld
\end_inset

–list
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Subsection
RPM (Low Level)
\end_layout

\begin_layout Standard
rpm is the package management system used by Linux Standard Base (LSB)-compliant
 distributions for low-level handling of packages.
 Just like dpkg, it can query, install, verify, upgrade, and remove packages,
 and is more frequently used by Fedora-based distributions, such as RHEL
 and CentOS.
\end_layout

\begin_layout Itemize
rpm -i nomepgm //per installare il pacchetto, (non me lo installa se esiste
 un pacchetto con lo stesso nome), se devo aggiornare prima lo elimino.
\end_layout

\begin_layout Itemize
rpm -e nomepgm //mi elimina il pacchetto ma solo l'eseguibile non documentazione
 ecc...
 (tipo dpkg –remove nomepgm)
\end_layout

\begin_layout Itemize
rpm -ihv nomepacchetto.rpm //mi installa il pacchetto con 'h' mi fa vedere
 il progresso e la 'v' sta per verbose.
\end_layout

\begin_layout Itemize
rpm -q nomepacchetto //mi fa una query cercandomi i pacchetti che hanno
 quel nome installati sul mio sistema
\end_layout

\begin_layout Itemize
rpm -qi nomepacchetto //mi fa vedere le info di installazione relative ad
 un pacchetto installato sul mio sistema.
\end_layout

\begin_layout Itemize
rpm -qf percorso //mostra quale pacchetto ha installato il programma o la
 directory situata in 
\begin_inset Quotes eld
\end_inset

percorso
\begin_inset Quotes erd
\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
ad esempio nel caso volessimo vedere quale pacchetto è responsabile dell'install
azione del programma 
\begin_inset Quotes eld
\end_inset

lspci
\begin_inset Quotes erd
\end_inset

, facciamo un 
\begin_inset Quotes eld
\end_inset

whereis lspci
\begin_inset Quotes erd
\end_inset

 per mostrare il percorso e supponendo che il percorso del programma sia
 
\begin_inset Quotes eld
\end_inset

/usr/sbin/lspci
\begin_inset Quotes erd
\end_inset

, eseguendo un 
\begin_inset Quotes eld
\end_inset

rpm -qf /usr/sbin/lspci
\begin_inset Quotes erd
\end_inset

 vediamo il pacchetto che ci ha fornito il programma lspci, oppure un altro
 caso potrebbe essere, vogliamo vedere quale pacchetto ha installato la
 directory 
\begin_inset Quotes eld
\end_inset

/etc/init.d
\begin_inset Quotes erd
\end_inset

, allora eseguiamo un 
\begin_inset Quotes eld
\end_inset

rpm -qf /etc/init.d
\begin_inset Quotes erd
\end_inset

 e verrà mostrato il pacchetto responsabile
\end_layout

\end_deeper
\begin_layout Itemize
rpm -q –list nomepacchetto //mi elenca tutti i file relativi a quel pacchetto
\end_layout

\begin_layout Itemize
rpm -qR nano //mi dice le dipendenze e le librerie utilizzate di nano 'R'
 sta per requirements
\end_layout

\begin_layout Itemize
rpm -u nomepacchetto //aggiorna il pacchetto 
\end_layout

\begin_layout Itemize
rpm -f nomepacchetto //upgrada il pacchetto solo se esiste una versione
 precedente
\end_layout

\begin_layout Standard
Potrebbe capitarmi di dover fare il rebuild del database, con 
\begin_inset Quotes eld
\end_inset

rpm –rebuilddb
\begin_inset Quotes erd
\end_inset

.
 ( lo faccio se ho fatto molte installazioni/rimozioni).
 E' importante il file /usr/lib/rpm/rpmrc che è il file di configurazione
 per il programma rpm, non bisogna far casini qui.
\end_layout

\begin_layout Subsection
Yumdownloader and rpm2cpio
\end_layout

\begin_layout Standard
Yumdownloader ci permette di scaricare file dal repository senza installarli
 (cosa che normalmente fa yum), possiamo eseguire:
\end_layout

\begin_layout Itemize
yumdownloader nomepgm //scarica il pacchetto del programma
\end_layout

\begin_layout Itemize
yumdownloader –source nomepgm //scarica il pacchetto sorgente del programma
\end_layout

\begin_layout Itemize
yumdownloader –resolve nomepgm //questo comando scaricherà il pacchetto
 con l'intero albero delle dipendenze associate, è molto utile nel caso
 dovessi installare un'applicazione su un server senza connetterlo ad internet
 o installare un programma su una macchina che non può connettersi ad internet
\end_layout

\begin_layout Standard
Cpio is a package used to view rpm package content, but in order to view
 it we must use 
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

rpm2cpio filename.rpm | cpio -t
\begin_inset Quotes erd
\end_inset

, cpio archive are info files containing info about a package; basically
 rpm2cpio creates a cpio of our rpm package.
\end_layout

\begin_layout Subsubsection
cpio
\end_layout

\begin_layout Standard
cpio is a general file archiver utility and its associated file format.
 It is primarily installed on Unix-like computer operating systems.
 The software utility was originally intended as a tape archiving program
 as part of the Programmer's Workbench (PWB/UNIX), and has been a component
 of virtually every Unix operating system released thereafter.
 Its name is derived from the phrase copy in and out, in close description
 of the program's use of standard input and standard output in its operation.
\end_layout

\begin_layout Standard
All variants of Unix also support other backup and archiving programs, such
 as tar, which has become more widely recognized.
 The use of cpio by the RPM Package Manager, in the initramfs program of
 Linux kernel 2.6, and in Apple Computer's Installer (pax) make cpio an important
 archiving tool.
 We must remember that both tar and cpio have a single purpose: concatenate
 many separate files to a single stream, in other words their purpose is
 to create a single contiguous file from an input of multiple files and
 directories.
 They don't compress data.
 (These days tar is more popular due to its relative simplicity – it can
 take input files as arguments instead of having to be coupled with find
 as cpio has.)
\end_layout

\begin_layout Standard
Vediamo alcuni esempi:
\end_layout

\begin_layout Itemize
find .
 -depth | cpio -ov > archive.cpio // l'opzione 
\begin_inset Quotes eld
\end_inset

-o
\begin_inset Quotes erd
\end_inset

 crea un archivio, mentre 
\begin_inset Quotes eld
\end_inset

-v
\begin_inset Quotes erd
\end_inset

 visualizza a video la lista di tutti i file inclusi, the '-depth' option
 forces 'find' to print of the entries in a directory before printing the
 directory itself.
 This limits the effects of restrictive directory permissions by printing
 the directory entries in a directory before the directory name itself
\end_layout

\begin_layout Itemize
cpio -idv < directory.cpio //estrae la directory
\end_layout

\begin_layout Itemize
ls | cpio -ov -H tar -F sample.tar //in questo modo si crea un archivio tar
 con cpio, attenzione che ls includerà solo i file ad un livello di profondità,
 avremmo dovuto usare invece 
\begin_inset Quotes eld
\end_inset

find .
\begin_inset Quotes erd
\end_inset

 per includerli tutti
\end_layout

\begin_layout Itemize
find .
 -depth | cpio -H newc -ov –owner root:root > initramfs.cpio //questo comando
 è utilizzato quando ad esempio si creano initramfs, con il flag 
\begin_inset Quotes eld
\end_inset

-H
\begin_inset Quotes erd
\end_inset

 specifico il formato dell'archivio cpio, in questo caso il formato è 
\begin_inset Quotes eld
\end_inset

newc
\begin_inset Quotes erd
\end_inset

, quello utilizzato dalle initramfs, è utilizzato 
\begin_inset Quotes eld
\end_inset

newc
\begin_inset Quotes erd
\end_inset

, which supports file systems having more than 65536 inodes, altre possibili
 opzioni con il flag 
\begin_inset Quotes eld
\end_inset

-H
\begin_inset Quotes erd
\end_inset

 sono:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
odc: The old (POSIX .1) portable format.
\end_layout

\begin_layout Itemize
crc: The new (SVR4) portable format with a checksum added; in pratica un
 newc con un checksum addato
\end_layout

\begin_layout Itemize
tar: The old tar format.
\end_layout

\begin_layout Itemize
hpodc: The portable format used by HPUX's cpio (which stores device files
 differently).
\end_layout

\begin_layout Itemize
ecc..
\end_layout

\end_deeper
\begin_layout Section
Shells
\end_layout

\begin_layout Standard
Esistono varie shell, la shell di default sui sistemi GNU/Linux è la Bash,questa
 è la shell più comune infatti lo scripting fatto per le altre shell è solitamen
te compatibile con quello Bash, comunque le shell più famose sono:
\end_layout

\begin_layout Itemize
bash
\end_layout

\begin_layout Itemize
ksh //usata come shell di default su OpenBSD
\end_layout

\begin_layout Itemize
csh/tcsh //usata come shell di default su FreeBSD, la tcsh non è altro che
 una csh con feature aggiunte (come autocompletamento, ecc...)
\end_layout

\begin_layout Itemize
zsh //una shell avanzata che raggruppa molte delle feature di tutte le altre,
 questa è la mia preferita! 
\end_layout

\begin_layout Standard
ognuna di queste shell ha i propri vantaggi/svantaggi, per poter visualizzare
 la lista delle shell disponibili su un sistema possiamo eseguire:
\end_layout

\begin_layout Itemize
cat /etc/shells //visualizza tutte le shell disponibili
\end_layout

\begin_layout Standard
una volta individuata la shell che vogliamo possiamo eseguire:
\end_layout

\begin_layout Itemize
chsh -s {shell-name} {user-name} // dove l'opzione 
\begin_inset Quotes eld
\end_inset

-s
\begin_inset Quotes erd
\end_inset

 indica il percorso della shell
\end_layout

\begin_layout Standard
vediamo degli esempi pratici:
\end_layout

\begin_layout Itemize
chsh -s /bin/zsh //cambia la shell dell'utente che lancia il comando ad
 una zsh
\end_layout

\begin_layout Standard
oppure un utente root potrebbe cambiare le shell degli altri utenti con:
\end_layout

\begin_layout Itemize
chsh -s /bin/zsh utenteacaso //cambia la shell dell'utente 
\begin_inset Quotes eld
\end_inset

utenteacaso
\begin_inset Quotes erd
\end_inset

 ad una zsh
\end_layout

\begin_layout Standard
per vedere ad un utente quale shell è impostata possiamo visualizzare il
 file 
\begin_inset Quotes eld
\end_inset

/etc/passwd
\begin_inset Quotes erd
\end_inset

 alla riga corrispondente al suo nome.
\end_layout

\begin_layout Standard
Per capire con che shell sto lavorando attualmente posso eseguire:
\end_layout

\begin_layout Itemize
ps | grep $$ //visualizza il processo corrente, cioè la shell, vedremo bash
 se la shell è una bash, oppure zsh e così via.
\end_layout

\begin_layout Section
Shell e variabili d'ambiente
\end_layout

\begin_layout Subsection
Shell testuale ( DA RIGUARDARE)
\end_layout

\begin_layout Standard
Esistono alcuni comandi da shell molto utili, ad esempio:
\end_layout

\begin_layout Itemize
time programName //fornisce il tempo necessario per lanciare il programma
 programName 
\end_layout

\begin_layout Itemize
exec //è un comando utilizzato per lanciare un programma con lo stesso PID
 della shell, quindi appena termina, anche la shell termina
\end_layout

\begin_layout Itemize
set //imposta le opzioni di shell, valido per molte shell
\end_layout

\begin_layout Itemize
shopt //mostra le opzioni di shell (vale solo per alcune shell, ad esempio
 la Bash)
\end_layout

\begin_layout Standard
Alcuni file importanti per la shell di ogni utente sono:
\end_layout

\begin_layout Itemize
~/.bash_history //dove è salvata la cronologia dei comandi
\end_layout

\begin_layout Itemize
~/.bashrc //(configurazione shell non di login) dove è salvata la configurazione,
 per convenzione qui vengono salvati gli alias (validi per utente) e i comandi
 da avviare per ogni emulatore di terminale che apriamo, è il file di configuraz
ione delle shell non di login, quindi per ogni terminale che apriamo una
 volta fatto il login; a volte per gli alias si può anche fare (per mantenere
 le configurazioni più ordinate e modulari) un file 
\begin_inset Quotes eld
\end_inset

.bash_alias
\begin_inset Quotes erd
\end_inset

 nella home e richiamarlo con 
\begin_inset Quotes eld
\end_inset

source
\begin_inset Quotes erd
\end_inset

 da 
\begin_inset Quotes eld
\end_inset

.bashrc
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
~/.profile //(configurazione shell di login) altro file in cui sono salvate
 le configurazioni di shell, per convenzione qui vengono salvate le variabili
 d'ambiente, e i comandi da eseguire all'avvio della shell di login (un
 ambiente TUI-only, cioè solo testo senza ambiente grafico, o meglio, ambienti
 in cui dobbiamo eseguire startx per avviare l'ambiente grafico o in cui
 comunque effettuiamo login da un ambiente TUI, (o un altro esempio che
 costituisce un'eccezione sono i terminal multiplexer come tmux e screen
 che entrano in una shell di login) per vedere come autoavviare applicazioni
 all'avvio se si è installato un ambiente grafico fare riferimento alla
 sezione su Xorg).
 Questo file viene preso in considerazione solo se non esiste già un file
 specifico di configurazione per la shell utilizzata, se ad esempio usiamo
 una shell bash, allora a questo file sarà data una priorità più bassa e
 verranno letti (se esistono) i file 
\begin_inset Quotes eld
\end_inset

~/.bash_profile
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

~/.bash_login
\begin_inset Quotes erd
\end_inset

 
\end_layout

\begin_layout Itemize
~/.bash_logout //dove sono salvati tutti le operazioni da effettuare al logout
\end_layout

\begin_layout Itemize
/etc/bash.bashrc //file di configurazione globale dove è salvata la configurazion
e, per convenzione qui vengono salvati gli alias globali validi per tutti
 gli utenti
\end_layout

\begin_layout Itemize
/etc/bash/bashrc.d //uguale al precedente, ma è un'intera directory dove
 possiamo mettere tutti i file di configurazione globali per le shell non
 di login
\end_layout

\begin_layout Itemize
/etc/profile //file di configurazione globale in cui sono salvate le configurazi
oni di shell, per convenzione qui vengono salvate anche le variabili d'ambiente
 globali per le shell di login, le shell di login sono quelle usate quando
 non viene usato X, o di defualt sono quelle che vengono utilizzate da programmi
 come tmux o screen
\end_layout

\begin_layout Standard
Inoltre in alcune distro esistono directory come 
\begin_inset Quotes eld
\end_inset

/etc/profile.d/
\begin_inset Quotes erd
\end_inset

 in cui vengono salvati degli script che hanno lo stesso scopo dei file
 precedenti e vengono usati per automatizzare determinate operazioni al
 login degli utenti.
\end_layout

\begin_layout Standard
N.B.: Se vengono cambiate delle configurazioni globali attraverso i file sopracita
ti nella directory /etc, queste modifiche saranno attive solo al prossimo
 login degli utenti.
\end_layout

\begin_layout Subsubsection
Priorità dei file di Configurazione per la Bash Shell
\end_layout

\begin_layout Standard
Per le Shell di Login la shell Bash cerca di eseguire nell'ordine sottocitato
 i seguenti file:
\end_layout

\begin_layout Enumerate
/etc/profile
\end_layout

\begin_layout Enumerate
~/.bash_profile
\end_layout

\begin_layout Enumerate
~/.bash_login
\end_layout

\begin_layout Enumerate
~/.profile
\end_layout

\begin_layout Standard
e quando esce o si effettua il logout prova ad eseguire:
\end_layout

\begin_layout Enumerate
~/.bash_logout
\end_layout

\begin_layout Standard
Per le Shell non di Login, la shell Bash cerca di eseguire nell'ordine sottocita
to i seguenti file:
\end_layout

\begin_layout Enumerate
/etc/bash.bashrc
\end_layout

\begin_layout Enumerate
~/.bashrc
\end_layout

\begin_layout Subsubsection
Shell di Login o Shell di Non Login ?
\end_layout

\begin_layout Standard
Per controllare se siamo in una shell di login o in una shell non di login
 quando usiamo una shell Bash, possiamo usare il comando:
\end_layout

\begin_layout Itemize
shopt -q login_shell && echo 'Login shell' || echo 'Not login shell' //mostra
 video un messaggio mostrando se la shell in utilizzo è di login o non di
 login
\end_layout

\begin_layout Standard
oppure
\end_layout

\begin_layout Itemize
shopt | grep login_shell //mostrerà le variabili della shell
\end_layout

\begin_layout Standard
oppure ancora possiamo eseguire:
\end_layout

\begin_layout Itemize
echo $0 //se questo mostra in output 
\begin_inset Quotes eld
\end_inset

-bash
\begin_inset Quotes erd
\end_inset

 allora la nostra shell è di login se invece in output abbiamo 
\begin_inset Quotes eld
\end_inset

bash
\begin_inset Quotes erd
\end_inset

 allora la nostra shell è non di login
\end_layout

\begin_layout Subsubsection
Variabili d'ambiente della shell
\end_layout

\begin_layout Standard
Esistono alcune variabili d'ambiente utili per la personalizzazione della
 shell:
\end_layout

\begin_layout Itemize
$PS1 //contiene la forma in cui viene stampato il prompt della shell
\end_layout

\begin_layout Itemize
$PS2 //contiene la forma in cui viene stampato il secondo prompt della shell,
 quello comunemente associato al carattere 
\begin_inset Quotes eld
\end_inset

>
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
$SHELL //contiene il tipo di shell utilizzata
\end_layout

\begin_layout Standard
Vediamo alcuni utili shortcut della Bash shell ora:
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

Ctrl+r
\begin_inset Quotes erd
\end_inset

 //mi permette di ricercare una stringa all'interno della cronologia dei
 comandi, possiamo quindi scrivere la parola ricercata e schiacciare Ctrl+r
 per scorrere la cronologia relativa a quella parola
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

Ctrl+l
\begin_inset Quotes erd
\end_inset

 //esegue una pulizia dello schermo, è analogo a lanciare il comando 
\begin_inset Quotes eld
\end_inset

clear
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

Ctrl+x+Backspace
\begin_inset Quotes erd
\end_inset

 //per cancellare tutto quello che c'è prima del cursore
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

Ctrl+k
\begin_inset Quotes erd
\end_inset

 //cancella tutto quello che c'è davanti al cursore
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

Ctrl+a
\begin_inset Quotes erd
\end_inset

 //sposta il cursore all'inizio della linea
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

Ctrl+e
\begin_inset Quotes erd
\end_inset

 //sposta il cursore alla fine della linea
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

Ctrl+u
\begin_inset Quotes erd
\end_inset

 //cancella tutto quello che c'è prima del cursore, equivalente a 
\begin_inset Quotes eld
\end_inset

Ctrl+x+Backspace
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

Ctrl+p
\begin_inset Quotes erd
\end_inset

 //va indietro nella cronologia dei comandi
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

Ctrl+n
\begin_inset Quotes erd
\end_inset

 //va avanti nella cronologia dei comandi
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

Alt+f
\begin_inset Quotes erd
\end_inset

 //sposta il cursore in avanti di una parola
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

Alt+b
\begin_inset Quotes erd
\end_inset

 //sposta il cursore indietro di una parola
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

Ctrl+t
\begin_inset Quotes erd
\end_inset

 //per cambiare l'ordine di due caratteri, utilizzato ad esempio nel caso
 di errori di battitura
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

Alt+t
\begin_inset Quotes erd
\end_inset

 //swappa due stringhe sulla riga di comando
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

Ctrl+w
\begin_inset Quotes erd
\end_inset

 //elimina la stringa precedente
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

CTRL+x+e
\begin_inset Quotes erd
\end_inset

 //inserisce il comando corrente in un editor di testo, per fare in modo
 che sia più facile modificarlo, o salvarlo eventualmente, l'editor che
 viene utilizzato è quello impostato come editor di default dal sistema,
 solitamente nella variabile $EDITOR
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

space+ComandoDaEseguire
\begin_inset Quotes erd
\end_inset

 //inteso uno spazio prima del comando come: 
\begin_inset Quotes eld
\end_inset

 cd
\begin_inset Quotes erd
\end_inset

 al posto di 
\begin_inset Quotes eld
\end_inset

cd
\begin_inset Quotes erd
\end_inset

, questa modalità di stesura del comando permette di fare in modo che non
 sia salvato nella history dei comandi
\end_layout

\begin_layout Itemize
some command|xsel –clipboard //copia l'output del comando nella clipboard
 di sistema pronto per essere incollato, utile quanto ad esempio vogliamo
 utilizzare servizi di paste online
\end_layout

\begin_layout Itemize

\backslash
nomeComando //utile per fare in modo di utilizzare il comando senza alias,
 se ad esempio abbiamo un alias impostato su 
\begin_inset Quotes eld
\end_inset

ls
\begin_inset Quotes erd
\end_inset

 e vogliamo invece utilizzare 
\begin_inset Quotes eld
\end_inset

ls
\begin_inset Quotes erd
\end_inset

 nella sua versione originale senza alias, eseguiamo 
\begin_inset Quotes eld
\end_inset


\backslash
ls
\begin_inset Quotes erd
\end_inset

, comodo soprattutto quando applichiamo alias su 
\begin_inset Quotes eld
\end_inset

rm
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Subsection
Configurazione e Personalizzazione della Shell Bash
\end_layout

\begin_layout Standard
Possiamo cambiare la dimensione della history, andando ad inserire nel file
 
\begin_inset Quotes eld
\end_inset

.bashrc
\begin_inset Quotes erd
\end_inset

, cercando la stringa 
\begin_inset Quotes eld
\end_inset

HIST
\begin_inset Quotes erd
\end_inset

, possiamo cambiare le due varibili relative chiamate 
\begin_inset Quotes eld
\end_inset

HISTSIZE
\begin_inset Quotes erd
\end_inset

 ed 
\begin_inset Quotes eld
\end_inset

HISTFILESIZE
\begin_inset Quotes erd
\end_inset

, una volta applicate le modifiche possiamo o sloggare e riloggare oppure
 eseguire:
\end_layout

\begin_layout Itemize
source .bashrc
\end_layout

\begin_layout Subsection
Variabili d'ambiente
\end_layout

\begin_layout Standard
Le variabili d'ambiente ci permettono di memorizzare dati all'interno della
 nostra shell, quindi il loro valore può variare da utente ad utente.
 Ad esempio, nel caso volessimo salvare una variabile chiamata 
\begin_inset Quotes eld
\end_inset

TEST
\begin_inset Quotes erd
\end_inset

, che rappresenta l'indirizzo di un sito web, allora facciamo:
\end_layout

\begin_layout Itemize
export TEST='http://linuxacademy.tv' //inizializziamo la variabile d'ambiente
 di nome TEST con il valore 'http://linuxacademy.tv'
\end_layout

\begin_layout Itemize
export PATH=$PATH:/home/myExec //aggiunge un'altra directory alla variabile
 d'ambiente 
\begin_inset Quotes eld
\end_inset

PATH
\begin_inset Quotes erd
\end_inset

, utile quando vogliamo solo aggiungere stringhe e non riscriverle da zero
\end_layout

\begin_layout Standard
N.B.: Le variabili salvate in questo modo, vengono cancellate quando viene
 effettuato il logout, per salvarle indipendentemente dai logout, bisogna
 salvarle nel file di configurazione della shell d'utente che solitamente
 è (dipende dalla configurazione) ~/.profile, quindi andremo ad aggiungere
 in questo file, il comando export proprio come riportato negli esempi precedent
i.
\end_layout

\begin_layout Standard
Possiamo stampare il valore delle variabili d'ambiente attraverso il comando
 
\begin_inset Quotes eld
\end_inset

echo
\begin_inset Quotes erd
\end_inset

, ponendo il simbolo 
\begin_inset Quotes eld
\end_inset

$
\begin_inset Quotes erd
\end_inset

 davanti al nome della variabile d'ambiente:
\end_layout

\begin_layout Itemize
echo $TEST //stampa a video la stringa 'http://linuxacademy.tv'
\end_layout

\begin_layout Standard
per cancellare una variabile, possiamo usare il comando 
\begin_inset Quotes eld
\end_inset

unset
\begin_inset Quotes erd
\end_inset

, ad esempio nel caso volessimo cancellare la variabile TEST possiamo effettuare
:
\end_layout

\begin_layout Itemize
unset TEST //cancella la variabile d'ambiente chiamata TEST
\end_layout

\begin_layout Standard
possiamo visualizzare tutte le variabili d'ambiente attraverso diversi comandi:
\end_layout

\begin_layout Itemize
env //visualizza tutte le variabili d'ambiente, posso settare permanenti
 le variabili d'ambiente o nel file .bashrc o nei file in /etc/env.d/
\end_layout

\begin_layout Itemize
set //visualizza tutte le variabili d'ambiente, anche se il comando set
 può essere usato anche per manipolare le opzioni di shell (vedi sezione
 successiva)
\end_layout

\begin_layout Itemize
printenv //visualizza tutte le variabili d'ambiente
\end_layout

\begin_layout Standard
Vediamo ora alcune variabili d'ambiente famose:
\end_layout

\begin_layout Itemize
$HOSTNAME //contiene il nome del nostro host
\end_layout

\begin_layout Itemize
$HOME //la home del nostro utente
\end_layout

\begin_layout Itemize
$PWD //la directory corrente
\end_layout

\begin_layout Itemize
$IFS //contiene il carattere utilizzato come separatore, rappresenta come
 la shell separa i parametri e i valori in genere, di default è assegnato
 al carattere 
\begin_inset Quotes eld
\end_inset

spazio
\begin_inset Quotes erd
\end_inset

 (space)
\end_layout

\begin_layout Itemize
$PS1 //il prompt visualizzato dalla shell
\end_layout

\begin_layout Itemize
$PS2 //il secondo prompt visualizzato dalla shell, quello comumente indicato
 con 
\begin_inset Quotes eld
\end_inset

>
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
$$ //il pid della shell attuale, in uno script è il PID dello script
\end_layout

\begin_layout Itemize
$USER //il nome del nostro utente
\end_layout

\begin_layout Itemize
$SHELL //il tipo di shell utiizzata
\end_layout

\begin_layout Itemize
$CDPATH //è una variabile d'ambiente che può contenere directory aggiuntive
 che vengono considerate sempre nel momento in cui eseguiamo 
\begin_inset Quotes eld
\end_inset

cd
\begin_inset Quotes erd
\end_inset

, ad esempio se accediamo spesso alla directory 
\begin_inset Quotes eld
\end_inset

/etc
\begin_inset Quotes erd
\end_inset

 in quanto nella directory 
\begin_inset Quotes eld
\end_inset

/etc
\begin_inset Quotes erd
\end_inset

 sono contenute le directory 
\begin_inset Quotes eld
\end_inset

/etc/x
\begin_inset Quotes erd
\end_inset

 ed 
\begin_inset Quotes eld
\end_inset

/etc/y
\begin_inset Quotes erd
\end_inset

 che sono di nostro interesse, allora possiamo eseguire 
\begin_inset Quotes eld
\end_inset

export CDPATH=/etc
\begin_inset Quotes erd
\end_inset

 a questo punto in qualasiasi directory ci dovessimo trovare, possiamo eseguire
 semplicemente un 
\begin_inset Quotes eld
\end_inset

cd x
\begin_inset Quotes erd
\end_inset

 per accedere alla directory /etc/x ed 
\begin_inset Quotes eld
\end_inset

cd y
\begin_inset Quotes erd
\end_inset

 per accedere alla directory 
\begin_inset Quotes eld
\end_inset

/etc/y
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
$LD_LIBRARY_PATH //il percorso delle librerie
\end_layout

\begin_layout Itemize
$DISPLAY //il display attuale in cui vengono visualizzate le finestre grafiche
\end_layout

\begin_layout Itemize
$EDITOR //il tipo di editor che viene aperto in automatico quando richiesto
\end_layout

\begin_layout Itemize
$PATH //il percorso da dove vengono presi gli eseguibili per essere lanciati
 come comandi
\end_layout

\begin_layout Itemize
$MAIL //il percorso dove vengono salvate le mail
\end_layout

\begin_layout Itemize
$LANG //la lingua utilizzata dall'utente
\end_layout

\begin_layout Itemize
$# //(utile negli script) il numero di parametri passati ad uno script
\end_layout

\begin_layout Itemize
$? //stampa il valore di ritorno dell'ultimo script/comando lanciato, è
 da ricordare che un valore uguale a 0 significa 
\begin_inset Quotes eld
\end_inset

esecuzione corretta
\begin_inset Quotes erd
\end_inset

, un valore diverso da zero, indica un errore
\end_layout

\begin_layout Itemize
$0 //(utile negli script) nome dello script
\end_layout

\begin_layout Itemize
$@ //(utile negli script) una variabile unica contenente la lista di parametri
 passati allo script, usa come separatore lo 
\begin_inset Quotes eld
\end_inset

spazio
\begin_inset Quotes erd
\end_inset

, questo è preferibile rispetto alla versione 
\begin_inset Quotes eld
\end_inset

$*
\begin_inset Quotes erd
\end_inset

, in quanto questa dipende da IFS
\end_layout

\begin_layout Itemize
$* //(utile negli script) una variabile unica contenente la lista di parametri
 passati allo script, usa come separatore il carattere nella variabile 
\begin_inset Quotes eld
\end_inset

IFS
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
$1, $2, ...
 //(utile negli script), è il parametro passato, ad esempio $1, è il primo
 parametro passato, $2 il secondo parametro passato e così via
\end_layout

\begin_layout Itemize
$- //visualizza una stringa rappresentante i flag opzione della shell attualment
e attivi (quelli che impostati con 
\begin_inset Quotes eld
\end_inset

set
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Standard
Dato un processo con relativo PID (visto ad esempio con top o ps) possiamo
 visualizzare le variabili d'ambiente che sta utilizzando andando a visualizzare
 il file:
\end_layout

\begin_layout Itemize
cat /proc/5464/environ //visualizza le variabili d'ambiente in uso del processo
 col PID 5464
\end_layout

\begin_layout Standard
N.B.: C'è una differenza tra 
\begin_inset Quotes eld
\end_inset

environment variables
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

shell variables
\begin_inset Quotes erd
\end_inset

, in quanto le environment variables sono utilizzate dall'intero sistema
 e da alcuni programmi per la loro esecuzione, come ad esempio LANG, EDITOR,
 ecc..., mentre le 
\begin_inset Quotes eld
\end_inset

shell variable
\begin_inset Quotes erd
\end_inset

 non sono possono essere usate dai programmi esterni quindi valgono solo
 per la shell.
\end_layout

\begin_layout Paragraph
Personalizzare il prompt dei comandi
\end_layout

\begin_layout Standard
Per personalizzare il prompt dei comandi, dobbiamo agire sulla variabile
 d'ambiente PS1, vediamo alcuni esempi:
\end_layout

\begin_layout Itemize
export PS1=
\begin_inset Quotes erd
\end_inset

miaStringa
\begin_inset Quotes erd
\end_inset

 //mostra come prompt dei comandi 
\begin_inset Quotes eld
\end_inset

miaStringa
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
export PS1=
\begin_inset Quotes erd
\end_inset

miaStringa 
\backslash
u@
\backslash
h
\begin_inset Quotes erd
\end_inset

 //mostra come prompt dei comandi 
\begin_inset Quotes eld
\end_inset

miaStringa nomeUtente@hostname
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
come possiamo notare, esistono dei codici come 
\begin_inset Quotes eld
\end_inset


\backslash
u
\begin_inset Quotes erd
\end_inset

 o 
\begin_inset Quotes eld
\end_inset


\backslash
h
\begin_inset Quotes erd
\end_inset

 che indicano variabili che possiamo mostrare nel prompt, elenchiamo alcuni
 esempi:
\end_layout

\begin_layout Itemize

\backslash
a : an ASCII bell character (07)
\end_layout

\begin_layout Itemize

\backslash
d : the date in "Weekday Month Date" format (e.g., "Tue May 26") 
\end_layout

\begin_layout Itemize

\backslash
D{format} : the format is passed to strftime(3) and the result is inserted
 into the prompt string; an empty format results in a locale-specific time
 representation.
 The braces are required 
\end_layout

\begin_layout Itemize

\backslash
e : an ASCII escape character (033) 
\end_layout

\begin_layout Itemize

\backslash
h : the hostname up to the first '.'
\end_layout

\begin_layout Itemize

\backslash
H : the hostname 
\end_layout

\begin_layout Itemize

\backslash
j : the number of jobs currently managed by the shell
\end_layout

\begin_layout Itemize

\backslash
l : the basename of the shell?s terminal device name 
\end_layout

\begin_layout Itemize

\backslash
n : newline 
\end_layout

\begin_layout Itemize

\backslash
r : carriage return 
\end_layout

\begin_layout Itemize

\backslash
s : the name of the shell, the basename of $0 (the portion following the
 final slash) 
\end_layout

\begin_layout Itemize

\backslash
t : the current time in 24-hour HH:MM:SS format 
\end_layout

\begin_layout Itemize

\backslash
T : the current time in 12-hour HH:MM:SS format 
\end_layout

\begin_layout Itemize

\backslash
@ : the current time in 12-hour am/pm format
\end_layout

\begin_layout Itemize

\backslash
A : the current time in 24-hour HH:MM format 
\end_layout

\begin_layout Itemize

\backslash
u : the username of the current user 
\end_layout

\begin_layout Itemize

\backslash
v : the version of bash (e.g., 2.00) 
\end_layout

\begin_layout Itemize

\backslash
V : the release of bash, version + patch level (e.g., 2.00.0) 
\end_layout

\begin_layout Itemize

\backslash
w : the current working directory, with $HOME abbreviated with a tilde 
\end_layout

\begin_layout Itemize

\backslash
W : the basename of the current working directory, with $HOME abbreviated
 with a tilde 
\end_layout

\begin_layout Itemize

\backslash
! : the history number of this command 
\end_layout

\begin_layout Itemize

\backslash
# : the command number of this command 
\end_layout

\begin_layout Itemize

\backslash
$ : if the effective UID is 0, a #, otherwise a $ 
\end_layout

\begin_layout Itemize

\backslash
nnn : the character corresponding to the octal number nnn 
\end_layout

\begin_layout Itemize

\backslash

\backslash
 : a backslash 
\end_layout

\begin_layout Itemize

\backslash
[ : begin a sequence of non-printing characters, which could be used to
 embed a terminal control sequence into the prompt 
\end_layout

\begin_layout Itemize

\backslash
] : end a sequence of non-printing characters 
\end_layout

\begin_layout Itemize

\backslash
u //nomeutente
\end_layout

\begin_layout Itemize

\backslash
h //hostname
\end_layout

\begin_layout Itemize

\backslash
w //directory corrente
\end_layout

\begin_layout Itemize

\backslash
@ //ora corrente con indicazione AM/PM
\end_layout

\begin_layout Itemize

\backslash
t //ora corrente con indicazione dei secondi
\end_layout

\begin_layout Itemize

\backslash
j //numero di job in esecuzione
\end_layout

\begin_layout Itemize

\backslash
d //data corrente
\end_layout

\begin_layout Itemize

\backslash
$ //mostra il simbolo 
\begin_inset Quotes eld
\end_inset

$
\begin_inset Quotes erd
\end_inset

 se l'utente corrente non è root mentre in caso contrario mostra il simbolo
 
\begin_inset Quotes eld
\end_inset

#
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Per poter modificare i colori o gli stili del testo invece esistono dei
 codici, ad esempio il verde non grassetto corrisponde al codice 
\begin_inset Quotes eld
\end_inset

0;32
\begin_inset Quotes erd
\end_inset

, però l'inizio e la fine dello stile/colore deve essere delimitata dalle
 sequenze:
\end_layout

\begin_layout Itemize

\backslash
[
\backslash
e[codiceColorem
\backslash
] //per iniziare con codiceColore
\end_layout

\begin_layout Itemize

\backslash
[
\backslash
e[m
\backslash
] //per terminare con l'ultimo codice con cui abbiamo iniziato
\end_layout

\begin_layout Standard
ad esempio, nel caso volessimo avere un prompt con il nome utente e l'hostname
 con carattere di separazione 
\begin_inset Quotes eld
\end_inset

@
\begin_inset Quotes erd
\end_inset

 tutto di colore 
\begin_inset Quotes eld
\end_inset

0;32
\begin_inset Quotes erd
\end_inset

 seguiti dalla directory corrente con stile/colore 
\begin_inset Quotes eld
\end_inset

0;31
\begin_inset Quotes erd
\end_inset

 allora facciamo:
\end_layout

\begin_layout Itemize
export PS1='
\backslash
[
\backslash
e[0;32m
\backslash
]
\backslash
u@
\backslash
h
\backslash
[
\backslash
e[m
\backslash
]
\backslash
[
\backslash
e[0;31m
\backslash
]
\backslash
w
\backslash
[
\backslash
e[m
\backslash
]'
\end_layout

\begin_layout Standard
Per una lista di tutti gli stili/colori disponibili, è consigliato consultare
 
\begin_inset CommandInset href
LatexCommand href
name "Guida ai Colori del Prompt di Shell"
target "https://wiki.archlinux.org/index.php/Color_Bash_Prompt"

\end_inset

.
\end_layout

\begin_layout Standard
Vediamo un altro esempio:
\end_layout

\begin_layout Itemize
PS1="$HC$FYEL[ $FBLE${debian_chroot:+($debian_chroot)}
\backslash
u$FYEL: $FBLE
\backslash
w $FYEL]
\backslash

\backslash
$ $RS" PS2="$HC$FYEL&gt; $RS"
\end_layout

\begin_layout Standard
o ancora
\end_layout

\begin_layout Itemize
PS1="
\backslash
[$(tput bold)
\backslash
]
\backslash
[$(tput setaf 6)
\backslash
]
\backslash
t 
\backslash
[$(tput setaf 2)
\backslash
][
\backslash
[$(tput setaf 3)
\backslash
]
\backslash
u
\backslash
[$(tput setaf 1)
\backslash
]@
\backslash
[$(tput setaf 3)
\backslash
]
\backslash
h 
\backslash
[$(tput setaf 6)
\backslash
]
\backslash
W
\backslash
[$(tput setaf 2)
\backslash
]]
\backslash
[$(tput setaf 4)
\backslash
]
\backslash

\backslash
$ 
\backslash
[$(tput sgr0)
\backslash
]"
\end_layout

\begin_layout Standard
online esistono diversi Bash PS1 generator per semplificare la procedura
 di customizzazione.
\end_layout

\begin_layout Subsubsection
Opzioni di Shell
\end_layout

\begin_layout Standard
Le 
\begin_inset Quotes eld
\end_inset

opzioni di shell
\begin_inset Quotes erd
\end_inset

, sono impostazioni che possono cambiare il comportamento delle shell (e
 degli script di shell) in determinate situazioni o per determinate operazioni.
 Il comando 
\begin_inset Quotes eld
\end_inset

set
\begin_inset Quotes erd
\end_inset

 viene utilizzato allo scopo di impostare le opzioni di shell.
 La sintassi del comando è:
\end_layout

\begin_layout Itemize
set -o nome-opzione 
\end_layout

\begin_layout Standard
o in forma abbreviata:
\end_layout

\begin_layout Itemize
set -opzione-abbreviata
\end_layout

\begin_layout Standard
Per disabilitare un'opzione invece si usa la sintassi:
\end_layout

\begin_layout Itemize
set +o nome-opzione //disabilita l'opzione menzionata
\end_layout

\begin_layout Standard
per vedere una lista delle possibilità eseguiamo:
\end_layout

\begin_layout Itemize
set -o //visualizza la lista delle possibili configurazioni attuabili
\end_layout

\begin_layout Standard
Vediamo alcuni esempi:
\end_layout

\begin_layout Itemize
set -o noclobber //in questo modo impostiamo l'opzione noclobber, che non
 permette sovrascritture da parte del terminale
\end_layout

\begin_layout Itemize
set +o noclobber //viene disabilitata l'opzione noclobber, quindi ridiventa
 possibile effettuare sovrascritture
\end_layout

\begin_layout Itemize
set -o vi //imposta come shortcut della shell (bash zsh) i comandi di vi,
 ad esempio per cancellare la riga di comando useremo 
\begin_inset Quotes eld
\end_inset

dd
\begin_inset Quotes erd
\end_inset

 e per navigare la history 
\begin_inset Quotes eld
\end_inset

Esc+(kjhl)
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
set -o emacs //imposta come shortcut della shell (bash o zsh) i comandi
 di emacs, questa è abilitata di default
\end_layout

\begin_layout Standard
Una guida più dettagliata alle opzioni di shell è fornita al link 
\begin_inset CommandInset href
LatexCommand href
name "Guida al comando Set e alle Opzioni di Shell"
target "http://www.tldp.org/LDP/abs/html/options.html"

\end_inset


\end_layout

\begin_layout Standard
Vediamo un esempio di file 
\begin_inset Quotes eld
\end_inset

~/.bashrc
\begin_inset Quotes erd
\end_inset

 che raggruppa varie comuni e utili configurazioni per la bash:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

# Store 5000 commands in history buffer 
\end_layout

\begin_layout Plain Layout

export HISTSIZE=5000
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Store 5000 commands in history FILE  
\end_layout

\begin_layout Plain Layout

export HISTFILESIZE=5000
\end_layout

\begin_layout Plain Layout

     
\end_layout

\begin_layout Plain Layout

# Avoid duplicates in hisotry  
\end_layout

\begin_layout Plain Layout

export HISTIGNORE='&:[ ]*'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Use less command as a pager 
\end_layout

\begin_layout Plain Layout

export PAGER=less
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Set vim as default text editor 
\end_layout

\begin_layout Plain Layout

export EDITOR=vim 
\end_layout

\begin_layout Plain Layout

export VISUAL=vim 
\end_layout

\begin_layout Plain Layout

export SVN_EDITOR="$VISUAL"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Oracle database specific
\end_layout

\begin_layout Plain Layout

export ORACLE_HOME=/usr/lib/oracle/xe/app/oracle/product/10.2.0/server 
\end_layout

\begin_layout Plain Layout

export ORACLE_SID=XE export NLS_LANG=$($ORACLE_HOME/bin/nls_lang.sh)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Set JAVA_HOME  
\end_layout

\begin_layout Plain Layout

export JAVA_HOME=/usr/lib/jvm/java-6-sun/jre
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Add ORACLE, JAVA and ~/bin bin to PATH 
\end_layout

\begin_layout Plain Layout

export PATH=$PATH:$ORACLE_HOME/bin:$HOME/bin:$JAVA_HOME/bin
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Secure SSH login stuff using keychain 
\end_layout

\begin_layout Plain Layout

# No need to input password again ever 
\end_layout

\begin_layout Plain Layout

/usr/bin/keychain $HOME/.ssh/id_dsa 
\end_layout

\begin_layout Plain Layout

source $HOME/.keychain/$HOSTNAME-sh
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Turn on Bash command completion 
\end_layout

\begin_layout Plain Layout

source /etc/bash_completion
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# MS-DOS / XP cmd like stuff 
\end_layout

\begin_layout Plain Layout

alias edit=$VISUAL 
\end_layout

\begin_layout Plain Layout

alias copy='cp' 
\end_layout

\begin_layout Plain Layout

alias cls='clear' 
\end_layout

\begin_layout Plain Layout

alias del='rm' 
\end_layout

\begin_layout Plain Layout

alias dir='ls' 
\end_layout

\begin_layout Plain Layout

alias md='mkdir' 
\end_layout

\begin_layout Plain Layout

alias move='mv' 
\end_layout

\begin_layout Plain Layout

alias rd='rmdir' 
\end_layout

\begin_layout Plain Layout

alias ren='mv' 
\end_layout

\begin_layout Plain Layout

alias ipconfig='ifconfig'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Other Linux stuff alias 
\end_layout

\begin_layout Plain Layout

bc='bc -l' 
\end_layout

\begin_layout Plain Layout

alias diff='diff -u'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# get updates from RHN 
\end_layout

\begin_layout Plain Layout

alias update='yum -y update'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# set eth1 as default 
\end_layout

\begin_layout Plain Layout

alias dnstop='dnstop -l 5  eth1' 
\end_layout

\begin_layout Plain Layout

alias vnstat='vnstat -i eth1'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# force colorful grep output 
\end_layout

\begin_layout Plain Layout

alias grep='grep --color'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# ls stuff 
\end_layout

\begin_layout Plain Layout

alias l.='ls -d .* --color=tty' 
\end_layout

\begin_layout Plain Layout

alias ll='ls -l --color=tty' 
\end_layout

\begin_layout Plain Layout

alias ls='ls --color=tty'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
vediamo un altro esempio con una bella carrellata di alias utili:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

alias ls='ls -c --color=auto' 
\end_layout

\begin_layout Plain Layout

alias la='ls -ac --color=auto' 
\end_layout

\begin_layout Plain Layout

alias ll='ls -lah --color=auto' 
\end_layout

\begin_layout Plain Layout

alias lsd='ls -d */' 
\end_layout

\begin_layout Plain Layout

alias lsz='ls -AZ --color=auto'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# with grep 
\end_layout

\begin_layout Plain Layout

alias lsg='ls --color=auto | g' 
\end_layout

\begin_layout Plain Layout

alias lag='ls -a --color=auto | g' 
\end_layout

\begin_layout Plain Layout

alias llg='ls -lah --color=auto | g'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Colorize grep 
\end_layout

\begin_layout Plain Layout

alias g="grep --color=always" 
\end_layout

\begin_layout Plain Layout

alias gi="grep -i --color=always"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Confirm 
\end_layout

\begin_layout Plain Layout

alias mv='mv -i' 
\end_layout

\begin_layout Plain Layout

alias cp='cp -i' 
\end_layout

\begin_layout Plain Layout

alias rm='rm -i'
\end_layout

\begin_layout Plain Layout

# Override -f 
\end_layout

\begin_layout Plain Layout

alias rmf='rm -Rfv' 
\end_layout

\begin_layout Plain Layout

alias cpf='
\backslash
cp -v' 
\end_layout

\begin_layout Plain Layout

alias mvf='
\backslash
mv -v' 
\end_layout

\begin_layout Plain Layout

alias rmf='rm -Rfv'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# No clobber 
\end_layout

\begin_layout Plain Layout

set -o noclobber 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Override >|
\end_layout

\begin_layout Plain Layout

# Sysadmin 
\end_layout

\begin_layout Plain Layout

alias psa='ps auxf' alias 
\end_layout

\begin_layout Plain Layout

psg='ps aux | grep' 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#requires an argument 
\end_layout

\begin_layout Plain Layout

#alias date='date "+%A %B %d, %Y %l:%M %p %Z"' 
\end_layout

\begin_layout Plain Layout

alias date='echo -ne "${LIGHTBLUE}";date "+%A %B %d, %Y %l:%M %p %Z"' 
\end_layout

\begin_layout Plain Layout

alias cal='echo -e "${CYAN}"; cal""' 
\end_layout

\begin_layout Plain Layout

alias hist='history | g $1' 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#Requires one input 
\end_layout

\begin_layout Plain Layout

alias du='du -sh' 
\end_layout

\begin_layout Plain Layout

alias dul='
\backslash
du -h | less' 
\end_layout

\begin_layout Plain Layout

alias df='df -h'
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Zsh
\end_layout

\begin_layout Standard
Questa è una shell molto avanzata, si consiglia l'installazione dei powerline
 fonts e di un qualche plugin manager come 
\begin_inset Quotes eld
\end_inset

oh my zsh
\begin_inset Quotes erd
\end_inset

, alcuni comandi utili qui sono:
\end_layout

\begin_layout Itemize
dirs -v //visualizza le ultime directory visitate ad ognina viene assegnato
 un numero e possiamo navigare su quella con 
\begin_inset Quotes eld
\end_inset

cd -<numero>
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
ad esempio:
\end_layout

\begin_layout Itemize
cd -2 //va alla directory indicata col numero 
\begin_inset Quotes eld
\end_inset

2
\begin_inset Quotes erd
\end_inset

 quando abbiamo eseguito 
\begin_inset Quotes eld
\end_inset

dirs -v
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Subsection
Funzioni d'Ambiente
\end_layout

\begin_layout Standard
Come per le variabili possiamo anche creare 
\begin_inset Quotes eld
\end_inset

comandi
\begin_inset Quotes erd
\end_inset

 (cioè funzioni) che saranno accessibili solo all'utente, questo è possibile
 andando a salvare nel file 
\begin_inset Quotes eld
\end_inset

.bashrc
\begin_inset Quotes erd
\end_inset

 o 
\begin_inset Quotes eld
\end_inset

.profile
\begin_inset Quotes erd
\end_inset

 a differenza dei file che vengono eseguiti all'avvio (ergo dipende molto
 dal setup dell'ambiente).
 Vediamo un esempio di funzioni inserite all'interno del file .bashrc:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

# Set Proxy 
\end_layout

\begin_layout Plain Layout

function nomecomandopersonaleuno() {     
\end_layout

\begin_layout Plain Layout

	export {http,https,ftp}_proxy="http://proxy-server:port" 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Unset Proxy 
\end_layout

\begin_layout Plain Layout

function nomecomandopersonaledue() {     
\end_layout

\begin_layout Plain Layout

unset {http,https,ftp}_proxy 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
ora al prossimo login (oppure dopo aver rieseguito il file .bashrc con un
 source o avviandolo) all'utente basterà digitare da riga di comando:
\end_layout

\begin_layout Itemize
nomecomandopersonaleuno //eseguirà le istruzioni contenute all'interno della
 funzione nomecomandopersonaleuno
\end_layout

\begin_layout Standard
oppure
\end_layout

\begin_layout Itemize
nomecomandopersonaledue //eseguirà le istruzioni contenute all'interno della
 funzione nomecomandopersonaledue
\end_layout

\begin_layout Subsection
Memorizzare Comandi e Riprodurli
\end_layout

\begin_layout Standard
Possiamo usare l'utility 
\begin_inset Quotes eld
\end_inset

script
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

replayscript
\begin_inset Quotes erd
\end_inset

, sia per scopi didattici che per scopi di utilità, è un modo per registrare
 le attività da terminale, si esegue in questo modo:
\end_layout

\begin_layout Itemize
script –timing=time.txt script.log //comincia una sessione di registrazione,
 e termina o col comando exit o con 
\begin_inset Quotes eld
\end_inset

Ctrl+d
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
scriptreplay –timing=time.txt script.log //riproduce i comandi registrati
 nello script.log, ma non come uno script, in quanto mi riporta l'esatto
 output
\end_layout

\begin_layout Subsection
Terminal Multiplexers
\end_layout

\begin_layout Standard
I Terminal Multiplexer permettono di lavorare in ambienti con più sessioni
 di terminale all'interno dello stesso terminale, è l'analogo dei desktop
 virtuali per le GUI fatto per le TUI.
 I due più famosi Terminal Multiplexer sono:
\end_layout

\begin_layout Itemize
tmux
\end_layout

\begin_layout Itemize
screen
\end_layout

\begin_layout Itemize
terminator (GUI)
\end_layout

\begin_layout Subsubsection
Tmux
\end_layout

\begin_layout Standard
Tmux è organizzato in sessioni, ogni sessione è costituita da una o più
 windows (finestre) ed ogni finestra può essere costituita da uno o più
 panes (riquadri), vediamo alcuni comandi comuni:
\end_layout

\begin_layout Itemize
tmux //avvia tmux
\end_layout

\begin_layout Standard
ogni comando di tmux comincia col prefix (prefisso) 
\begin_inset Quotes eld
\end_inset

Ctrl+b
\begin_inset Quotes erd
\end_inset

, quindi ogni comando che segue dovrà prima essere preceduto dalla combinazione
\begin_inset Quotes erd
\end_inset

Ctrl+b
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Itemize
c //crea una nuova window
\end_layout

\begin_layout Itemize
n //va alla window successiva
\end_layout

\begin_layout Itemize
p //va alla window precedente
\end_layout

\begin_layout Itemize
& //killa la window corrente
\end_layout

\begin_layout Itemize
, //rinomina la window corrente
\end_layout

\begin_layout Itemize
w //mostra la lista delle window all'interno della sessione corrente
\end_layout

\begin_layout Itemize
0-9 //va alla finestra identificata dall'id specificato
\end_layout

\begin_layout Standard
per quanto riguarda i pane, abbiamo a disposizione:
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

 //splitta in modo orizzontale la window in due pane
\end_layout

\begin_layout Itemize
% //splitta in modo verticale la window in due pane
\end_layout

\begin_layout Itemize
o //switcha tra un pane e l'altro
\end_layout

\begin_layout Itemize
tasti direzionali //ridimensiona un pane
\end_layout

\begin_layout Itemize
spacebar //cambia il layout tra alcuni predefiniti
\end_layout

\begin_layout Itemize
z //mette un pane in fullscreen, dobbiamo ripetere lo shortcut per rimetterlo
 a posto
\end_layout

\begin_layout Itemize
{,} //spostiamo il pane a destra o a sinistra
\end_layout

\begin_layout Itemize
; //va all'ultimo pane attivo
\end_layout

\begin_layout Itemize
! //converte il pane in una finestra separata
\end_layout

\begin_layout Itemize
x //chiude il pane
\end_layout

\begin_layout Standard
Inoltre sono disponibili molti comandi, possiamo accedere alla modalità
 comandi con lo shortcut 
\begin_inset Quotes eld
\end_inset

Ctrl+b+:
\begin_inset Quotes erd
\end_inset

, da qui alcuni comandi utili sono:
\end_layout

\begin_layout Itemize
join-pane -s 1 //joina la window 1 come pane alla window corrente
\end_layout

\begin_layout Itemize
join-pane -b -s 5 -t 2 //joins window 5 to the left of pane 2 in the current
 window
\end_layout

\begin_layout Itemize
join-pane -s 1 -t 0 //joina la finestra uno come pane alla finestra corrente
\end_layout

\begin_layout Itemize
swap-window -s 2 -t 1 //swappa la finestra 2 con la numero 1
\end_layout

\begin_layout Standard
Guardare ovviamente il man per altre opzioni
\end_layout

\begin_layout Subsubsection
Screen
\end_layout

\begin_layout Standard
Possiamo avviarlo eseguendo:
\end_layout

\begin_layout Itemize
screen //si avvia una sessione di screen, che possiamo terminare (chiudere
 del tutto) con 
\begin_inset Quotes eld
\end_inset

Ctrl+d
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
screen -mS nomeSessione //si avvia una sessione di screen, con il nome menzionat
o nel comando
\end_layout

\begin_layout Standard
Altri comandi utili sono:
\end_layout

\begin_layout Itemize
screen -ls //elenca le varie sessioni disponibili, possiamo rimuovere una
 sessione attraverso il comando 
\begin_inset Quotes eld
\end_inset

kill
\begin_inset Quotes erd
\end_inset

 seguito dal numero del processo indicato quando eseguiamo 
\begin_inset Quotes eld
\end_inset

screen -ls
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
screen -r sessionID //ripristina la sessione menzionata
\end_layout

\begin_layout Standard
possiamo fare il detach di una sessione con:
\end_layout

\begin_layout Itemize
Ctrl+a+d //detacha la sessione, possiamo visualizzarla con 
\begin_inset Quotes eld
\end_inset

screen -ls
\begin_inset Quotes erd
\end_inset

 o ripristinare con 
\begin_inset Quotes eld
\end_inset

screen -r nomeSessione
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Vediamo altri comandi:
\end_layout

\begin_layout Itemize
Ctrl+a, 
\begin_inset Quotes eld
\end_inset

 //switcha finestra
\end_layout

\begin_layout Itemize
Ctrl+a,c //crea una nuova finestra
\end_layout

\begin_layout Itemize
Ctrl+a,A //rinomina la finestra corrente
\end_layout

\begin_layout Itemize
Ctrl+aa //switcha tra le ultime due finestre
\end_layout

\begin_layout Itemize
Ctrl+a,k //killa una finestra
\end_layout

\begin_layout Itemize
Ctrl+a, S //split window horizontally
\end_layout

\begin_layout Itemize
Ctrl+a, | //split window vertically
\end_layout

\begin_layout Itemize
Ctrl+a, Tab //switcha tra una finestra all'altra
\end_layout

\begin_layout Itemize
Ctrl+a, :resize [rows,cols] //ridimensiona la finestra
\end_layout

\begin_layout Itemize
Ctrl+a, :remove //rimuove la finestra
\end_layout

\begin_layout Subsubsection
Terminator
\end_layout

\begin_layout Standard
Vediamo alcuni comandi di terminator:
\end_layout

\begin_layout Itemize
terminator //avvia l'applicazione
\end_layout

\begin_layout Itemize
Ctrl+Shit+e //split verticale
\end_layout

\begin_layout Itemize
Ctrl+Shift+o //split orizzontale
\end_layout

\begin_layout Itemize
Ctrl+Shift+z //massimizza un terminale
\end_layout

\begin_layout Itemize
Ctrl+d //chiude un terminale
\end_layout

\begin_layout Itemize
Alt+Left/Up/Right/Down //switcha tra le finestre
\end_layout

\begin_layout Itemize
Ctrl+Shift+Left/Up/Right/Down //resize del terminale, quest'operazione è
 possibile anche dalla GUI attraverso il mouse
\end_layout

\begin_layout Section
Lavorare con File di Testo
\end_layout

\begin_layout Standard
I file di testo e la loro gestione ricopre un ruolo importante nei sistemi
 GNU/Linux, in quanto qualsiasi cosa è alla fine vista come un file di testo,
 i più comuni editor di testo sono 
\begin_inset Quotes eld
\end_inset

vi
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

nano
\begin_inset Quotes erd
\end_inset

, anche se i standard 
\begin_inset Quotes eld
\end_inset

de facto
\begin_inset Quotes erd
\end_inset

 per i power users sono 
\begin_inset Quotes eld
\end_inset

vi
\begin_inset Quotes erd
\end_inset

 ed 
\begin_inset Quotes eld
\end_inset

emacs
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsection
Vi (Editor di Testo)
\end_layout

\begin_layout Standard
Vi è un editor di testo molto famoso, posso aprire un file di testo con
 vi eseguendo:
\end_layout

\begin_layout Itemize
vi nomefile //apre il file nomefile con vi
\end_layout

\begin_layout Standard
Vi funziona secondo tre modalità operative e diventa un editor di testo
 molto efficiente una volta imparati i comandi più importanti:
\end_layout

\begin_layout Enumerate
Modalità 
\begin_inset Quotes eld
\end_inset

comandi
\begin_inset Quotes erd
\end_inset

 (Accessibile attraverso il tasto 
\begin_inset Quotes eld
\end_inset

Esc
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Enumerate
Modalità 
\begin_inset Quotes eld
\end_inset

colon
\begin_inset Quotes erd
\end_inset

 o 
\begin_inset Quotes eld
\end_inset

ex-mode
\begin_inset Quotes erd
\end_inset

 (Accessibile attraverso il tasto 
\begin_inset Quotes eld
\end_inset

:
\begin_inset Quotes erd
\end_inset

): utilizzata per manipolare il file
\end_layout

\begin_layout Enumerate
Modalità 
\begin_inset Quotes eld
\end_inset

inserimento
\begin_inset Quotes erd
\end_inset

 (Accessibile attraverso il comando 
\begin_inset Quotes eld
\end_inset

i
\begin_inset Quotes erd
\end_inset

): utilizzata per editare/inserire testo all'interno del file
\end_layout

\begin_layout Itemize
Per uscire premere :q
\end_layout

\begin_layout Itemize
Per salvare premre :w
\end_layout

\begin_layout Itemize
Per salvare e uscire :wq
\end_layout

\begin_layout Itemize
Per uscire da tutte le finestre :qa
\end_layout

\begin_layout Itemize
Per copiare una riga si entra in command mode e si preme 
\begin_inset Quotes eld
\end_inset

yy
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Per incollare schiaccio 
\begin_inset Quotes eld
\end_inset

p
\begin_inset Quotes erd
\end_inset

 oppure 
\begin_inset Quotes eld
\end_inset

P
\begin_inset Quotes erd
\end_inset

 se voglio effettuare l'incollatura sulla riga soprastante
\end_layout

\begin_layout Itemize
Per andare alla riga quattro eseguo 
\begin_inset Quotes eld
\end_inset

:4
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Per avere a schermo l'output di altri comandi eseguo 
\begin_inset Quotes eld
\end_inset

:r! nomeComando
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Per copiare 4 righe dal testo faccio 
\begin_inset Quotes eld
\end_inset

4yy
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Per tagliare una riga uso 
\begin_inset Quotes eld
\end_inset

dd
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
:d //cancella una riga senza copiarla, esegue quindi 
\begin_inset Quotes eld
\end_inset

cancella
\begin_inset Quotes erd
\end_inset

 e non taglia
\end_layout

\begin_layout Itemize
Per cancellare 10 righe successive uso 
\begin_inset Quotes eld
\end_inset

10dd
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Per cancellare 10 righe precedenti uso 
\begin_inset Quotes eld
\end_inset

10dk
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Per muovermi alla parola successiva 
\begin_inset Quotes eld
\end_inset

w
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Per muovermi alla parola successiva 
\begin_inset Quotes eld
\end_inset

b
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Per muovermi fino a prima dell'occorrenza del carattere 'f' eseguo 
\begin_inset Quotes eld
\end_inset

tf
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Per muovermi fino all'occorrenza del carattere 'c' eseguo 
\begin_inset Quotes eld
\end_inset

fc
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Per cancellare all'interno di parentesi quadre [] o altre delimitatori eseguo
 
\begin_inset Quotes eld
\end_inset

ci[
\begin_inset Quotes eld
\end_inset


\end_layout

\begin_layout Itemize
Per cancellare all'interno di parentesi quadre [] ed inoltre anche le parentesi
 quadre eseguo 
\begin_inset Quotes eld
\end_inset

ca[
\begin_inset Quotes eld
\end_inset


\end_layout

\begin_layout Itemize
Con 
\begin_inset Quotes eld
\end_inset

%
\begin_inset Quotes erd
\end_inset

 vado alla fine dell'altro delimitatore corrispondente, se sono posizionato
 su {, allora andrò su } e viceversa
\end_layout

\begin_layout Itemize
Con 
\begin_inset Quotes eld
\end_inset

Shift+A
\begin_inset Quotes erd
\end_inset

 vado a fine riga
\end_layout

\begin_layout Itemize
Con 
\begin_inset Quotes eld
\end_inset

R
\begin_inset Quotes erd
\end_inset

 faccio il replace del testo
\end_layout

\begin_layout Itemize
Con 
\begin_inset Quotes eld
\end_inset

Shift+H
\begin_inset Quotes erd
\end_inset

 vado all'inizio del testo H sta per home
\end_layout

\begin_layout Itemize
Con 
\begin_inset Quotes eld
\end_inset

Shift+L
\begin_inset Quotes erd
\end_inset

 vado a fine testo
\end_layout

\begin_layout Itemize
Con 
\begin_inset Quotes eld
\end_inset

u
\begin_inset Quotes erd
\end_inset

 faccio un 
\begin_inset Quotes eld
\end_inset

undo
\begin_inset Quotes erd
\end_inset

, annullo l'ultima operazione
\end_layout

\begin_layout Itemize
Per cercare parole posso usare 
\begin_inset Quotes eld
\end_inset

/parolaDaCercare
\begin_inset Quotes erd
\end_inset

, questo posizionerà il cursore sulla parola cercata
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Per andare alla prossima ricorrenza schiaccio 
\begin_inset Quotes eld
\end_inset

n
\begin_inset Quotes erd
\end_inset

 
\end_layout

\begin_layout Itemize
Per andare alla precedente ricorrenza schiaccio 
\begin_inset Quotes eld
\end_inset

N
\begin_inset Quotes erd
\end_inset

 in realtà posso cercare indietro nel documento anche con 
\begin_inset Quotes eld
\end_inset

?parolaDaCercare
\begin_inset Quotes erd
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Possiamo effettuare sostituzione di testo, ad esempio per sostituire tutte
 le occorrenze della parola 
\begin_inset Quotes eld
\end_inset

this is
\begin_inset Quotes erd
\end_inset

 con 
\begin_inset Quotes eld
\end_inset

that
\begin_inset Quotes erd
\end_inset

 possiamo usare il comando 
\begin_inset Quotes eld
\end_inset

:%s/this is/ that
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Per sostituire solo una riga o una singola parola possiamo usare 
\begin_inset Quotes eld
\end_inset

:1s/this is/ that
\begin_inset Quotes erd
\end_inset

 
\end_layout

\begin_layout Itemize
Con Vi possiamo inserire comandi da terminale GNU/Linux con 
\begin_inset Quotes eld
\end_inset

:!nomecomando
\begin_inset Quotes erd
\end_inset

, ad esempio 
\begin_inset Quotes eld
\end_inset

:!ls
\begin_inset Quotes erd
\end_inset

 
\end_layout

\begin_layout Itemize
Per caricare un file dalla colon mode posso effettuare un 
\begin_inset Quotes eld
\end_inset

:e fileToOpen
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Per caricare il contenuto di un altro file all'interno del file che sto
 editando faccio 
\begin_inset Quotes eld
\end_inset

:r filetoinsert
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Vi supporta diversi plugin, ed il modo più conveniente per gestirli è utilizzare
 dei plugin manager, come 
\begin_inset Quotes eld
\end_inset

plug
\begin_inset Quotes erd
\end_inset

 , due percorsi sono importanti per le personalizzazioni di 
\begin_inset Quotes eld
\end_inset

vi
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Itemize
il percorso ~/.vim/ //che costituisce la directory dove andranno installati
 i nostri plugin
\end_layout

\begin_layout Itemize
il file ~/.vimrc //che costituisce un file di configurazione, con diverse
 possibili opzioni, se non esiste, possiamo crearlo, un'opzione utile è
 ad esempio impostare automaticamente il numero di riga, possiamo farlo
 aggiungendo a questo file la stringa 
\begin_inset Quotes eld
\end_inset

set number
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Vediamo alcune opzioni utili da abilitare in vi/vim, questo è possibile
 attraverso il comando:
\end_layout

\begin_layout Itemize
:syntax on //imposta il syntax highlighting
\end_layout

\begin_layout Itemize
:set syntax=html //imposta il syntax come se fosse un file html, utile quando
 editiamo un file senza estensione e vogliamo il syntax highlighting
\end_layout

\begin_layout Itemize
:set number //imposta il line numbering
\end_layout

\begin_layout Itemize
:set shell sh=/bin/bash //imposto la shell da usare quando eseguo i comandi
 esterni, con 
\begin_inset Quotes eld
\end_inset

:!nomecomando
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
:sh //eseguo la shell impostata
\end_layout

\begin_layout Itemize
:set relativenumber //abilita il conteggio relativo delle linee, in modo
 da poter sempre sapere ad esempio su quante righe precedenti o successive
 lavorare
\end_layout

\begin_layout Itemize
:set paste //imposta vim nella paste mode, in modo da non avere effetti
 indesiderati nel momento in cui andiamo ad incollare da copie effettuate
 in altri programmi, come browser, editor di testo, ecc...
\end_layout

\begin_layout Itemize
:set softtabstop=4 //imposta il numero di caratteri da eliminare quando
 è stato effettuato un tab e si vuole cancellare
\end_layout

\begin_layout Itemize
:set ts=4 //imposto il numero di spazi corrispondenti ad una pressione del
 tasto tab
\end_layout

\begin_layout Itemize
:set sw=4 //quando imposto il tasto tab, devo anche settare questa, altrimenti
 i comandi di indentazione con 
\begin_inset Quotes eld
\end_inset

<
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

>
\begin_inset Quotes erd
\end_inset

 non funzionano
\end_layout

\begin_layout Itemize
:set et //imposto l'espansione del tab con spazi
\end_layout

\begin_layout Itemize
:set autoindent //indenta automaticamente dopo l'invio
\end_layout

\begin_layout Itemize
:set noautoindent //disabilita l'autoindentazione
\end_layout

\begin_layout Itemize
:set splitbelow //automaticamente quando viene eseguito un nuovo split verticale
 la finestra nuova viene posizionata in basso
\end_layout

\begin_layout Itemize
:set splitright //automaticamente quando viene eseguito un nuovo split orizzonta
le la finestra nuova viene posizionata a destra
\end_layout

\begin_layout Itemize
:set wildmenu //imposta l'autocompletamento dei file quando eseguiamo 
\begin_inset Quotes eld
\end_inset

:e
\begin_inset Quotes erd
\end_inset

 o qualsiasi comando che apre un file
\end_layout

\begin_deeper
\begin_layout Itemize
ad esempio 
\begin_inset Quotes eld
\end_inset

:b <TAB>
\begin_inset Quotes erd
\end_inset

 permette di andare in un file precedentemente visitato
\end_layout

\end_deeper
\begin_layout Itemize
:set expandtab //when enabled, causes spaces to be used in place of tab
 characters
\end_layout

\begin_layout Itemize
:set hlsearch //effettua l'highlight di tutti i valori trovati nella ricerca
\end_layout

\begin_layout Itemize
:set showmatch //effettua l'highlight della parentesi corrispondente che
 viene matchata
\end_layout

\begin_layout Itemize
:30,60w newFileName //salva il contenuto dalla linea 30 alla linea 60 in
 un nuovo file
\end_layout

\begin_layout Itemize
:s/parola/parolaNuova/g //sostituisce tutte le occorrenze di 
\begin_inset Quotes eld
\end_inset

parola
\begin_inset Quotes erd
\end_inset

 con 
\begin_inset Quotes eld
\end_inset

parolaNuova
\begin_inset Quotes erd
\end_inset

 solo sulla linea corrente
\end_layout

\begin_layout Itemize
:%s/parola/parolaNuova/g //sostituisce 
\begin_inset Quotes eld
\end_inset

parola
\begin_inset Quotes erd
\end_inset

 con 
\begin_inset Quotes eld
\end_inset

parolaNuova
\begin_inset Quotes erd
\end_inset

 in tutto il testo
\end_layout

\begin_layout Itemize
:%s/parola/parolaNuova/gi //sostituisce 
\begin_inset Quotes eld
\end_inset

parola
\begin_inset Quotes erd
\end_inset

 con 
\begin_inset Quotes eld
\end_inset

parolaNuova
\begin_inset Quotes erd
\end_inset

 in tutto il testo in modalità case insensitive
\end_layout

\begin_layout Itemize
:3,7s/parola/parolaNuova/g //sostituisce 
\begin_inset Quotes eld
\end_inset

parola
\begin_inset Quotes erd
\end_inset

 con 
\begin_inset Quotes eld
\end_inset

parolaNuova
\begin_inset Quotes erd
\end_inset

 tra le righe 3 e 7
\end_layout

\begin_layout Itemize
:%s/parola/parolaNuova/gc //sostituisce tutte le occorrenze di 
\begin_inset Quotes eld
\end_inset

parola
\begin_inset Quotes erd
\end_inset

 con 
\begin_inset Quotes eld
\end_inset

parolaNuova
\begin_inset Quotes erd
\end_inset

 chiedendo conferma ad ogni occorrenza
\end_layout

\begin_layout Itemize
map <F2> :Vexplore<CR> //mappa il tasto F2 ad un file explorer
\end_layout

\begin_layout Itemize
map <F5> :set number!<CR><Esc> //mappa il tasto F5 ad un toggle per la numerazio
ne delle linee
\end_layout

\begin_layout Itemize
nnoremap <C-w>t :tabnew<cr> //mappa il tasto Ctrl+w, t alla creazione di
 una nuova tab
\end_layout

\begin_layout Standard
For what concerns the remapping we have to know that, we have various options,
\end_layout

\begin_layout Standard
remap is an option that makes mappings work recursively.
 By default it is on and I'd recommend you leave it that way.
 The rest are mapping commands, described below:
\end_layout

\begin_layout Standard
:map and :noremap are recursive and non-recursive versions of the various
 mapping commands.
 What that means is that if you do:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

:map j gg 
\end_layout

\begin_layout Plain Layout

:map Q j 
\end_layout

\begin_layout Plain Layout

:noremap W j
\end_layout

\end_inset


\end_layout

\begin_layout Standard
j will be mapped to gg.
 Q will also be mapped to gg, because j will be expanded for the recursive
 mapping.
 W will be mapped to j (and not to gg) because j will not be expanded for
 the non-recursive mapping.
\end_layout

\begin_layout Standard
Now remember that Vim is a modal editor.
 It has a normal mode, visual mode and other modes.
\end_layout

\begin_layout Standard
For each of these sets of mappings, there is a mapping that works in normal,
 visual, select and operator modes (:map and :noremap), one that works in
 normal mode (:nmap and :nnoremap), one in visual mode (:vmap and :vnoremap)
 and so on.
\end_layout

\begin_layout Standard
Se vogliamo rendere permanenti queste modifiche, salviamo le stringhe relative
 ai comandi all'interno del file 
\begin_inset Quotes eld
\end_inset

.vimrc
\begin_inset Quotes erd
\end_inset

 presente (o forse no) nella home directory, ad esempio col comando:
\end_layout

\begin_layout Itemize
echo 
\begin_inset Quotes eld
\end_inset

syntax on
\begin_inset Quotes erd
\end_inset

 >> ~/.vimrc
\end_layout

\begin_layout Itemize
echo 
\begin_inset Quotes eld
\end_inset

set number
\begin_inset Quotes erd
\end_inset

 >> ~/.vimrc
\end_layout

\begin_layout Subsection
Vim
\end_layout

\begin_layout Standard
Possiamo eseguire copy & paste compatibile con altre applicazioni grafiche
 se abbiamo l'opzione 
\begin_inset Quotes eld
\end_inset

+clipboard
\begin_inset Quotes erd
\end_inset

 attivata quando eseguiamo:
\end_layout

\begin_layout Itemize
:version
\end_layout

\begin_layout Standard
se questa è presente possiamo copiare attraverso il comando (dopo aver seleziona
to con la modalità visual):
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

y+ //in questo caso copio nella clipboard di xorg
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

_d //cancella una riga senza incollarla in un buffer, quindi esegue solo
 delete e non cut
\end_layout

\begin_layout Standard
possiamo anche incollare in modalità insert senza ritornare in 
\begin_inset Quotes eld
\end_inset

normal mode
\begin_inset Quotes erd
\end_inset

, eseguendo:
\end_layout

\begin_layout Itemize
Ctrl+r e poi premendo il registro da cui vogliamo incollare
\end_layout

\begin_layout Standard
se invece volessimo incollare del codice (ad esempio) preso da un browser
 o da qualsiasi altra applicazione in xorg, allora a questo punto eseguiamo:
\end_layout

\begin_layout Itemize
:set paste //per abilitare la modalità incolla
\end_layout

\begin_layout Standard
per capire se una modalità è attiva o meno possiamo fare così:
\end_layout

\begin_layout Itemize
:set paste?
\end_layout

\begin_layout Standard
oppure:
\end_layout

\begin_layout Itemize
:set ft? autoindent? //fa un check su due impostazioni
\end_layout

\begin_layout Standard
e poi premiamo la combinazione 
\begin_inset Quotes eld
\end_inset

Shift+Control+v
\begin_inset Quotes erd
\end_inset

 oppure un incolla col mouse.
\end_layout

\begin_layout Standard
Possiamo testare una configurazione di un file .vimrc, senza modificare il
 nostro, attraverso il flag 
\begin_inset Quotes eld
\end_inset

-u
\begin_inset Quotes erd
\end_inset

, con:
\end_layout

\begin_layout Itemize
vim -u test_vimrc //dove test_vimrc è il file di configurazione di github
 che vogliamo testare, ne possiamo trovare tantissimi su github
\end_layout

\begin_layout Standard
Cosa utile in Vim per convertire file da windows a linux (o da linux a windows
 ?) è:
\end_layout

\begin_layout Itemize
:1,$s/^M//g
\end_layout

\begin_layout Standard
Ci potrebbe capitare di premere la combinazione di tasti Ctrl+s, in questo
 caso sembrerebbe che vim sia bloccato, in realtà basta premere Ctrl+q per
 sbloccarlo, questa feature è chiamata 
\begin_inset Quotes eld
\end_inset

software flow control
\begin_inset Quotes erd
\end_inset

.
 E' una feature legacy che esiste dagli anni 80,
\end_layout

\begin_layout Standard
per disabilitare questa feature dobbiamo modificare il nostro file di configuraz
ione shell ad esempio ~/.bash_profile or ~/.bashrc, con la seguente stringa:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

stty -ixon 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
P.S.: Per navigare i file è molto comodo il plugin 
\begin_inset Quotes eld
\end_inset

CtrlP
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Subsubsection
Richiamare programmi esterni su blocchi di righe
\end_layout

\begin_layout Standard
Una volta selezionato un blocco di righe ad esempio con 
\begin_inset Quotes eld
\end_inset

Shift+V
\begin_inset Quotes erd
\end_inset

, possiamo applicare comandi esterni come awk, sed o meglio ancora perl,
 andando a modificare il testo, ad esempio una volta selezionato il testo
 desiderato, possiamo premere 
\begin_inset Quotes eld
\end_inset

:
\begin_inset Quotes erd
\end_inset

, e ci verrà mostrata una stringa coi caratteri 
\begin_inset Quotes eld
\end_inset

'<,'>
\begin_inset Quotes erd
\end_inset

, a questo punto possiamo digitare 
\begin_inset Quotes eld
\end_inset

!
\begin_inset Quotes erd
\end_inset

 preceduto dal comando esterno ad esempio:
\end_layout

\begin_layout Itemize
:'<,'>!perl -ne 'print if ($_ > 15)'
\end_layout

\begin_layout Standard
questo si che è figo.
\end_layout

\begin_layout Subsubsection
Cercare documentazione in vim
\end_layout

\begin_layout Standard
Possiamo cercare documentazione una volta posizionato il cursore su una
 determinata funzione/keyword premendo 
\begin_inset Quotes eld
\end_inset

shift+k
\begin_inset Quotes erd
\end_inset

.
 Ad esempio se programmiamo in Perl, questo funziona solo se abbiamo installato
 il pacchetto 
\begin_inset Quotes eld
\end_inset

perl-doc
\begin_inset Quotes erd
\end_inset

 o se programmiamo in python solo se abbiamo installato 
\begin_inset Quotes eld
\end_inset

pydoc
\begin_inset Quotes erd
\end_inset

 e così via.
 
\end_layout

\begin_layout Standard
Inoltre per cercare ad esempio il prototipo di una funzione scritta da noi,
 possiamo (cercare :h tags, :h ctags, :h cscope, :h include-search :help
 include-search -> http://vimhelp.appspot.com/tagsrch.txt.html#include-search)
\end_layout

\begin_layout Subsubsection
Editare file con sudo
\end_layout

\begin_layout Standard
Se dovessimo aprire un file senza i permessi necessari per modificarlo con
 vim, possiamo apportare comunque le modifiche eseguendo:
\end_layout

\begin_layout Itemize
:w | !sudo tee % //questo ci permetterà di salvare le modifiche anche non
 essendo root
\end_layout

\begin_layout Standard
inoltre aprire vim con i diritti di root non è molto costruttivo in quanto
 perdiamo la configurazione di vim utilizzata per il nostro utente, quindi
 se volessimo evitare di lanciare quel comando lungo da vim tutte le volte
 possiamo considerare di usare 
\begin_inset Quotes eld
\end_inset

sudoedit
\begin_inset Quotes erd
\end_inset

 o 
\begin_inset Quotes eld
\end_inset

sudo -e
\begin_inset Quotes erd
\end_inset

 che sono equivalenti, quindi eseguiamo:
\end_layout

\begin_layout Itemize
sudoedit /path/al/file/diRoot //in questo modo viene creata una copia temporanea
 del file, in modo da usare la mia configurazione di vim e solo una volta
 salvato andremo a riscrivere il file originale con i diritti di root
\end_layout

\begin_layout Subsubsection
Folding/Unfolding di testo
\end_layout

\begin_layout Standard
Possiamo eseguire un folding di testo, in vari modi, uno ad esempio è entrare
 nella modalità visual, selezionare il testo interessato e poi eseguire:
\end_layout

\begin_layout Itemize
zf //effettua il folding del testo
\end_layout

\begin_layout Standard
oppure possiamo utilizzare cose come ad esempio:
\end_layout

\begin_layout Itemize
zfip //fold direttamente di un paragrafo
\end_layout

\begin_layout Standard
oppure:
\end_layout

\begin_layout Itemize
zfap //fold del testo tenendo conto anche delle parentesi
\end_layout

\begin_layout Standard
o ad esempio nel caso avessimo una funzione delimitata da simboli 
\begin_inset Quotes eld
\end_inset

{
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

}
\begin_inset Quotes erd
\end_inset

 eseguiamo:
\end_layout

\begin_layout Itemize
zfi{ //fold della funzione delimitata da parentesi graffe
\end_layout

\begin_layout Standard
ovviamente può essere applicato a tutte le parentesi.
 Possiamo unfoldare il testo premendo ad esempio 
\begin_inset Quotes eld
\end_inset

i
\begin_inset Quotes erd
\end_inset

 sul testo foldato.
 E' buona norma mettere dei commenti sul testo che vogliamo foldare (nel
 caso in cui il testo in questione non sia una funzione) in modo che una
 volta foldato sappiamo a cosa si riferisce.
\end_layout

\begin_layout Standard
Oppure possiamo aprire e chiudere un fold con:
\end_layout

\begin_layout Itemize
zo //apre il fold
\end_layout

\begin_layout Itemize
zc //richiude il fold
\end_layout

\begin_layout Itemize
zi //abilita/disabilita il fold
\end_layout

\begin_layout Subsubsection
Navigare Codice Sorgente
\end_layout

\begin_layout Itemize
gd/gD //Possiamo andare alla definizione di una variabile/funzione mentre
 ci siamo sopra col cursore
\end_layout

\begin_layout Itemize
<Ctrl+o> //andiamo alla precedente posizione nel codice
\end_layout

\begin_layout Itemize
<Ctrl+i> //ritorniamo alla successiva posizione nel codice
\end_layout

\begin_layout Itemize
* //andiamo alla prossima occorrenza della stringa su cui è il cursore
\end_layout

\begin_layout Subsubsection
File di template in Vim
\end_layout

\begin_layout Standard
Possiamo creare una directory con tutta una serie di template per vari file
 sorgenti appartenenti a diversi linguaggi di programmazione, ad esempio
 ipotizziamo che nella directory ~/templates/sources/ ci siano tutti i sorgenti
 e abbiamo uno scheletro per tutti i file python, ad esempio 
\begin_inset Quotes eld
\end_inset

~/templates/sources/skeleton.py
\begin_inset Quotes erd
\end_inset

, a questo punto ci basterà inserire nel nostro file di configurazione la
 stringa:
\end_layout

\begin_layout Itemize
autocmd BufNewFile *.py 0r ~/templates/sources/skeleton.py
\end_layout

\begin_layout Standard
ora ogni volta che creeremo un nuovo file avremo già lo scheletro.
\end_layout

\begin_layout Subsubsection
Documentazione per sorgenti
\end_layout

\begin_layout Standard
nel file relativo alla configurazione del linguaggio in uso, ad esempio
 
\begin_inset Quotes eld
\end_inset

~/.vim/after/ftplugin/python.vim
\begin_inset Quotes erd
\end_inset

 possiamo aggiungere:
\end_layout

\begin_layout Itemize
set keywordprg=:new
\backslash
|setl
\backslash
 buftype=nofile
\backslash
 nobuflisted
\backslash
|r
\backslash
 !
\backslash
 pydoc //questo ci permetterà di aprire un nuovo buffer temporaneo in cui
 comparirà la documentazione
\end_layout

\begin_layout Subsubsection
Window, buffers e Tab Management
\end_layout

\begin_layout Standard
In generale il workflow di vim è gestito attraverso:
\end_layout

\begin_layout Itemize
buffers: ad un buffer corrisponde un file, 
\end_layout

\begin_layout Itemize
windows: Windows are not designed as file-proxies and can't be made into
 ones: they are "containers" or "viewports" designed to offer you a view
 into a buffer.
 No more, no less.
\end_layout

\begin_layout Itemize
tabs: ad una tab corrisponde un workspace intero
\end_layout

\begin_layout Standard
ora, il concetto di tab può essere fuorviante per chi è abituato con altri
 editor, in quanto in vim il tab è associato ad un vero e proprio intero
 workspace, mentre esiste la corrispondenza 1 buffer = 1 file aperto, quindi
 il buffer è quello che negli altri IDE invece corrisponde al tab, le window
 possono mostrare quello che è all'interno di un buffer, quindi di un file,
 posso visualizzare più window nella stessa schermata, con lo stesso buffer
 on con buffer diversi.
 Un tab quindi in genere può gestire molti buffer e molte window.
\end_layout

\begin_layout Subsubsection
Comandi per gestire le Window
\end_layout

\begin_layout Itemize
Ctrl+w, n //apre una nuova window in verticale
\end_layout

\begin_layout Itemize
Ctrl+w, s //apre una nuova finastra in orizzontale, se abbiamo selezionato
 una funzione o un blocco di codice possiamo focalizzarci su quest'ultimo
\end_layout

\begin_layout Itemize
Ctrl+w, v //apre una nuova finastra in verticale
\end_layout

\begin_layout Itemize
Ctrl+w, q //chiude una finestra
\end_layout

\begin_layout Itemize
Ctrl+w, (arrows or hjkl) //sposto il cursore su un'altra finestra
\end_layout

\begin_layout Itemize
Ctrl+w, (HJKL) //sposto la finestra nella direzione indicata
\end_layout

\begin_layout Itemize
Ctrl+w, w //cicla la selezione sulle window disponibili
\end_layout

\begin_layout Itemize
Ctrl+w, p //seleziona l'ultima finestra a cui è stato fatto accesso
\end_layout

\begin_layout Itemize
Ctrl+w, o //chiude tutte le altre finestre eccetto quella selezionata (funziona
 solo se non sono stati effettuate modifiche nelle altre finestre)
\end_layout

\begin_layout Itemize
Ctrl+w, _ //massimizza in verticale la window corrente
\end_layout

\begin_layout Itemize
Ctrl+w, | //massimizza in orizzontale la window corrente
\end_layout

\begin_layout Itemize
Ctrl+w, = //ridimensiona le finestre dando loro lo stesso spazio
\end_layout

\begin_layout Itemize
Ctrl+w, f //apre un file in una nuova tab
\end_layout

\begin_layout Itemize
Ctrl+w, gf //apre il file sotto il cursore in una nuova finestra
\end_layout

\begin_layout Itemize
Ctrl+w, Ctrl+- //riduce le dimensioni in altezza di una finestra, posso
 inserire prima del - un numero in modo da modificare più velocemente le
 dimensioni
\end_layout

\begin_layout Itemize
Ctrl+w, Ctrl++ //aumenta le dimensioni in altezza di una finestra, posso
 inserire prima del + un numero in modo da modificare più velocemente le
 dimensioni
\end_layout

\begin_layout Itemize
Ctrl+w, Ctrl+< //riduce le dimensioni in larghezza di una finestra, posso
 inserire prima del < un numero in modo da modificare più velocemente le
 dimensioni
\end_layout

\begin_layout Itemize
Ctrl+w, Ctrl+> //aumenta le dimensioni in larghezza di una finestra, posso
 inserire prima del > un numero in modo da modificare più velocemente le
 dimensioni
\end_layout

\begin_layout Itemize
Ctrl+o, va alla precedente posizione nella jump list
\end_layout

\begin_layout Itemize
Ctrl+i, va alla successiva posizione nella jump list
\end_layout

\begin_layout Subsubsection
Comandi per gestire i Buffer
\end_layout

\begin_layout Standard
utilizzare ctrp.vim per avere una gestione più flessibile delle finestre,
 dei buffer eccetera e per lavorare con progetti con molti file.
\end_layout

\begin_layout Standard
Per elencare i buffer possiamo usare:
\end_layout

\begin_layout Itemize
:e nomeFile //permette di aprire un file in un nuovo buffer
\end_layout

\begin_layout Itemize
:e <tab> //mi permette di avere l'autocompletamento per i file nella directory
 corrente e aprire il file selezionato in un nuovo buffer
\end_layout

\begin_layout Itemize
:ls //mostra i buffer correntemente aperti
\end_layout

\begin_layout Itemize
:b + Ctrl+d //mostra i buffer a cui posso saltare
\end_layout

\begin_layout Itemize
:b numero_visto_da_ls //salta al buffer selezionato
\end_layout

\begin_layout Itemize
:b <tab> //possiamo scorrere i diversi buffer, molto comodo soprattutto
 se selezionata l'opzione 
\begin_inset Quotes eld
\end_inset

set wildmenu
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
:bd //chiude il buffer corrente
\end_layout

\begin_layout Itemize
gf //va al file, se il cursore evidenzia un file
\end_layout

\begin_layout Standard
E' da considerara che la maggior parte del tempo la spendiamo in buffer
 e windows, le tab sono usate molto poco perchè in genere corrispondono
 proprio a sessioni di lavoro diverse.
\end_layout

\begin_layout Subsubsection
Comandi per gestire le Tab
\end_layout

\begin_layout Itemize
:tabnew //crea una nuova tab
\end_layout

\begin_layout Itemize
:tabclose //chiude la tab corrente
\end_layout

\begin_layout Itemize
gt //va alla prossima tab
\end_layout

\begin_layout Itemize
gT //va alla tab precedente
\end_layout

\begin_layout Subsubsection
Auto Indentazione di Codice
\end_layout

\begin_layout Standard
Per autoindentare codice, possiamo fare nella normal mode:
\end_layout

\begin_layout Itemize
gg=G //autoindenta il codice, e mette a posto la formattazione, in pratica
 il comando indenta è =, quindi con gg ci posizioniamo a inizio file, =
 indenta e con G gli diciamo di indentare fino a fine file
\end_layout

\begin_layout Subsubsection
Vim Plugins
\end_layout

\begin_layout Standard
Esistono molti plugin, e molti plugin manager (consigliatissimo se non obbligato
rio usarli), ad esempio uno dei più famosi è 
\begin_inset Quotes eld
\end_inset

pathogen
\begin_inset Quotes erd
\end_inset

 ma c'è anche 
\begin_inset Quotes eld
\end_inset

apt-vim
\begin_inset Quotes erd
\end_inset

 e molti altri, con pathogen per installare un plugin eseguiamo:
\end_layout

\begin_layout Itemize
cd ~/.vim/bundle && git clone https://github.com/scrooloose/nerdtree.git //in
 questo caso stiamo installando l'estensione nerdtree
\end_layout

\begin_layout Standard
la maggior parte dei plugin è su github quindi git è utilizzatissimo in
 questi casi, in pratica però quello che accade è la copia della directory
 
\begin_inset Quotes eld
\end_inset

nerdtree
\begin_inset Quotes erd
\end_inset

 all'interno di 
\begin_inset Quotes eld
\end_inset

.vim/bundle/
\begin_inset Quotes erd
\end_inset

, in questo modo avremo la directory 
\begin_inset Quotes eld
\end_inset

.vim/bundle/nerdtree
\begin_inset Quotes erd
\end_inset

 e dentro questa tutti i file relativi, ovviamente per la maggior parte
 dei plugin saranno da aggiungere una o più righe al file di configurazione
 
\begin_inset Quotes eld
\end_inset

.vimrc
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsubsection
Configurazione Vim per tipo di File
\end_layout

\begin_layout Standard
Potrebbe capitare che per file con estensione 
\begin_inset Quotes eld
\end_inset

.c
\begin_inset Quotes erd
\end_inset

 vogliamo che il tab sia di 8 caratteri mentre per file con estensione 
\begin_inset Quotes eld
\end_inset

.rb
\begin_inset Quotes erd
\end_inset

 il tab sia di 
\begin_inset Quotes eld
\end_inset

2
\begin_inset Quotes erd
\end_inset

 caratteri, per cambiare queste impostazioni per tipo di file ci basta creare
 una directory chiamata 
\begin_inset Quotes eld
\end_inset

.vim/after/ftplugin
\begin_inset Quotes erd
\end_inset

 e poi creare dei file 
\begin_inset Quotes eld
\end_inset

.vim
\begin_inset Quotes erd
\end_inset

 per ciascuna estensione desiderata, ad esempio, andiamo a modificare la
 larghezza del tab per i file con estensione 
\begin_inset Quotes eld
\end_inset

.rb
\begin_inset Quotes erd
\end_inset

 (per il linguaggio ruby), possiamo fare così:
\end_layout

\begin_layout Itemize
mkdir -p ~/.vim/after/ftplugin
\end_layout

\begin_layout Itemize
touch ruby.vim
\end_layout

\begin_layout Standard
e ora in 
\begin_inset Quotes eld
\end_inset

c.vim
\begin_inset Quotes erd
\end_inset

 inseriamo ad esempio:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

set ts=2
\end_layout

\begin_layout Plain Layout

set sw=2
\end_layout

\begin_layout Plain Layout

set et
\end_layout

\end_inset


\end_layout

\begin_layout Standard
possiamo capire come chiamare il file, capendo qual'è il tipo associato,
 ad esempio nel caso del bash, creare un file chiamato bash.vim non funzionerà
 per scoprire come chiamare il file, mettiamoci in un file bash ed eseguiamo
 il comando:
\end_layout

\begin_layout Itemize
:set ft? //questo comando ci indicherà il tipo di file, nel caso di un file
 bash ci risponderà 
\begin_inset Quotes eld
\end_inset

sh
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
a questo punto dal tipo di file possiamo creare il nostro file ~/.vim/after/ftplu
gin/sh.vim con le impostazioni desiderate.
\end_layout

\begin_layout Subsubsection
Registri
\end_layout

\begin_layout Standard
In vim possiamo copiare ed incollare da vari registri...
 possiamo selezionare un registro con il doppio apice 
\begin_inset Quotes eld
\end_inset

, inoltre c'è un registro speciale chiamato 
\begin_inset Quotes eld
\end_inset

blackhole
\begin_inset Quotes erd
\end_inset

 indicato conl'underscore 
\begin_inset Quotes eld
\end_inset

_
\begin_inset Quotes erd
\end_inset

, ad esempio nel caso volessimo buttare via una riga senza copiarla, possiamo
 tagliarla e incollarla nel registro blackhole con: 
\begin_inset Quotes eld
\end_inset

_dd, mentre per salvare una riga nel registro b, possiamo usare 
\begin_inset Quotes eld
\end_inset

bdd.
\end_layout

\begin_layout Subsubsection
Make e Automatizzare Compilazioni
\end_layout

\begin_layout Standard
Possiamo impostare il comando 
\begin_inset Quotes eld
\end_inset

make
\begin_inset Quotes erd
\end_inset

 con:
\end_layout

\begin_layout Itemize
:set makeprg=bash
\backslash
 myscript.sh
\end_layout

\begin_layout Standard
oppure per evitare di usare escape possiamo usare:
\end_layout

\begin_layout Itemize
:let &makeprg = 
\begin_inset Quotes eld
\end_inset

cd cmt && make
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
oppure possiamo cambiare il comando make a differenza del tipo di file,
 ad esempio:
\end_layout

\begin_layout Itemize
set makeprg=redcarpet
\backslash
 %
\backslash
 >/tmp/%<.html
\end_layout

\begin_layout Standard
where % means the file currently edited, and %< means the file currently
 edited without extension
\end_layout

\begin_layout Subsection
Streams and Redirects, Redirection
\end_layout

\begin_layout Standard
I canali standard (o standard streams), in tutti i moderni sistemi operativi,
 rappresentano i dispositivi logici di input e di output che collegano un
 programma con l'ambiente operativo in cui esso viene eseguito (tipicamente
 un terminale testuale) e che sono connessi automaticamente al suo avvio.
 Questi canali predefiniti sono disponibili nei sistemi operativi Unix e
 Unix-like, e in alcuni ambienti di programmazione.
\end_layout

\begin_layout Standard
I tre canali di input/output predefiniti sono detti standard input, standard
 output e standard error (talvolta abbreviati rispettivamente in stdin,
 stdout e stderr).
 In soldoni:
\end_layout

\begin_layout Itemize
Tutto quello che viene inserito come input da tastiera (Standatd Input o
 stdin)
\end_layout

\begin_layout Itemize
L'output del comando/programmo (Standard Output o stdout)
\end_layout

\begin_layout Itemize
Degli errori prodotti dal comanda/programma, come ad esempio 
\begin_inset Quotes eld
\end_inset

file not found
\begin_inset Quotes erd
\end_inset

 o 
\begin_inset Quotes eld
\end_inset

permission denied
\begin_inset Quotes erd
\end_inset

 (Standard Error o stderr)
\end_layout

\begin_layout Standard
Nei sistemi operativi GNU/Linux si utilizza: 
\end_layout

\begin_layout Itemize
il simbolo 
\begin_inset Quotes eld
\end_inset

>
\begin_inset Quotes erd
\end_inset

 per redirigire lo stdout altrove in un altro file
\end_layout

\begin_layout Itemize
il simbolo 
\begin_inset Quotes eld
\end_inset

<
\begin_inset Quotes erd
\end_inset

 per redirigere lo stdin attraverso un file, input redirection can be useful
 if you have written a program which expects input from the terminal and
 you want to provide it from a file
\end_layout

\begin_layout Itemize
il simbolo 
\begin_inset Quotes eld
\end_inset

1>
\begin_inset Quotes erd
\end_inset

 per redirigire lo stdout altrove in un altro file
\end_layout

\begin_layout Itemize
il simbolo 
\begin_inset Quotes eld
\end_inset

2>
\begin_inset Quotes erd
\end_inset

 per redirigere lo stderr in un altro file
\end_layout

\begin_layout Itemize
il simbolo 
\begin_inset Quotes eld
\end_inset

>>
\begin_inset Quotes erd
\end_inset

 per redirigere lo stdout in modalità 
\begin_inset Quotes eld
\end_inset

append
\begin_inset Quotes erd
\end_inset

, dove per modalità append si intende l'aggiunta di testo senza sovrascrittura
 del testo già pre-esistente
\end_layout

\begin_layout Itemize
il simbolo 
\begin_inset Quotes eld
\end_inset

<<
\begin_inset Quotes erd
\end_inset

 per utilizzare 
\begin_inset Quotes eld
\end_inset

heredoc
\begin_inset Quotes erd
\end_inset

 cioè dare in pasto stringhe fino ad un determinato delimitatore 
\end_layout

\begin_layout Itemize
il simbolo 
\begin_inset Quotes eld
\end_inset

2>>
\begin_inset Quotes erd
\end_inset

 per redirigere lo stderr in modalità 
\begin_inset Quotes eld
\end_inset

append
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
il simbolo 
\begin_inset Quotes eld
\end_inset

<<<
\begin_inset Quotes erd
\end_inset

 per utilizzare 
\begin_inset Quotes eld
\end_inset

herestring
\begin_inset Quotes erd
\end_inset

 cioè dare in pasto una stringa multilinea
\end_layout

\begin_layout Standard
Un caso d'uso di redirizione dello stderr è ad esempio quando vogliamo che
 non vengano stampati a schermo gli errori o i warning forniti da un programma,
 allora in questo caso si redirige lo stderr nel cosiddetto buco nero dell'infor
matica e cioè il file 
\begin_inset Quotes eld
\end_inset

/dev/null
\begin_inset Quotes erd
\end_inset

, viene chiamato così in quanto qualsiasi cosa ci finisce viene cancellata;
 quindi con:
\end_layout

\begin_layout Itemize
nomeComando 2> /dev/null
\end_layout

\begin_layout Standard
Nel caso volessimo invece redirigere sia lo stdout che lo stderr allora
 dovremmo utilizzare un comando come
\end_layout

\begin_layout Itemize
cat file1 file2 > myfilestdout 2> myfilestderr 
\end_layout

\begin_layout Itemize
il simbolo 
\begin_inset Quotes eld
\end_inset

2>&1
\begin_inset Quotes erd
\end_inset

 indica un redirezionamento dello stderr allo stdout file
\end_layout

\begin_layout Standard
Ad esempio: 
\end_layout

\begin_layout Itemize
cat file file2 file3 > mystdout 2>&1 //mi fa l'append dello stderr al file
 dell'stdout, che in questo caso è mystdout
\end_layout

\begin_layout Standard
Un'altra possibile opzione è:
\end_layout

\begin_layout Itemize
il simbolo 
\begin_inset Quotes eld
\end_inset

&>
\begin_inset Quotes erd
\end_inset

 che mi permette di redirigere contemporaneamente stderr e stdout nello
 stesso file
\end_layout

\begin_layout Standard
ad esempio:
\end_layout

\begin_layout Itemize
cmd &> output.txt
\end_layout

\begin_layout Standard
vediamo un esempio di redirection dell'input:
\end_layout

\begin_layout Itemize
myprogram < filename //prende come input il contenuto del file specificato
\end_layout

\begin_layout Standard
E' anche possibile inserire i redirection prima del comando e ad esempio
 eseguire:
\end_layout

\begin_layout Itemize
> fileOut myCommand arg1 arg2
\end_layout

\begin_layout Itemize
< fileName tr -d 'C'
\end_layout

\begin_layout Standard
vediamo invece ora un esempio di heredoc, in pratica questa è una modalità
 che ci permette di inserire una stringa multilinea fino ad un delimitatore
 da noi specificato, This type of redirection instructs the shell to read
 input from the current source until a line containing only word (with no
 trailing blanks) is seen, all of the lines read up to that point are then
 used as the standard input for a command ad esempio:
\end_layout

\begin_layout Itemize
sql=$(cat <<EOF SELECT 
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

foo, bar FROM db WHERE foo='baz'
\end_layout

\begin_layout Plain Layout

EOF
\end_layout

\begin_layout Plain Layout

)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
or let's see how to pass this multiline to a file:
\end_layout

\begin_layout Itemize
$ cat <<EOF > print.sh
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#!/bin/bash echo 
\backslash
$PWD echo $PWD EOF
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
or we can pass this multiline to a series of command:
\end_layout

\begin_layout Itemize
cat <<EOF | grep 'b' | tee b.txt | grep 'r' 
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

foo bar baz 
\end_layout

\begin_layout Plain Layout

EOF
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
vediamo altri esempi:
\end_layout

\begin_layout Itemize
tr a-z A-Z << END_TEXT
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

one two three
\end_layout

\begin_layout Plain Layout

four five six
\end_layout

\begin_layout Plain Layout

END_TEXT
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
possiamo anche ad esempio fare in modo che la prima occorrenza della parola
 specificata interrompa l'input aggiungendo un 
\begin_inset Quotes eld
\end_inset

-
\begin_inset Quotes erd
\end_inset

 prima della parola, ad esempio:
\end_layout

\begin_layout Itemize
tr a-z A-Z <<- END_TEXT 
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

one two three four five six END_TEXT
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
vediamo ora un esempio di 
\begin_inset Quotes eld
\end_inset

here string
\begin_inset Quotes erd
\end_inset

, in pratica possiamo specificare stringhe su più linee senza utilizzare
 una parola specifica come delimitatore:
\end_layout

\begin_layout Itemize
tr a-z A-Z <<< ' one 
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

two 
\end_layout

\begin_layout Plain Layout

three'
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
in pratica vengono usati i singoli apici 
\begin_inset Quotes eld
\end_inset

'
\begin_inset Quotes erd
\end_inset

 come delimitatori a differenza delle 
\begin_inset Quotes eld
\end_inset

heredoc
\begin_inset Quotes erd
\end_inset

 in cui specificavamo una parola delimitante.
\end_layout

\begin_layout Standard
Vediamo un altro esempio in cui ad esempio inizializziamo contemporanemente
 più variabili:
\end_layout

\begin_layout Itemize
read a b c <<< 'one two three' 
\end_layout

\begin_layout Standard
ora possiamo provare con: 
\end_layout

\begin_layout Itemize
echo $a $b $c //questo stamperà il valore delle tre variabili e possiamo
 notare che a='one', b='two' e c='three'
\end_layout

\begin_layout Subsection
Cat, wc, split, diff e shuf
\end_layout

\begin_layout Standard
Il comando cat può essere utilizzato per visualizzare piccoli file o concatenare
 più file.
 Alcuni esempi di applicazione possono essere: 
\end_layout

\begin_layout Itemize
cat filename //visualizza il file filename
\end_layout

\begin_layout Itemize
cat filename1 filename2 //visualizza i due file concatenati
\end_layout

\begin_layout Standard
Il comando wc mi fornisce informazioni su un file di testo, come il numero
 di linee o di parole.
 Ad esempio: 
\end_layout

\begin_layout Itemize
wc -l nomefile //mi fornisce il numero di righe da cui è composto il file
 
\end_layout

\begin_layout Standard
Il comando split è utilizzato per spezzare un file in più file:
\end_layout

\begin_layout Itemize
split -l 2 nomefile //questo comando per ogni due righe del file crea un
 nuovo file, se nomefile ha 8 righe, verranno creati 4 file
\end_layout

\begin_layout Itemize
split -l $[ $(wc -l filename|cut -d" " -f1) * 70 / 100 ] filename //divide
 il file in base alle righe, in questo caso vengono prese solo il 70% delle
 righe, è da notare che non funziona per percentuali sotto il 50%, i file
 in output iniziano con 
\begin_inset Quotes eld
\end_inset

xx
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
una versione più elaborata di split è 
\begin_inset Quotes eld
\end_inset

csplit
\begin_inset Quotes erd
\end_inset

 che viene utilizzato per effettuare split di file contenenti linee di contesto,
 ma possiamo utilizzarlo anche per dividere il numero di righe in percentuali
 al di sotto del 50%.
\end_layout

\begin_layout Itemize
csplit xonotic_commands $(( $(wc -l < xonotic_commands) * 2 / 10 + 1)) //ivide
 il file in base alle righe, in questo caso vengono prese solo il 70% delle
 righe, funziona ancheper percentuali sotto il 50%, nell'esempio viene preso
 il 20% del file e salvato in un file e il restante in un altro file, i
 file in output iniziano con xx
\end_layout

\begin_layout Standard
Il comando diff è utilizzato per vedere le differenze tra due o più file:
\end_layout

\begin_layout Itemize
diff fileA fileB //evidenzia le differenze tra il fileA e il fileB
\end_layout

\begin_layout Itemize
diff -u fileA fileB //visualizza le differenze nel formato unified, quello
 utilizzato da git e altri software di versioning
\end_layout

\begin_layout Standard
Il comando shuf è utilizzato per randomizzare le righe di un file, questo
 può essere utile quando lavoriamo con dati all'interno di file o csv e
 dobbiamo analizzarli:
\end_layout

\begin_layout Itemize
shuf nomeFile //effettua permutazioni sulle righe del file
\end_layout

\begin_layout Subsection
Pipes
\end_layout

\begin_layout Standard
Permettono di usare l'output di un comando come input per un altro comando.
 Quello che viene preso è l'output inteso come contenuto del file relativo
 allo stdout.
 Ad esempio:
\end_layout

\begin_layout Itemize
ls /etc | sort -f //questo comando prende il listato prodotto da ls e lo
 da in pasto a sort che lo ordina, il parametro -f indica di usare la modalità
 
\begin_inset Quotes eld
\end_inset

case insensitive
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Subsection
Tee
\end_layout

\begin_layout Standard
Il comando 
\begin_inset Quotes eld
\end_inset

tee
\begin_inset Quotes erd
\end_inset

 permette di scrivere sia lo standard output sullo schermo che all'interno
 di un file.
\end_layout

\begin_layout Standard
Ad esempio:
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

ls | tee newfile
\begin_inset Quotes erd
\end_inset

 it will write the list of files into the file newfile 
\end_layout

\begin_layout Standard
Un altro esempio potrebbe essere
\end_layout

\begin_layout Itemize
ls | tee -a newfile //attraverso il parametro -a, riusciamo a scrivere in
 append nel file senza sovrascriverlo del tutto.
\end_layout

\begin_layout Standard
La differenza sostanziale quindi tra un 
\begin_inset Quotes eld
\end_inset

tee
\begin_inset Quotes erd
\end_inset

 e un redirect sta nel fatto che 
\begin_inset Quotes eld
\end_inset

tee
\begin_inset Quotes erd
\end_inset

 riesce a stampare in due posti contemporaneamente standard output + file,
 mentre un semplice redirect scrive in un solo posto.
\end_layout

\begin_layout Subsection
Cut
\end_layout

\begin_layout Standard
Spesso accade di ritrovarsi a lavorare con file organizzati per righe o
 colonne, in questi casi può essere utile utilizzare il comando 
\begin_inset Quotes eld
\end_inset

cut
\begin_inset Quotes erd
\end_inset

 che ci permette di estrarre in modo utile le informazioni da questo tipo
 di file, esempi di utilizzo, sono:
\end_layout

\begin_layout Itemize
cut -f 3 data.txt //stampa la terza colonna del file data.txt, in questo caso
 non viene specificato un delimitatore, di default viene considerato come
 delimitatore il 
\begin_inset Quotes eld
\end_inset

tab
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
cut -f 2-4 data.txt //stampa i campi (colonne) dalla 2 alla 4
\end_layout

\begin_layout Itemize
cut -f 1,3 data.txt //stampa i campi (colonne) 1 e 3
\end_layout

\begin_layout Itemize
cut -f1 -d: /etc/passwd //in questo caso prendiamo solo i primi campi (prima
 colonna) del file /etc/passwd, usando come delimitatore il carattere 
\begin_inset Quotes eld
\end_inset

:
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
cut -f 1,3 -d ':' –output-delimiter=$'
\backslash
t' /etc/passwd //in questo caso vengono stampati i campi 1 e 3, viene usato
 come delimitatore 
\begin_inset Quotes eld
\end_inset

:
\begin_inset Quotes erd
\end_inset

, ma nella stampa il carattere 
\begin_inset Quotes eld
\end_inset

:
\begin_inset Quotes erd
\end_inset

 viene sostituito con un 
\begin_inset Quotes eld
\end_inset

tab
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
cut -c1-3 test.txt //stampa i caratteri dal primo al terzo
\end_layout

\begin_layout Itemize
cut -c2- text.txt //stampa solo i caratteri dal secondo in poi, elimino quindi
 il primo carattere
\end_layout

\begin_layout Subsection
Regular Expressions (o RegEx)
\end_layout

\begin_layout Standard
In theoretical computer science and formal language theory, a regular expression
 (sometimes called a rational expression)[1][2] is a sequence of characters
 that define a search pattern, mainly for use in pattern matching with strings,
 or string matching, i.e.
 "find and replace"-like operations.
 The concept arose in the 1950s, when the American mathematician Stephen
 Kleene formalized the description of a regular language, and came into
 common use with the Unix text processing utilities ed, an editor, and grep,
 a filter.
\end_layout

\begin_layout Standard
Useremo spesso regular expressions, con 
\begin_inset Quotes eld
\end_inset

grep
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

sed
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

awk
\begin_inset Quotes erd
\end_inset

 ed altri programmi, attenzione a non confondere le regular expression con
 le expansion expressions (dette anche globs o shell globbing) utilizzata
 per indicare più file con la shell.
\end_layout

\begin_layout Standard
Leggere le regular expression come 
\begin_inset Quotes eld
\end_inset

cercami il testo che matcha questo pattern
\begin_inset Quotes erd
\end_inset

.
 Vediamo alcuni costrutti di base per poi arrivare ad esempi auto esplicativi.
\end_layout

\begin_layout Subsubsection
Anchors
\end_layout

\begin_layout Standard
Queste sono le anchors:
\end_layout

\begin_layout Itemize
^ //indica l'inizio di una linea o di una stringa
\end_layout

\begin_layout Itemize
$ //indica la fine di una stringa o di una linea
\end_layout

\begin_layout Subsubsection
Quantifiers
\end_layout

\begin_layout Itemize
* //0 or more 
\end_layout

\begin_layout Itemize
{3} //Exactly 3 
\end_layout

\begin_layout Itemize
+ //1 or more 
\end_layout

\begin_layout Itemize
{3,} //3 or more 
\end_layout

\begin_layout Itemize
? //0 or 1 
\end_layout

\begin_layout Itemize
{3,5} //3, 4 or 5 (so at least 3 and at maximum 5)
\end_layout

\begin_layout Subsubsection
Character Classes
\end_layout

\begin_layout Standard
Character Classes sono classi di caratteri, come:
\end_layout

\begin_layout Itemize

\backslash
c Control character 
\end_layout

\begin_layout Itemize

\backslash
s White space //questo comprende spazi, tab, eccetera
\end_layout

\begin_layout Itemize

\backslash
S Not white space 
\end_layout

\begin_layout Itemize

\backslash
t //tab, questo è compreso anche in 
\begin_inset Quotes eld
\end_inset


\backslash
s
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize

\backslash
r //carriage return
\end_layout

\begin_layout Itemize

\backslash
n //line feed
\end_layout

\begin_layout Itemize

\backslash
b //inizio o fine di una parola
\end_layout

\begin_layout Itemize

\backslash
< //inizio di una parola
\end_layout

\begin_layout Itemize

\backslash
> //fine di una parola
\end_layout

\begin_layout Itemize

\backslash
d Digit 
\end_layout

\begin_layout Itemize

\backslash
D Not digit 
\end_layout

\begin_layout Itemize

\backslash
w Word 
\end_layout

\begin_layout Itemize

\backslash
W Not word 
\end_layout

\begin_layout Itemize

\backslash
x Hexade­cimal digit 
\end_layout

\begin_layout Itemize

\backslash
O Octal digit
\end_layout

\begin_layout Subsubsection
Range
\end_layout

\begin_layout Standard
Possiamo anche specificare range, ad esempio:
\end_layout

\begin_layout Itemize
[A-Za-z] //include tutti i caratteri maiuscoli e minuscoli
\end_layout

\begin_layout Itemize
[0-9] //include tutte le cifre
\end_layout

\begin_layout Itemize
(foo|bar) //foo OR bar, nota che per sed e vim l'OR si effettua attraverso
 
\begin_inset Quotes eld
\end_inset


\backslash
|
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
.
 //un carattere qualsiasi
\end_layout

\begin_layout Itemize
a.c //a+un carattere qualsiasi+c
\end_layout

\begin_layout Itemize
a..c //a+due caratteri qualsiasi+c
\end_layout

\begin_layout Itemize
.* //qualsiasi cosa
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
l.*k //qualsiasi cosa fino all'ultima 
\begin_inset Quotes eld
\end_inset

k
\begin_inset Quotes erd
\end_inset

 della stringa
\end_layout

\begin_layout Itemize
l.*?k //qualsiasi cosa fino alla successiva
\begin_inset Quotes eld
\end_inset

k
\begin_inset Quotes erd
\end_inset

 , si chiama notazione lazy
\end_layout

\end_deeper
\begin_layout Itemize
[^abc] //un qualsiasi carattere che non appartenga all'insieme indicato,
 questa è una negazione
\end_layout

\begin_layout Itemize
[-_A-Zp] //include i caratteri 
\begin_inset Quotes eld
\end_inset

-
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

_
\begin_inset Quotes erd
\end_inset

, da A a Z e il carattere 
\begin_inset Quotes eld
\end_inset

p
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
[349] //include i caratteri 
\begin_inset Quotes eld
\end_inset

3
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

4
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

9
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
[Ss] //il carattere 
\begin_inset Quotes eld
\end_inset

S
\begin_inset Quotes erd
\end_inset

 e il carattere 
\begin_inset Quotes eld
\end_inset

s
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Attenzione le parentesi quadre possono avere significato opposto se la parentesi
 di apertura è seguita dal carattere 
\begin_inset Quotes eld
\end_inset

^
\begin_inset Quotes erd
\end_inset

, ad esempio:
\end_layout

\begin_layout Itemize
[^abc] //NOT (a OR b OR c), quindi non a o non b o non c, indichiamo un
 carattere che non deve essere uno di questi tre menzionati
\end_layout

\begin_layout Itemize
[^a-z] //indichiamo che il carattere non deve appartenere all'insieme dei
 caratteri minuscoli
\end_layout

\begin_layout Standard
N.B.: Se come carattere vogliamo indicare proprio uno di quelli utilizzati
 nelle regular expressions, allora devo usare l'escape character 
\begin_inset Quotes eld
\end_inset


\backslash

\begin_inset Quotes erd
\end_inset

, facciamo un esempio, nel caso volessi effettuare il match della stringa
 
\begin_inset Quotes eld
\end_inset

192.168.1.1
\begin_inset Quotes erd
\end_inset

, allora la mia regular expression sarebbe 
\begin_inset Quotes eld
\end_inset

192
\backslash
.168
\backslash
.1
\backslash
.1
\begin_inset Quotes erd
\end_inset

, oppure se volessimo effettuare il match di tutte le stringhe comprese
 tra parentesi quadre allora dovremo scrivere 
\begin_inset Quotes eld
\end_inset


\backslash
[.*
\backslash
]
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsubsection
Stringhe POSIX
\end_layout

\begin_layout Itemize
[:upper:] Upper case letters 
\end_layout

\begin_layout Itemize
[:lower:] Lower case letters 
\end_layout

\begin_layout Itemize
[:alpha:] All letters 
\end_layout

\begin_layout Itemize
[:alnum:] Digits and letters 
\end_layout

\begin_layout Itemize
[:digit:] Digits 
\end_layout

\begin_layout Itemize
[:xdigit:] Hexadecimal digits 
\end_layout

\begin_layout Itemize
[:punct:] Punctu­ation 
\end_layout

\begin_layout Itemize
[:blank:] Space and tab 
\end_layout

\begin_layout Itemize
[:space:] Blank characters 
\end_layout

\begin_layout Itemize
[:cntrl:] Control characters 
\end_layout

\begin_layout Itemize
[:graph:] Printed characters 
\end_layout

\begin_layout Itemize
[:print:] Printed characters and spaces 
\end_layout

\begin_layout Itemize
[:word:] Digits, letters and underscore
\end_layout

\begin_layout Subsubsection
Raggruppamenti
\end_layout

\begin_layout Standard
Possiamo effettuare raggruppamenti per poter trattare insiemi di caratteri
 come se fosse uno solo, attraverso le parentesi tonde, vediamo alcuni esempi:
\end_layout

\begin_layout Itemize
a [(caso)(random)] //seleziona la stringa 
\begin_inset Quotes eld
\end_inset

a caso
\begin_inset Quotes erd
\end_inset

 o la stringa 
\begin_inset Quotes eld
\end_inset

a random
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
(John|Harold) Smith //analogo al precedente comando, seleziona la stringa
 
\begin_inset Quotes eld
\end_inset

John Smith
\begin_inset Quotes erd
\end_inset

 oppure 
\begin_inset Quotes eld
\end_inset

Harold Smith
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
John (Reginald)?Smith //seleziona la stringa 
\begin_inset Quotes eld
\end_inset

John Reginald Smith
\begin_inset Quotes erd
\end_inset

 o la stringa 
\begin_inset Quotes eld
\end_inset

John Smith
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
possiamo riferirci agli elementi raggruppati con la sequenza 
\begin_inset Quotes eld
\end_inset

carattere di escape + numero
\begin_inset Quotes erd
\end_inset

, facciamo degli esempi:
\end_layout

\begin_layout Itemize
(
\backslash
b
\backslash
d
\backslash
d
\backslash
d
\backslash
d
\backslash
b).*
\backslash
1 //in questo caso selezioniamo le stringhe che contengono un numero a quattro
 cifre che si ripete almeno due volte 
\end_layout

\begin_layout Itemize
(John) (Smith).*
\backslash
2 
\backslash
1 //in questo caso selezioniamo le stringhe che contengono la stringa 
\begin_inset Quotes eld
\end_inset

John Smith
\begin_inset Quotes erd
\end_inset

 e poi 
\begin_inset Quotes eld
\end_inset

Smith John
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Subsubsection
Lookaheads
\end_layout

\begin_layout Standard
With a lookahead we want to look ahead (hence the name) in our string and
 see if it matches the given pattern, but then disregard it and move on.
 The concept is best illustrated with an example.
\end_layout

\begin_layout Standard
Let's say we wish to identify numbers greater than 4000 but less than 5000.
 This is a problem which seems simple but is in fact a little trickier than
 you suspect.
 A common first attempt is to try the following:
\end_layout

\begin_layout Itemize

\backslash
b4
\backslash
d
\backslash
d
\backslash
d
\backslash
b //this will match all the numbers between 4000 and 4999, but we don't
 want to include the number 4000
\end_layout

\begin_layout Standard
this can be easily managed with lookaheads which impose 
\begin_inset Quotes eld
\end_inset

if
\begin_inset Quotes erd
\end_inset

 conditions, for example:
\end_layout

\begin_layout Itemize

\backslash
b4(?!000)
\backslash
d
\backslash
d
\backslash
d
\backslash
b //in this way we are telling with our regex that if after the 4 there
 is 
\begin_inset Quotes eld
\end_inset

000
\begin_inset Quotes erd
\end_inset

 then we don't have to match the string, in plain english we could say:
 "We are looking for a '4' which is not followed by 3 '0's but is followed
 by 3 digits".
\end_layout

\begin_layout Standard
This is a negative lookahead, since we are not considering the expression
 who match the condition, anyway there are even the so called 
\begin_inset Quotes eld
\end_inset

positive lookaheads
\begin_inset Quotes erd
\end_inset

, which will mean 
\begin_inset Quotes eld
\end_inset

match this expression, only if this condition is satisfied
\begin_inset Quotes erd
\end_inset

, for a positive lookahead, the syntax is 
\begin_inset Quotes eld
\end_inset

(?=charactersToMatch)
\begin_inset Quotes erd
\end_inset

 instead of 
\begin_inset Quotes eld
\end_inset

(?=charactersToNotMatch)
\begin_inset Quotes erd
\end_inset

, all we need is to replace the character 
\begin_inset Quotes eld
\end_inset

!
\begin_inset Quotes erd
\end_inset

 with the character 
\begin_inset Quotes eld
\end_inset

=
\begin_inset Quotes erd
\end_inset

, anche se i lookahead positivi sono meno usati.
\end_layout

\begin_layout Subsubsection
Lookbehinds
\end_layout

\begin_layout Standard
Possiamo anche cercare a ritroso attraverso i lookbehinds, anche in questo
 caso esistono sia lookbehind positive che negative e si indicano con la
 sintassi:
\end_layout

\begin_layout Itemize
(?<=x) per lookbehind positive
\end_layout

\begin_layout Itemize
(?<!x) per lookbehind negative
\end_layout

\begin_layout Standard
Let's say we would like to find instances of the name 'Smith' but only if
 they are a surname.
 To achieve this we have said that we want to look at the word before it
 and if that word begins with a capital letter we'll assume it is a surname
 (the more astute of you will have already seen the flaw in this, ie what
 if Smith is the second word in a sentence, but we'll ignore that for now.)
\end_layout

\begin_layout Itemize
(?<=[A-Z]
\backslash
w* )Smith //Now we won't identify Smith Francis but we will identify Harold
 Smith.
 
\end_layout

\begin_layout Subsubsection
Esempi per capire
\end_layout

\begin_layout Itemize
^
\backslash
s //tutte le righe che cominciano con una spaziatura o con un tab
\end_layout

\begin_layout Itemize
^
\backslash
s+#|^# //tutte le righe che cominciano con uno o più spazi/tablature e poi
 il carattere 
\begin_inset Quotes eld
\end_inset

#
\begin_inset Quotes erd
\end_inset

 oppure le stringhe che cominciano con il carattere 
\begin_inset Quotes eld
\end_inset

#
\begin_inset Quotes erd
\end_inset

, questo è utile per isolare un commento ad esempio nei bash script, attenzione
 la stesura di 
\begin_inset Quotes eld
\end_inset

^
\backslash
s#|^#
\begin_inset Quotes erd
\end_inset

 non avrebbe tenuto conto di commenti posizionati dopo più di uno spazio/tablatu
ra
\end_layout

\begin_layout Itemize
<[^>].*> //seleziono tutte le stringhe come 
\begin_inset Quotes eld
\end_inset

<qualsiasicosa>
\begin_inset Quotes erd
\end_inset

 ma senza ad esempio stringhe come 
\begin_inset Quotes eld
\end_inset

<>
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
[0-9]{1,3}
\backslash
.[0-9]{1,3}
\backslash
.[0-9]{1,3}
\backslash
.[0-9]{1,3} //in questo caso riusciamo a selezionare gli indirizzi IP
\end_layout

\begin_layout Itemize

\backslash
b(
\backslash
d{1,3}
\backslash
.){3}
\backslash
d{1,3}
\backslash
b //modo più furbo per selezionare gli indirizzi IP
\end_layout

\begin_layout Itemize
^b[alu]t$ //selezioniamo le righe che contengono solo una stringa che inizia
 per 
\begin_inset Quotes eld
\end_inset

b
\begin_inset Quotes erd
\end_inset

, finisce per 
\begin_inset Quotes eld
\end_inset

t
\begin_inset Quotes erd
\end_inset

 e contiene solo un carattere nel mezzo che può essere o 
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

 o 
\begin_inset Quotes eld
\end_inset

l
\begin_inset Quotes erd
\end_inset

 o 
\begin_inset Quotes eld
\end_inset

u
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Subsection
Grep, Egrep ed Fgrep
\end_layout

\begin_layout Standard
Grep è un programma utilizzato generalmente per ricercare testo o pattern
 specifici, per utilizzare le regular expressions, dobbiamo ricordare di
 utilizzare il flag 
\begin_inset Quotes eld
\end_inset

-P
\begin_inset Quotes erd
\end_inset

 e per evitare conflitti è buona norma sempre utilizzare apici singoli come
 argomento stringa di grep.
 Alcuni esempi di utilizzo di grep possono essere:
\end_layout

\begin_layout Itemize
grep stringaDaCercare nomeFile //per cercare la stringa stringaDaCercare
 all'interno del file nomeFile
\end_layout

\begin_layout Itemize
grep -i stringaDaCercare nomeFile //in questo caso, ignoro il fatto che
 stringaDaCercare sia maiuscola o minuscola, effettuo una ricerca case-insensiti
ve
\end_layout

\begin_layout Itemize
grep -A4 stringaDaCercare nomeFile //cerca stringaDaCercare in nomeFile
 e stampa la riga contenente la stringa più le 4 righe successive (il flag
 
\begin_inset Quotes eld
\end_inset

-A
\begin_inset Quotes erd
\end_inset

 sta per 
\begin_inset Quotes eld
\end_inset

after
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Itemize
grep -B4 stringaDaCercare nomeFile //cerca stringaDaCercare in nomeFile
 e stampa la riga contenente la stringa più le 4 righe precedenti (il flag
 
\begin_inset Quotes eld
\end_inset

-B
\begin_inset Quotes erd
\end_inset

 sta per 
\begin_inset Quotes eld
\end_inset

before
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Itemize
grep -w 'M' //in questo caso viene cercata proprio una parola isolata M,
 'w' sta per 
\begin_inset Quotes eld
\end_inset

word
\begin_inset Quotes erd
\end_inset

, ad esempio nel caso dovessimo cercare la cartella 'M' e non avere in output
 tutte le cartelle che contengono la parola M possiamo usare 
\begin_inset Quotes eld
\end_inset

ls -l | grep M
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
grep -c hello nomeFile //mi dice quante volte la parola 
\begin_inset Quotes eld
\end_inset

hello
\begin_inset Quotes erd
\end_inset

 è contenuta nel file nomeFile
\end_layout

\begin_layout Itemize
grep [bde] nomeFile //evidenzia tutti i caratteri b, d ed e all'interno
 del file nomeFile
\end_layout

\begin_layout Itemize
grep -P '
\backslash
b4(?!000)[[:digit:]]{3}
\backslash
b' nomeFile //cerca tutte le stringhe che contengono numeri compresi tra
 4000 e 5000 (estremi esclusi)
\end_layout

\begin_layout Itemize
grep –color=auto keyword nomeFile //in questo modo la stringa cercata verrà
 evidenziata con un colore diverso (molto utile!)
\end_layout

\begin_layout Standard
E' possibile anche utilizzare regular expressions complesse utilizzando
 il flag 
\begin_inset Quotes eld
\end_inset

-P
\begin_inset Quotes erd
\end_inset

 per feature più avanzate (tipo lookaheads e lookbehinds) come: 
\end_layout

\begin_layout Itemize
'^word' che significa, le linee che iniziano con la parola 
\begin_inset Quotes eld
\end_inset

word
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
'word$' che significa, le linee che finiscono per 
\begin_inset Quotes eld
\end_inset

word
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
grep [a-g] testf //in questo esempio, vengono evidenziati tutti i caratteri
 compresi tra la 
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

 e la 
\begin_inset Quotes eld
\end_inset

g
\begin_inset Quotes erd
\end_inset

 nel file testf
\end_layout

\begin_layout Itemize
grep ^[a-g] testf //in questo esempio, vengono evidenziate le parole che
 finiscono per uno dei caratteri compresi tra la 
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

 la 
\begin_inset Quotes eld
\end_inset

g
\begin_inset Quotes erd
\end_inset

 all'interno del file testf
\end_layout

\begin_layout Itemize
grep -f grepinput testf //prende come input pattern, il contenuto del file1
 per ricercare all'interno di file2
\end_layout

\begin_layout Itemize
grep -r 'modules' .
 //a partire dalla corrente directory scandisce ogni file con all'interno
 la parola 
\begin_inset Quotes eld
\end_inset

modules
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
grep -v 'permission denied' //mostra tutte le stringhe che non contengono
 la stringa indicata, quindi il flag 
\begin_inset Quotes eld
\end_inset

-v
\begin_inset Quotes erd
\end_inset

 è il flag di negazione, utile per cercare stringhe che non contengono quella
 voce
\end_layout

\begin_layout Itemize
grep -n 'word' //esegue un normale grep, ma indica il numero di linea a
 cui è stata trovata la parola cercata
\end_layout

\begin_layout Itemize
grep -nir 'word' .
 //a partire dalla corrente directory scandisce ogni file con all'interno
 la parola 
\begin_inset Quotes eld
\end_inset

word
\begin_inset Quotes erd
\end_inset

 non è case sensitive ed indica il numero di linea a cui è stata trovata
 la parola menzionata
\end_layout

\begin_layout Itemize
grep -lr cron /etc //elenca tutti i file che contengono la parola 
\begin_inset Quotes eld
\end_inset

cron
\begin_inset Quotes erd
\end_inset

 all'interno del loro nome all'interno della directory 
\begin_inset Quotes eld
\end_inset

/etc
\begin_inset Quotes erd
\end_inset

, il flag 
\begin_inset Quotes eld
\end_inset

l
\begin_inset Quotes erd
\end_inset

 sta per list o elenca, mentre il flag 
\begin_inset Quotes eld
\end_inset

r
\begin_inset Quotes erd
\end_inset

 permette di effettuare l'operazione ricorsivamente in tutte le sottodirectory
 di /etc.
\end_layout

\begin_layout Itemize
grep -F -x -v -f fileB fileA //mostra tutte le righe di A senza le righe
 nel file B; this works by using each line in fileB as a pattern (-f fileB)
 and treating it as a plain string to match (not a regular regex) (-F).
 You force the match to happen on the whole line (-x) and print out only
 the lines that don't match (-v).
 Therefore you are printing out the lines in fileA that don't contain the
 same data as any line in fileB.
 Un'alternativa a questo è 
\begin_inset Quotes eld
\end_inset

comm <(sort a) <(sort b) -3
\begin_inset Quotes erd
\end_inset

 che stampa le righe di differenza tra i due file 
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

b
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Itemize
grep -aob 
\begin_inset Quotes eld
\end_inset

y
\begin_inset Quotes erd
\end_inset

 file.txt //mostra tutte le posizioni in cui compare la lettera 
\begin_inset Quotes eld
\end_inset

y
\begin_inset Quotes erd
\end_inset

 nel file chiamato file.txt
\end_layout

\begin_layout Standard
N.B.: Quando si vogliono usare regex complesse, oltre ad usare il flag 
\begin_inset Quotes eld
\end_inset

-P
\begin_inset Quotes erd
\end_inset

 (che comunque provoca conflitti se usato con egrep) dobbiamo mettere la
 stringa tra singoli apici e non tra doppi apici, per sicurezza possiamo
 comunque mettere sempre le stringhe di grep tra singoli apici nel dubbio.
\end_layout

\begin_layout Standard
We can use it to include/exclude the list of pictures from a website with
 
\begin_inset Quotes eld
\end_inset

grep ^=
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Ci sono due varianti del comando grep:
\end_layout

\begin_layout Itemize
egrep //equivalente ad eseguire un 
\begin_inset Quotes eld
\end_inset

grep -E
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
fgrep //equivalente ad eseguire un 
\begin_inset Quotes eld
\end_inset

grep -F
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Egrep è utilizzato per includere forme complesse di regular expressions
 (chiamate extended regular expressions).
 Vediamo alcuni esempi:
\end_layout

\begin_layout Itemize
egrep -i 'hello.*world' testf //mostra tutte le linee che contengono sia
 la parola hello che la parola world (come un'operazione AND logica) all'interno
 del file testf, il flag 
\begin_inset Quotes eld
\end_inset

-i
\begin_inset Quotes erd
\end_inset

 indica la modalità case-insensitive
\end_layout

\begin_layout Itemize
egrep -i 'hello|world' testf //mostra tutte le linee che contengono o la
 parola hello o la parola world (come un'operazione OR logica) all'interno
 del file testf, il flag 
\begin_inset Quotes eld
\end_inset

-i
\begin_inset Quotes erd
\end_inset

 anche in questo caso indica la modalità case-insensitive
\end_layout

\begin_layout Itemize
egrep -v 'hello|world' testfile //mostra tutte le linee che non contengono
 la parola hello o la parola world, quindi il flag 
\begin_inset Quotes eld
\end_inset

-v
\begin_inset Quotes erd
\end_inset

 effettua l'operazione negata rispetto a quella che verrebbe effettuata
 di default
\end_layout

\begin_layout Standard
Fgrep è una forma di grep utile a cercare stringhe senza tener conto delle
 regular expression, quindi viene cercata la stringa così come scritta senza
 interpretare caratteri come 
\begin_inset Quotes eld
\end_inset

.
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

|
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

$
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

*
\begin_inset Quotes erd
\end_inset

, eccetera come caratteri speciali, vediamo qualche esempio:
\end_layout

\begin_layout Itemize
fgrep *hello$ testf //cerca esattamente la parola 
\begin_inset Quotes eld
\end_inset

*hello$
\begin_inset Quotes erd
\end_inset

 senza intenderla come 
\begin_inset Quotes eld
\end_inset

regular expression
\begin_inset Quotes erd
\end_inset

, quindi i simboli speciali non verranno intesi come caratteri jolly, comunque
 tutto è fattibile da grep in quanto possiamo usare gli escape characters,
 quindi la stessa cosa con grep sarebbe stata 
\begin_inset Quotes eld
\end_inset

grep '
\backslash
*hello
\backslash
$' testf
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Subsection
Sed
\end_layout

\begin_layout Standard
Sed è una utility sui sistemi GNU/Linux utilizzata per effettuare elaborazioni
 su file di testo, questa utility fa uso di un linguaggio di programmazione
 compatto per effettuare le proprie operazioni, riceve un testo come input,
 o dallo stdin o da un file, esegue alcune operazioni sulle righe specificate,
 una alla volta, quindi invia il risultato allo stdout o in un file.
 Negli script di shell, sed è, di solito, una delle molte componenti di
 una pipe.
 Solitamente viene invocato per modificare flussi di testo o elaborarli
 in genere con una o due righe, a differenza di Awk che rappresenta un linguaggi
o più complesso con cui vengono scritti veri e propri script.
 Sed determina le righe dell'input, su cui deve operare, tramite un indirizzo
 che gli è stato passato.
 Questo indirizzo può essere rappresentato sia da un numero di riga sia
 da una verifica d'occorrenza.
 Ad esempio, 3d indica a sed di cancellare la terza riga dell'input, mentre
 /windows/d segnala a sed che si vogliono cancellare tutte le righe dell'input
 contenenti l'occorrenza "windows".
 Di tutte le operazioni a disposizione di sed, vengono focalizzate, in primo
 luogo, le tre più comunemente usate.
 Esse sono:
\end_layout

\begin_layout Itemize
p->print (visualizza allo stdout), 
\end_layout

\begin_layout Itemize
d->delete (cancella)
\end_layout

\begin_layout Itemize
s->substitute (sostituisce)
\end_layout

\begin_layout Standard
Esempi di utilizzo, possono essere:
\end_layout

\begin_layout Itemize
sed -e '1d' /etc/services | more //elimina la prima riga, il 
\begin_inset Quotes eld
\end_inset

-e
\begin_inset Quotes erd
\end_inset

 indica di eseguire un comando, anche se nel caso venisse usato un solo
 comando possiamo ometterlo
\end_layout

\begin_layout Itemize
sed -e '1,10d' /etc/services | more //elimina le righe dalla 1 alla 10 nel
 file menzionato
\end_layout

\begin_layout Itemize
sed -n -e '1,10p' nomeFile | more //in questo caso vengono stampate solo
 le righe dalla 1 alla 10, usiamo il flag 
\begin_inset Quotes eld
\end_inset

-n
\begin_inset Quotes erd
\end_inset

 in quanto quando vogliamo stampare le righe col comando 
\begin_inset Quotes eld
\end_inset

p
\begin_inset Quotes erd
\end_inset

 è buona norma, anzichè verrà comunque stampato tutto il file
\end_layout

\begin_layout Itemize
sed -n 
\begin_inset Quotes eld
\end_inset

3p
\begin_inset Quotes erd
\end_inset

 nomeFile //stampa la terza riga del file
\end_layout

\begin_layout Itemize
sed -n -e '/BEGIN/,/END/p' /my/test/file | more //stampa il file dalla riga
 che contiene 
\begin_inset Quotes eld
\end_inset

BEGIN
\begin_inset Quotes erd
\end_inset

 fino alla riga che contiene 
\begin_inset Quotes eld
\end_inset

END
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
sed -n -e '/main
\backslash
s*(/,/^}/p' nomeFile //stampa la funzione main di un file
\end_layout

\begin_layout Itemize
sed 's/male/malissimo/' mioFile //stampa a schermo (cioè standard output)
 il file 
\begin_inset Quotes eld
\end_inset

mioFile
\begin_inset Quotes erd
\end_inset

 con la parola malissimo al posto della parola male (viene effettuata una
 sola sostituzione per riga), nota che le sostituzioni non vanno a sovrascrivere
 il file, e non viene salvato nemmeno un nuovo file con la parola sostituita,
 per farlo dovremmo usare invece i redirect
\end_layout

\begin_layout Itemize
sed 's/male/malissimo/g' mioFile //stampa a schermo (cioè standard output)
 il file 
\begin_inset Quotes eld
\end_inset

mioFile
\begin_inset Quotes erd
\end_inset

 con la parola malissimo al posto della parola male vengono effettuate tutte
 le sostituzioni possibili nota che le sostituzioni non vanno a sovrascrivere
 il file, e non viene salvato nemmeno un nuovo file con la parola sostituita,
 per farlo dovremmo usare invece i redirect
\end_layout

\begin_layout Itemize
sed -e 's:/usr/local:/usr:g' mylist.txt //avviene una sostituzione,ma questa
 volta come delimitatori usiamo il carattere 
\begin_inset Quotes eld
\end_inset

:
\begin_inset Quotes erd
\end_inset

, in quanto lo slash 
\begin_inset Quotes eld
\end_inset

/
\begin_inset Quotes erd
\end_inset

 è utilizzato nelle stringhe interessate nella sostituzione
\end_layout

\begin_layout Itemize
sed 's/male/malissimo/' mioFile > mioFileNuovo //effettua la stessa operazione
 precedente ma salva quello che viene stampato sullo standard output in
 nuovo file chiamato 
\begin_inset Quotes eld
\end_inset

mioFileNuovo
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
sed 's/partitime/fulltime/w promotions.txt' team //sostituisce la parola
 
\begin_inset Quotes eld
\end_inset

parttime
\begin_inset Quotes erd
\end_inset

 con la parola 
\begin_inset Quotes eld
\end_inset

fulltime
\begin_inset Quotes erd
\end_inset

 (ma solo un'occorrenza per linea) e sovrascrive i cambiamenti attraverso
 il flag 
\begin_inset Quotes eld
\end_inset

-w
\begin_inset Quotes erd
\end_inset

 nel file 
\begin_inset Quotes eld
\end_inset

promotions.txt
\begin_inset Quotes erd
\end_inset

, mentre l'operazione viene fatta prednendo come riferimento il file 
\begin_inset Quotes eld
\end_inset

team
\begin_inset Quotes erd
\end_inset

.
 Ricorda di redirigere l'output al buco nero /dev/null se non si vuole vedere
 nulla sullo standard output
\end_layout

\begin_layout Itemize
sed -e 's/
\backslash
(.*
\backslash
) 
\backslash
(.*
\backslash
) 
\backslash
(.*
\backslash
)/Victor 
\backslash
1 
\backslash
2 Von 
\backslash
3/' myfile.txt //in questo caso definiamo delle regioni di interesse all'interno
 del file attraverso delle parentesi backslashate e ci riferiamo a queste
 regioni con dei numeri backslashati
\end_layout

\begin_layout Itemize
sed -e 's/.*/ralph said: &/' origmsg.txt //in questo caso aggiungiamo all'inizio
 di ogni riga la stringa 
\begin_inset Quotes eld
\end_inset

ralph said: 
\begin_inset Quotes eld
\end_inset


\end_layout

\begin_layout Itemize
sed -e '1,10s/enchantment/entrapment/g' myfile2.txt //effettua la sostituzione
 solo tra la riga 1 e la riga 10
\end_layout

\begin_layout Itemize
sed -n 5p nomeFile //stampa la riga 5 del file menzionato
\end_layout

\begin_layout Itemize
sed -n '10,20p' nomeFile //stampa a schermo tutte le linee tra la 10 e la
 20 del file menzionato
\end_layout

\begin_layout Itemize
sed -n '10,$p' nomeFile //stampa a schermo tutte le linee dalla 10 in poi
 del file menzionato
\end_layout

\begin_layout Itemize
sed -i 8d nomeFile //elimina la riga 8 del file menzionato
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

sed '0,/parttime/s/parttime/promotion/' team //sostituisce la zero-esima
 occorrenza della parola 
\begin_inset Quotes eld
\end_inset

parttime
\begin_inset Quotes erd
\end_inset

 con la parola 
\begin_inset Quotes eld
\end_inset

promotion
\begin_inset Quotes erd
\end_inset

 and this means substitute 
\begin_inset Quotes eld
\end_inset

the zero-th occurrence of the word parttime with promotion in the file team.
\end_layout

\begin_layout Standard
Per elaborazioni più complesse valgono anche le regular expressions, ad
 esempio per rimuovere testo 
\begin_inset Quotes eld
\end_inset

html
\begin_inset Quotes erd
\end_inset

, possiamo effettuare un:
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

sed 's/<[^>]*>//' team
\begin_inset Quotes erd
\end_inset

 //rimuove tutte le parole che iniziano per il carattere 
\begin_inset Quotes eld
\end_inset

<
\begin_inset Quotes erd
\end_inset

 e che non sono seguite dal carattere 
\begin_inset Quotes eld
\end_inset

>
\begin_inset Quotes erd
\end_inset

 e che hanno qualsiasi stringa seguita dal carattere 
\begin_inset Quotes eld
\end_inset

>
\begin_inset Quotes erd
\end_inset

.
 Ricorda che l'espressione regolare [^a] significa 
\begin_inset Quotes eld
\end_inset

non le linee che continuano col carattere 'a'
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Ad ogni modo una sostituzione globale di tutte le occorrenze di una parola
 con un'altra è possibile ad esempio attraverso:
\end_layout

\begin_layout Itemize
sed 's/wordtochange/wantedword/g' myfile.txt > newfile.txt //sostituisce tutte
 le occorrenze della parola wordtochange con la parola wantedword, questo
 avviene grazie all'utilizzo del flag 
\begin_inset Quotes eld
\end_inset

-g
\begin_inset Quotes erd
\end_inset

 che sta per 
\begin_inset Quotes eld
\end_inset

globally
\begin_inset Quotes erd
\end_inset

 (o globalmente), nel caso questo flag non fosse presente allora avverrebbe
 un'unica sostituzione per riga
\end_layout

\begin_layout Standard
Possiamo usare file esterni in cui mettiamo i nostri comandi, nel caso dovessimo
 eseguire più comandi sed, e poi richiamarli da un'istruzione tipo:
\end_layout

\begin_layout Itemize
sed -n -f mycommands.sed myfile.txt //esegue lo script sed, definito dalla
 serie di comandi in mycommands.sed sul file menzionato 
\begin_inset Quotes eld
\end_inset

myfile.txt
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
possiamo usare sed anche per rinominare tutti i file con spazi mettendo
 degli underscore, ad esempio con:
\end_layout

\begin_layout Itemize
ls | while read file; do echo 
\begin_inset Quotes eld
\end_inset

$file
\begin_inset Quotes erd
\end_inset

|sed -e '$/
\backslash
 /_/g' ; done //sostituisce nei nomi dei file gli spazi con degli underscore
\end_layout

\begin_layout Subsubsection
Sed Scripts
\end_layout

\begin_layout Standard
Vediamo ora esempi di script sed, questi ci permettono una flessibilità
 maggiore, vediamo ad esempio come effettuare sostituzioni multiple:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

1,20{         
\end_layout

\begin_layout Plain Layout

	s/[Ll]inux/GNU
\backslash
/Linux/g         
\end_layout

\begin_layout Plain Layout

	s/samba/Samba/g         
\end_layout

\begin_layout Plain Layout

	s/posix/POSIX/g 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
in questo caso verranno effettuate tutte le sostituzioni indicate tra la
 riga 1 alla riga 20, ovviamente al posto dei numeri possiamo inserire anche
 delle regular expressions.
\end_layout

\begin_layout Standard
Vediamo un altro esempio:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

1,/^END/{         
\end_layout

\begin_layout Plain Layout

	s/[Ll]inux/GNU
\backslash
/Linux/g          
\end_layout

\begin_layout Plain Layout

	s/samba/Samba/g          
\end_layout

\begin_layout Plain Layout

	s/posix/POSIX/g         
\end_layout

\begin_layout Plain Layout

	p 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
in questo caso verranno effettuate tutte le sostituzioni tra la riga 1 e
 la riga che inizia per 
\begin_inset Quotes eld
\end_inset

END
\begin_inset Quotes erd
\end_inset

 oppure se questa non si trova, le modifiche vanno fino a fine file, notare
 il comando p alla fine che stampa le righe.
\end_layout

\begin_layout Paragraph
Append, Insert and Change
\end_layout

\begin_layout Standard
Ora che scriviamo script possiamo utilizzare ulteriori features di sed.
 Possiamo aggiungere una riga prima di ogni altra riga del file (o quelle
 specificate dall'address)attraverso:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

i
\backslash
 
\end_layout

\begin_layout Plain Layout

This line will be inserted before each line
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Possiamo oppure mettere in append determinate stringhe con:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

a
\backslash
 
\end_layout

\begin_layout Plain Layout

insert this line after each line.
  Thanks! :)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Oppure possiamo cambiare completamente le linee con:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

c
\backslash
 
\end_layout

\begin_layout Plain Layout

You're history, original line! Muhahaha!
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Let's see a more complex script:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

1d 
\end_layout

\begin_layout Plain Layout

/^^/d
\end_layout

\begin_layout Plain Layout

s/[[:cntrl:]]//g
\end_layout

\begin_layout Plain Layout

/^D/ {   
\end_layout

\begin_layout Plain Layout

		s/^D
\backslash
(.*
\backslash
)/
\backslash
1
\backslash
tOUTY
\backslash
tINNY
\backslash
t/         
\end_layout

\begin_layout Plain Layout

		s/^01/Jan/         
\end_layout

\begin_layout Plain Layout

		s/^02/Feb/         
\end_layout

\begin_layout Plain Layout

		s/^03/Mar/         
\end_layout

\begin_layout Plain Layout

		s/^04/Apr/         
\end_layout

\begin_layout Plain Layout

		s/^05/May/         
\end_layout

\begin_layout Plain Layout

		s/^06/Jun/         
\end_layout

\begin_layout Plain Layout

		s/^07/Jul/         
\end_layout

\begin_layout Plain Layout

		s/^08/Aug/         
\end_layout

\begin_layout Plain Layout

		s/^09/Sep/         
\end_layout

\begin_layout Plain Layout

		s/^10/Oct/         
\end_layout

\begin_layout Plain Layout

		s/^11/Nov/         
\end_layout

\begin_layout Plain Layout

		s/^12/Dec/         
\end_layout

\begin_layout Plain Layout

		s:^
\backslash
(.*
\backslash
)/
\backslash
(.*
\backslash
)/
\backslash
(.*
\backslash
):
\backslash
2 
\backslash
1 
\backslash
3:  
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Common Sed Commands Vademecum
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

# sed
\end_layout

\begin_layout Plain Layout

> Run replacements based on regular expressions.
\end_layout

\begin_layout Plain Layout

- Replace the first occurrence of a string in a file, and print the result:
\end_layout

\begin_layout Plain Layout

`sed 's/{{find}}/{{replace}}/' {{filename}}`
\end_layout

\begin_layout Plain Layout

- Replace all occurrences of an extended regular expression in a file:
\end_layout

\begin_layout Plain Layout

`sed -r 's/{{regex}}/{{replace}}/g' {{filename}}`
\end_layout

\begin_layout Plain Layout

- Replace all occurrences of a string in a file, overwriting the file (i.e.
 in-place):
\end_layout

\begin_layout Plain Layout

`sed -i 's/{{find}}/{{replace}}/g' {{filename}}`
\end_layout

\begin_layout Plain Layout

- Replace only on lines matching the line pattern:
\end_layout

\begin_layout Plain Layout

`sed '/{{line_pattern}}/s/{{find}}/{{replace}}/' {{filename}}`
\end_layout

\begin_layout Plain Layout

- Apply multiple find-replace expressions to a file:
\end_layout

\begin_layout Plain Layout

`sed -e 's/{{find}}/{{replace}}/' -e 's/{{find}}/{{replace}}/' {{filename}}`
\end_layout

\begin_layout Plain Layout

- Replace separator / by any other character not used in the find or replace
 patterns, e.g., #:
\end_layout

\begin_layout Plain Layout

`sed 's#{{find}}#{{replace}}#' {{filename}}` 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Awk
\end_layout

\begin_layout Itemize
awk '{ print $2 }' //stampa il secondo campo di dati spaziati da uno spazio
 generico, mooolto utile!
\end_layout

\begin_layout Itemize
awk -F 
\begin_inset Quotes eld
\end_inset

#
\begin_inset Quotes erd
\end_inset

 '{print $1 $NF}' //le colonne vengono divise dal separatore 
\begin_inset Quotes eld
\end_inset

#
\begin_inset Quotes erd
\end_inset

 e viene stampata la prima colonna, e l'ultima colonna
\end_layout

\begin_layout Itemize
awk -F 
\begin_inset Quotes eld
\end_inset

.
\begin_inset Quotes erd
\end_inset

 '{print $NF 
\begin_inset Quotes eld
\end_inset

,
\begin_inset Quotes erd
\end_inset

 $(NF-1)}' //le colonne vengono divise dal separatore 
\begin_inset Quotes eld
\end_inset

.
\begin_inset Quotes erd
\end_inset

 e viene stampata l'ultima colonna, e la penultima colonna, spaziati da
 una virgola
\end_layout

\begin_layout Itemize
awk '{ sub("
\backslash
r$", ""); print }' windows.txt > unix.txt //To convert a Windows file to a
 UNIX file, enter the following command
\end_layout

\begin_layout Itemize
awk 'sub("$", "
\backslash
r")' uniz.txt > windows.txt //To convert a UNIX text file called “unix.txt”
 to a Windows text file called “windows.txt”, enter the following command
\end_layout

\begin_layout Itemize
awk 'FNR == 2 {print}' //stampa la seconda riga
\end_layout

\begin_layout Itemize
awk 'FNR == 5 {print $3}' //stampa il tezo campo della quinta riga
\end_layout

\begin_layout Section
Gestione dei File su GNU/Linux
\end_layout

\begin_layout Subsection
Tipologie di File
\end_layout

\begin_layout Standard
Nei sistemi GNU/Linux esistono diverse tipologie di file, uno schema può
 essere visionato nella tabella sottostante:
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tipo di File 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Descrizione
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
file regolare 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
file che contiene dei dati (l'accezione normale di file)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
cartella o direttorio 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
file che contiene una lista di nomi associati a degli inode
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
collegamento simbolico
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
file che contiene un riferimento ad un altro file/directory
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
dispositivo a caratteri
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
file che identifica una periferica ad accesso a caratteri
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
dispositivo a blocchi
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
file che identifica una periferica ad accesso a blocchi
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
“coda” (o fifo)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
file speciale che identifica una linea di comunicazione software unidirezionale
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
“presa” (o socket)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
file speciale che identifica una linea di comunicazione software bidirezionale
 
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Tipi di File con relativa descrizione
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Le tipologie per noi di maggiore interesse sono le prime tre, siccome conosciamo
 già abbastanza bene il concetto di file e il concetto di directory, nella
 prossima sezione parleremo di collegamenti (o link).
\end_layout

\begin_layout Subsection
Soft Link e Hard link
\end_layout

\begin_layout Standard
Esistono due modalità per creare dei collegamenti (o 
\begin_inset Quotes eld
\end_inset

link
\begin_inset Quotes erd
\end_inset

) sui sistemi GNU/Linux:
\end_layout

\begin_layout Itemize
Soft Link
\end_layout

\begin_layout Itemize
Hard Link
\end_layout

\begin_layout Standard
le uniche differenze sono:
\end_layout

\begin_layout Itemize
Gli hard link possono vivere solo sullo stesso filesystem
\end_layout

\begin_layout Itemize
Se rimuovo una copia di un hard link, l'altra continua a sopravvivere
\end_layout

\begin_layout Itemize
Nel caso di soft link, se rimuovo la copia originale, l'altra muore
\end_layout

\begin_layout Standard
Gli Hard Link sono simili ad una copia, ma si aggiornano quando viene effettuata
 una modifica su uno dei link.
 Per creare un Hard Link facciamo:
\end_layout

\begin_layout Itemize
ln sourceFile nameofTheHardLink //crea un hard link
\end_layout

\begin_layout Standard
Per creare un Soft Link facciamo:
\end_layout

\begin_layout Itemize
ln -s sourceFile nameOfTheSoftLink //crea un soft link
\end_layout

\begin_layout Standard
Esistono ovviamente anche altri flag aggiuntivi che possono essere utilizzati
 ad esempio:
\end_layout

\begin_layout Itemize
-i //chiede conferma prima della creazione
\end_layout

\begin_layout Itemize
-f //forza la creazione di un link
\end_layout

\begin_layout Standard
Per rimuovere un link basta effettuare:
\end_layout

\begin_layout Itemize
unlink nomeFileODirectory //rimuove il link al file o alla directory
\end_layout

\begin_layout Standard
ATTENZIONE: non provare assolutamente a rimuovere link a directory utilizzando
 rm -R sul link della directory, questo provocherà la rimozione dei file
 reali e non del link.
\end_layout

\begin_layout Subsection
Cercare File in GNU/Linux
\end_layout

\begin_layout Standard
I comandi più comunemente utilizzati per cercare file su linux sono:
\end_layout

\begin_layout Itemize
find
\end_layout

\begin_layout Itemize
locate
\end_layout

\begin_layout Standard
Anche se è possibile effettuare ricerche di file anche con un appropriato
 utilizzo dei comandi 
\begin_inset Quotes eld
\end_inset

grep
\begin_inset Quotes erd
\end_inset

 ed 
\begin_inset Quotes eld
\end_inset

ls
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsubsection
Find
\end_layout

\begin_layout Standard
Vediamo alcuni esempi di applicazione del programma find:
\end_layout

\begin_layout Itemize
find /etc -name motd //questo comando cercherà nella directory /etc (e sue
 sottodirectory) un file che ha nel nome la parola 
\begin_inset Quotes eld
\end_inset

motd
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
il comando find è lento (rispetto a locate), ma molto efficace in quando
 scandisce i file uno ad uno.
 E' molto probabile non avere i permessi di lettura in alcune directory
 (almenochè non si è l'utente root) in questo caso, vedremo molti messaggi
 a schermo provenienti dallo standard error, per evitare di stampare questi
 messaggi a schermo possiamo fare uso del seguente comando:
\end_layout

\begin_layout Itemize
find /etc -name motd 2>/dev/null
\end_layout

\begin_layout Standard
Altri esempi di applicazione del comando find possono essere:
\end_layout

\begin_layout Itemize
find /home/john -name 
\begin_inset Quotes eld
\end_inset

*.jpg
\begin_inset Quotes erd
\end_inset

 //cerca nella directory /home/john, tutti i file con estensione .jpg
\end_layout

\begin_layout Itemize
find /etc -perm 777 //cerca nella directory /etc tutti i file con permessi
 777, questa operazione potrebbe essere utile per salvaguardare la macchina,
 in modo da non esporre a tutti, file sensibili.
\end_layout

\begin_layout Standard
Un'altra utile possibilità risiede nel poter effettuare delle operazioni
 specifiche con i file trovati, ad esempio:
\end_layout

\begin_layout Itemize
find /home -perm 777 -exec chmod 555 {} 
\backslash
; //questo comando, una volta lanciato, troverà tutti i file con permessi
 777 e li cambierà a 555, questa operazione viene effettuata per ogni file
 trovato; la parola chiave 
\begin_inset Quotes eld
\end_inset

-exec
\begin_inset Quotes erd
\end_inset

 indica l'inizio di un comando, le parantesi graffe {} indicano 
\begin_inset Quotes eld
\end_inset

ogni file trovato
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset


\backslash
;
\begin_inset Quotes erd
\end_inset

 indica la fine del comando.
\end_layout

\begin_layout Itemize
find / -size 30M //questo comando mi troverà file grossi fino a 30MB 
\end_layout

\begin_layout Itemize
find / -type f -size +500M //questo comando troverà file di grandezza maggiore
 a 500MB
\end_layout

\begin_layout Standard
E' possibile anche impostare una determinata profondità nelle ricerche,
 ad esempio:
\end_layout

\begin_layout Itemize
find /etc -maxdepth 1 //effettua ricerche fino a una sottodirectory di profondit
à
\end_layout

\begin_layout Standard
possiamo ricercare anche in funzione di nomi utente o di gruppo (o codice
 utente/gruppo); infatti altri esempi potrebbero essere:
\end_layout

\begin_layout Itemize
find /home -user john //elenca i file appertenenti all'utente 
\begin_inset Quotes eld
\end_inset

John
\begin_inset Quotes erd
\end_inset

 nella directory /home
\end_layout

\begin_layout Itemize
find .
 -type f -name 'cron*' //in questo esempio vengono evidenziati solo i file
 che iniziano per 
\begin_inset Quotes eld
\end_inset

cron
\begin_inset Quotes erd
\end_inset

 e non le directory, arreaverso il flag 
\begin_inset Quotes eld
\end_inset

-type f
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
find .
 -type d -name 'cron*' //in questo altro caso invece vengono cercate solo
 le directory che iniziano per 
\begin_inset Quotes eld
\end_inset

cron
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
find / -mtime +1 //se vogliamo cercare i file modificati nell'ultimo giorno,
 un'alternativa ad 
\begin_inset Quotes eld
\end_inset

-mtime
\begin_inset Quotes erd
\end_inset

 è 
\begin_inset Quotes eld
\end_inset

-a
\begin_inset Quotes erd
\end_inset

, per effettuare le stesse funzioni
\end_layout

\begin_layout Itemize
find / -group nameofgroup //evidenzia tutti i file di un determinato gruppo
\end_layout

\begin_layout Itemize
find .
 -name 'file*' -exec rm {} 
\backslash
; //elimina tutti i file che iniziano per la parola 
\begin_inset Quotes eld
\end_inset

file
\begin_inset Quotes erd
\end_inset

, questo può essere utile nel caso dovessimo eliminare una lista di file
 con nomi simili
\end_layout

\begin_layout Itemize
find ~/Movies/ -size +1024M //cerca file di dimensioni oltre 1GB (1024MB)
 nella directory menzionata
\end_layout

\begin_layout Itemize
find / -size 50M //trova tutti i file che hanno una dimensione esattamente
 di 50MB
\end_layout

\begin_layout Itemize
find / -size 33c //trova tutti i file di 33 byte, infatti il suffisso 
\begin_inset Quotes eld
\end_inset

c
\begin_inset Quotes erd
\end_inset

 sta per byte, mentre l'opzione di default (cioè se non avessi messo la
 'c') sarebbe stata 
\begin_inset Quotes eld
\end_inset

b
\begin_inset Quotes erd
\end_inset

 che sta per blocco, dove per blocco si intendono blocchi da 512byte cadauno
\end_layout

\begin_layout Itemize
find .
 -size 1033c ! -executable //mostra tutti i file che sono grandi 1033bytes
 e non sono eseguibili
\end_layout

\begin_layout Itemize
find / -size +50M -size -100M //trova tutti i file che hanno una dimensione
 maggiore a 50MB ma minore a 100MB
\end_layout

\begin_layout Itemize
find / -type f -name *.mp3 -size +10M -exec rm {} 
\backslash
; //trova tutti i file mp3 con dimensione maggiore a 10MB e li elimina
\end_layout

\begin_layout Itemize
find ~ -perm 777 //cerca tutti i file nella directory utente con pieni permessi
\end_layout

\begin_layout Itemize
find .
 -user daniel -type f -name *.jpg ! -name autumn* //trova tutti i file dell'utent
e daniel, con estensione jpg ma che non contengono la stringa 
\begin_inset Quotes eld
\end_inset

autumn
\begin_inset Quotes erd
\end_inset

 nel nome
\end_layout

\begin_layout Itemize
find ~/scripts/ -user root -type f -amin -2 -name *.rb //trova gli script
 ruby (.rb) a cui abbiamo fatto accesso negli ultimi 2 minuti
\end_layout

\begin_layout Itemize
find ~/scripts/ -user root -type f -mmin -2 -name *.rb //trova gli script
 ruby (.rb) che abbiamo modificato negli ultimi 2 minuti
\end_layout

\begin_layout Itemize
find /tmp -type f -empty //cerca tutti i file vuoti
\end_layout

\begin_layout Itemize
find /tmp -type f -name ".*" //cerca tutti i file nascosti
\end_layout

\begin_layout Itemize
find / -mtime +50 –mtime -100 //trova tutti i file che sono stati cambiati
 più di 50 giorni fa ma non più di 100 giorni fa
\end_layout

\begin_layout Itemize
find / -mmin -60 //trova tutti i file modificati nell'ultima ora
\end_layout

\begin_layout Itemize
find / -perm -4000 2>/dev/null //in questo modo cerchiamo tutti i file con
 setuid, questi possono essere utili nell'ambito della sicurezza per effettuare
 privilege escalation, quindi fare attenzione a questi file
\end_layout

\begin_layout Subsubsection
Locate
\end_layout

\begin_layout Standard
Locate è un programma che crea un indice dei file salvati sul sistema all'intern
o di un database.
 Quando viene effettuata una ricerca, locate cercherà all'interno del database,
 quindi le ricerche sono molto veloci.
 Normalmente il database viene aggiornato ogni ora, ma questo dipende dalla
 configurazione, quest'azione periodica può anche essere visualizzata in
 cron.
 Possiamo aggiornare manualmente il database attraverso il comando
\end_layout

\begin_layout Itemize
updatedb //aggiorna il database di locate
\end_layout

\begin_layout Standard
Altri esempi di utilizzo possono essere:
\end_layout

\begin_layout Itemize
locate fileName //cerca il file chiamato 
\begin_inset Quotes eld
\end_inset

filename
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
locate physics | grep -i 
\begin_inset Quotes eld
\end_inset

/DATA
\begin_inset Quotes erd
\end_inset

 //questo cercherà i file chiamati 
\begin_inset Quotes eld
\end_inset

physics
\begin_inset Quotes erd
\end_inset

 che sono situati nella directory 
\begin_inset Quotes eld
\end_inset

/DATA
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Nota Bene: Se un file viene creato e istantaneamente viene cercato, locate
 non riesce a trovarlo in quanto il database non è stato aggiornato.
\end_layout

\begin_layout Standard
Il file di configurazione per il database è localizzato in 
\begin_inset Quotes eld
\end_inset

/etc/updatedb.conf
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Paragraph
Updatedb File
\end_layout

\begin_layout Standard
Vediamo ora alcune impostazioni importanti all'interno del file 
\begin_inset Quotes eld
\end_inset

/etc/updatedb.conf
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
PRUNE_BIND_MOUNTS = 
\begin_inset Quotes eld
\end_inset

yes
\begin_inset Quotes erd
\end_inset

 //questa opzione permette di mettere in gioco all'interno del database
 anche i filesystem connessi al sistema principale
\end_layout

\begin_layout Itemize
PRUNEFS = 
\begin_inset Quotes eld
\end_inset

...
 ...
 ...
\begin_inset Quotes erd
\end_inset

 //qui sono elencati i tipi di filesystem da ignorare e quindi non catalogare
 nel database
\end_layout

\begin_layout Itemize
PRUNENAMES = 
\begin_inset Quotes eld
\end_inset

.git .hg .svn
\begin_inset Quotes erd
\end_inset

 //le estensioni da escludere nelle ricerche
\end_layout

\begin_layout Itemize
PRUNEPATHS = 
\begin_inset Quotes eld
\end_inset

/afs /media
\begin_inset Quotes erd
\end_inset

 //le directory da escludere nelle ricerche
\end_layout

\begin_layout Subsubsection
Modalità Alternative per cercare file
\end_layout

\begin_layout Standard
Verranno di sequito elencate alcune modalità alternative per effettuare
 ricerche di file su sistemi GNU/Linux:
\end_layout

\begin_layout Itemize
ls /nomeDirectoryInCuiCercare -R | grep 
\begin_inset Quotes eld
\end_inset

nomeFileOWildCard
\begin_inset Quotes erd
\end_inset

 //cerca in modo ricorsivo (dir e subdirs) all'interno della directory /nomeDire
ctoryInCuiCercare i file che hanno nome nomeFileOWildCard
\end_layout

\begin_layout Itemize
grep -lr nomeFile /directory //elenca i file i cui nomi corrispondono a
 nomeFile all'interno della directory /directory
\end_layout

\begin_layout Subsection
Il programma Tar
\end_layout

\begin_layout Standard
Tar è un programma utilizzato per archiviare (o raggruppare) più file in
 un singolo file, i file creati con tar sono chiamati 
\begin_inset Quotes eld
\end_inset

tarball
\begin_inset Quotes erd
\end_inset

, questo ci permette di maneggiare insiemi di file e directory come se fossero
 un unico file.
 Generalmente archiviare dei file non significa necessariamente comprimerli,
 anche se questa è una possibilità.
 Alcuni esempi d'uso possono essere:
\end_layout

\begin_layout Itemize
tar cvf ciao.tar /home //crea un tar della directory 
\begin_inset Quotes eld
\end_inset

/home
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
tar cvf ciao.tar file1 file2 file3 //crea un tar con all'interno i tre file
\end_layout

\begin_layout Itemize
tar cvf mydirectory.tgz .
 //crea un archivio della directory corrente
\end_layout

\begin_layout Itemize
tar tvf ciao.tar //elenca il contenuto dell'archivio tar
\end_layout

\begin_layout Itemize
tar -tf <file.tar.gz> | xargs rm -r //elimina tutti i file che sono stati
 estratti dall'archivio menzionato, è molto comodo quando ci troviamo davanti
 a tarbomb, cioè pacchetti che non presentano al loro interno una parent
 directory ma un insieme esagerato di file
\end_layout

\begin_layout Itemize
tar xvf ciao.tar //estrae in loco il contenuto dell'archivio tar
\end_layout

\begin_layout Itemize
tar xvpf ciao.tar //estrae in loco il contenuto dell'archivio tar, il flag
 
\begin_inset Quotes eld
\end_inset

-p
\begin_inset Quotes erd
\end_inset

, serve a preservare i permessi dei file all'interno dell'archivio
\end_layout

\begin_layout Itemize
tar xvpf ciao.tar –xattrs //estrae in loco il contenuto dell'archivio tar,
 il flag 
\begin_inset Quotes eld
\end_inset

-p
\begin_inset Quotes erd
\end_inset

, serve a preservare i permessi dei file all'interno dell'archivio e l'opzione
 
\begin_inset Quotes eld
\end_inset

–xattrs
\begin_inset Quotes erd
\end_inset

 serve a preservare gli attributi dei file all'interno dell'archivio
\end_layout

\begin_layout Itemize
tar xvf ciao.tar -C /percorso/preferito //estra il contenuto di un file tar
 nella directory /percorso/preferito
\end_layout

\begin_layout Itemize
tar caf target.tar.xz file1 file2 file3 //con il flag -a indica di utilizzare
 lo schema di compressione indicato nel suffisso dell'archivio, molto comodo,
 quindi ad esempio se avessimo usato come suffisso 
\begin_inset Quotes eld
\end_inset

.tar.gz
\begin_inset Quotes erd
\end_inset

 avrebbe utilizzato gzip
\end_layout

\begin_layout Standard
Un altro flag molto utilizzato è 'p', per mantenere gli stessi permessi
 all'interno dell'archivio, così nel momento di una futura estrazione la
 gerarchia di permessi sui file non va persa.
 Nel caso volessimo comprimere, abbiamo diverse opzioni in funzione dell'algorit
mo di compressione che preferiamo utilizzare, generalmente abbiamo:
\end_layout

\begin_layout Itemize
gzip or gunzip //per comprimere con questo algoritmo ci basta includere
 il flag -z alle opzioni precedenti passate al tar, ad esempio 
\begin_inset Quotes eld
\end_inset

tar cvzf ciao.tar.gz /home
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
bzip2 //per comprimere con questo algoritmo ci basta includere il flag -j
 ai comandi tar 
\begin_inset Quotes eld
\end_inset

tar cvjf ciao.tar.bz2 /home
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Ad ogni modo è bene tenere in mente che archiviazione e compressione possono
 lavorare sepratamente, ad esempio:
\end_layout

\begin_layout Itemize
gzip nomeFile.tar //comprime l'archivio nomeFile.tar
\end_layout

\begin_layout Itemize
gzip -1 nomeFile.tar //comprime l'archivio utilizzando un algoritmo più veloce,
 avremo però meno compressione ( il valore numerico può andare da 1 a 9
\end_layout

\begin_layout Itemize
gunzip nomeFileCompresso.tar.gz //decomprime il file nomeFileCompresso.tar.gz
\end_layout

\begin_layout Itemize
bzip2 nomeFile.tar //comprime il file nomeFile.tar
\end_layout

\begin_layout Itemize
bunzip2 nomeFile.tar.bz2 //decomprime il file nomeFile.tar.bz2
\end_layout

\begin_layout Standard
Nota Bene: Esistono delle analogie tra le estensioni dei file archiviati
 e compressi:
\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Suffisso Breve
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Suffisso Lungo
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
.tgz
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
.tar.gz
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
.tbz, .tbz2, .tb2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
.tar.bz2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
.taz, .tz
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
.tar.Z
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
.tlz
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
.tar.lz, .tar.lzma
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
.txz
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
.tar.xz
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Suffissi equivalenti per file archiviati e compressi
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Vediamo ora alcuni esempi di tar in cui viene combinata la compressione/decompre
ssione:
\end_layout

\begin_layout Itemize
tar zxvf ciao.tar.gz //decomprime ed estrae l'archivio compresso con gunzip
\end_layout

\begin_layout Itemize
tar jxvf ciao.tar.bz2 //decomprime ed estrae l'archivio compresso con bzip2
\end_layout

\begin_layout Itemize
tar tzf nomeArchivio.tar.gz //visualizza il contenuto di un archivio compresso
 con gunzip
\end_layout

\begin_layout Itemize
tar Jxvf ciao.tar.xz //decomprime ed estrae l'archivio compresso con xz
\end_layout

\begin_layout Standard
N.B.: Bzip è un algoritmo più lento ma è molto efficiente quando usato per
 comprimere file di testo, quindi viene utilizzato per distribuire codice
 sorgente.
 Un'altro algoritmo che sta sempre diventando più famoso è 
\begin_inset Quotes eld
\end_inset

xz
\begin_inset Quotes erd
\end_inset

 e il suo corrispettivo 
\begin_inset Quotes eld
\end_inset

unxz
\begin_inset Quotes erd
\end_inset

.
 Per decomprimere invece archivi di tipo rar, possiamo usare unrar, ed eseguire
 
\begin_inset Quotes eld
\end_inset

unrar l nomearchivio.rar
\begin_inset Quotes erd
\end_inset

 per visualizzarne il contenuto e 
\begin_inset Quotes eld
\end_inset

unrar x nomearchivio.rar
\begin_inset Quotes erd
\end_inset

 per estrarre l'archivio.
\end_layout

\begin_layout Subsection
Librerie
\end_layout

\begin_layout Standard
Esistono generalmente due tipi di librerie:
\end_layout

\begin_layout Itemize
Shared libraries: are .so (or in Windows .dll, or in OS X .dylib) files.
 All the code relating to the library is in this file, and it is referenced
 by programs using it at run-time.
 A program using a shared library only makes reference to the code that
 it uses in the shared library.
\end_layout

\begin_layout Itemize
Static libraries are .a (or in Windows .lib) files.
 All the code relating to the library is in this file, and it is directly
 linked into the program at compile time.
 A program using a static library takes copies of the code that it uses
 from the static library and makes it part of the program.
 [Windows also has .lib files which are used to reference .dll files, but
 they act the same way as the first one].
\end_layout

\begin_layout Standard
There are advantages and disadvantages in each method.
\end_layout

\begin_layout Itemize
Shared libraries reduce the amount of code that is duplicated in each program
 that makes use of the library, keeping the binaries small.
 It also allows you to replace the shared object with one that is functionally
 equivalent, but may have added performance benefits without needing to
 recompile the program that makes use of it.
 Shared libraries will, however have a small additional cost for the execution
 of the functions as well as a run-time loading cost as all the symbols
 in the library need to be connected to the things they use.
 Additionally, shared libraries can be loaded into an application at run-time,
 which is the general mechanism for implementing binary plug-in systems.
\end_layout

\begin_layout Itemize
Static libraries increase the overall size of the binary, but it means that
 you don't need to carry along a copy of the library that is being used.
 As the code is connected at compile time there are not any additional run-time
 loading costs.
 The code is simply there.
\end_layout

\begin_layout Standard
Personally, one could prefer shared libraries, but use static libraries
 when needing to ensure that the binary does not have many external dependencies
 that may be difficult to meet, such as specific versions of the C++ standard
 library or specific versions of the Boost C++ library.
\end_layout

\begin_layout Standard
Detta in modo pragmatico le librerie sono file che contengono pezzi di codice
 a cui i programmatori fanno riferimento all'interno dei loro programmi,
 anche perchè la riscrittura di quel pezzo di codice o l'inclusione della
 librearia stessa all'interno del loro programma, costerebbe loro spazio
 aggiuntivo.
 Un file di libreria normalmente ha estensione 
\begin_inset Quotes eld
\end_inset

.so
\begin_inset Quotes erd
\end_inset

 o 
\begin_inset Quotes eld
\end_inset

.a
\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_layout Standard
Per poter visualizzare di quali librerie fa uso un determinato programma
 possiamo utilizzare:
\end_layout

\begin_layout Itemize
ldd percorsoDelProgramma //dove il percorso del programma può essere individuato
 con whereis nomeProgramma
\end_layout

\begin_layout Standard
Inoltre per permettere ad un programma di precaricare una determinata libreria
 prima di tutte le altre possiamo utilizzare la variabile d'ambiente LD_PRELOAD,
 ad esempio:
\end_layout

\begin_layout Itemize
LD_PRELOAD=/usr/lib/libv4l/v4l1compat.so skype //in questo caso aggiungiamo
 una libreria da far caricare ad un software chiamato skype prima di tutte
 le altre
\end_layout

\begin_layout Standard
Esistono diversi modi per configurare le librerie di sistema su GNU/Linux:
\end_layout

\begin_layout Itemize
Configurazione Globale (o Global Configurations): configurazione valida
 per tutti gli utenti di un sistema
\end_layout

\begin_layout Itemize
Configurazione locale o d'ambiente (Environment Configurations): configurazione
 valida per un utente specifico
\end_layout

\begin_layout Standard
Quando cambiamo una qualche configurazione riguardante le librerie, dobbiamo
 effettuare una pulizia della cache, questo avviene per rendere effettivi
 i cambiamenti, a questo proposito viene usato il comando:
\end_layout

\begin_layout Itemize
ldconfig //ricarica le librerie disponibili
\end_layout

\begin_layout Itemize
ldconfig -v //visualizza le librerie attualmente caricate dal sistema
\end_layout

\begin_layout Standard
A volte un determinato software cerca una specifica libreria e non la trova,
 nel caso dovessimo avere sul sistema una libreria molto simile, magari
 che differisce di una sola o poche versioni da quella cercata si può risolvere
 il problema, andando ad effettuare dei link di questa libreria esistente
 utilizzando i nomi delle librerie cercate.
 Il file contenente la configurazione globale di sistema delle librerie
 è 
\begin_inset Quotes eld
\end_inset

/etc/ld.so.conf
\begin_inset Quotes erd
\end_inset

; in questo file, troveremo una direttiva di include che ci dirà dove è
 localizzata la directory che contiene i file contenenti i percorsi a alle
 librerie.
 Nella directory 
\begin_inset Quotes eld
\end_inset

/etc/ld.so.conf.d/
\begin_inset Quotes erd
\end_inset

 sono invece contenuti diversi file con estensione 
\begin_inset Quotes eld
\end_inset

.conf
\begin_inset Quotes erd
\end_inset

 che contengono i veri e propri percorsi alle librerie.
 La directory contenente le librerie di sistema è costituita da 
\begin_inset Quotes eld
\end_inset

/lib
\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_layout Standard
Nel caso volessimo avere una libreria privata, che può quindi vedere solo
 il mio utente (per questioni di privacy, o per effettuare dei test) la
 soluzione migliore è creare una directory che contiene questa/queste libreria/e
 e poi creare una variabile d'ambiente che mi fornisce il link alla directory
 contenente la mia libreria.
 Ad esempio:
\end_layout

\begin_layout Enumerate
mkdir /usr/local/mylibrary //creo una directory e all'interno ci metto la
 mia libreria
\end_layout

\begin_layout Enumerate
export LD_LIBRARY_PATH=/usr/local/mylibrary //modifico la variabile d'ambiente
 
\begin_inset Quotes eld
\end_inset

LD_LIBRARY_PATH
\begin_inset Quotes erd
\end_inset

 contenente il percorso alle librerie accessibile all'utente
\end_layout

\begin_layout Standard
N.B.: possiamo anche utilizzare più percorsi, infatti utente posso utilizzare
 il separatore 
\begin_inset Quotes eld
\end_inset

:
\begin_inset Quotes erd
\end_inset

 per indicare i vari percorsi, come ad esempio:
\end_layout

\begin_layout Itemize
export LD_LIBRARY_PATH=/usr/local/mylibrary:/usr/local/mylibrary2
\end_layout

\begin_layout Standard
Ricorda che se sono state effettuate delle modifiche all'interno del file
 /etc/ld.so.conf, allora dobbiamo lanciare un 
\begin_inset Quotes eld
\end_inset

ldconfig
\begin_inset Quotes erd
\end_inset

, viceversa se abbiamo aggiunto delle librerie solo per il mio utente allora
 non sarà necessario lanciare il comando 
\begin_inset Quotes eld
\end_inset

ldconfig
\begin_inset Quotes erd
\end_inset

.
 In linea di massima possiamo dire che:
\end_layout

\begin_layout Itemize
In presenza di modifiche della Configurazione Globale -> necessario un 
\begin_inset Quotes eld
\end_inset

ldconfig
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
In presenza di modifiche della Configurazione Locale -> non necessario un
 
\begin_inset Quotes eld
\end_inset

ldconfig
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Paragraph
Problemi comuni con le librerie
\end_layout

\begin_layout Standard
Talvolta pur essendoci la libreria richiesta, prendiamo ad esempio la libreria
 
\begin_inset Quotes eld
\end_inset

libXft.so.2
\begin_inset Quotes erd
\end_inset

, il lancio di un eseguibile potrebbe ancora lanciare il messaggio 
\begin_inset Quotes eld
\end_inset

error while loading shared libraries: libXft.so.2: cannot open shared object
 file: No such file or directory
\begin_inset Quotes erd
\end_inset

, questo avviene in quanto il sistema vuole quella specifica libreria, ma
 per un'altra architettura, nel nostro caso potrebbe ad esempio volere la
 versione per architettura 
\begin_inset Quotes eld
\end_inset

i386
\begin_inset Quotes erd
\end_inset

 di quella libreria, mentre noi abbiamo solo la versione per architettura
 
\begin_inset Quotes eld
\end_inset

x86_64
\begin_inset Quotes erd
\end_inset

, dobbiamo quindi procedere con l'aggiungere i pacchetti per l'architettura
 
\begin_inset Quotes eld
\end_inset

i386
\begin_inset Quotes erd
\end_inset

 e installare la libreria.
 SOlitamente su Debian una determinata libreria o pacchetto per un'altra
 architettura si può installare accodando al nome del pacchetto la stringa
 
\begin_inset Quotes eld
\end_inset

:i386
\begin_inset Quotes erd
\end_inset

, quindi nel nostro caso, se la libreria 
\begin_inset Quotes eld
\end_inset

libXft.so.2
\begin_inset Quotes erd
\end_inset

 appartiene al pacchetto 
\begin_inset Quotes eld
\end_inset

libxft2
\begin_inset Quotes erd
\end_inset

 ci basterà eseguire:
\end_layout

\begin_layout Itemize
sudo apt-get install libxft2:i386 
\end_layout

\begin_layout Subsection
Il Comando 
\begin_inset Quotes eld
\end_inset

dd
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Il programma 
\begin_inset Quotes eld
\end_inset

dd
\begin_inset Quotes erd
\end_inset

 costituisce un comando molto flessibile che ci permette di copiare o convertire
 file da una locazione ad uno specifico file, viene usato per diversi scopi,
 alcuni esempi applicativi sono:
\end_layout

\begin_layout Itemize
Creare immagini ISO
\end_layout

\begin_layout Itemize
Effettuare Backup
\end_layout

\begin_layout Itemize
Salvare i primi 512 Byte nella partizione 
\begin_inset Quotes eld
\end_inset

/
\begin_inset Quotes erd
\end_inset

 di root per salvare il Master Boot Record
\end_layout

\begin_layout Itemize
Per riempire di zeri una partizione o in genere un dispositivo di memoria
 per poterlo svuotare completamente di tutti i dati presenti
\end_layout

\begin_layout Itemize
Per creare in genere un file di una determinata dimensione (ad esempio per
 effettuare qualche tipo di simulazione)
\end_layout

\begin_layout Itemize
Per creare file di swap
\end_layout

\begin_layout Itemize
Effettuare benchmark grossolani
\end_layout

\begin_layout Itemize
Salvare un dispositivo con tutte le sue relative partizioni e tabella delle
 partizioni, se ad esempio c'è un HD con diversi sistemi operativi e diversi
 dati, o ad esempio un'immagine SD di un sistema operativo con una configurazion
e particolare, possiamo usare dd per copiare tutto
\end_layout

\begin_layout Standard
Esempi di utilizzo sono:
\end_layout

\begin_layout Itemize
dd if=/root/mydir of=/home/user/backup.iso //dove if sta per 
\begin_inset Quotes eld
\end_inset

input file
\begin_inset Quotes erd
\end_inset

 e of sta per 
\begin_inset Quotes eld
\end_inset

output file
\begin_inset Quotes erd
\end_inset

, in questo esempio viene creata un'immagine iso della directory 
\begin_inset Quotes eld
\end_inset

mydir
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
dd if=/dev/sda1 of=/home/user/mbr.iso bs=512 count=1 //in questo caso viene
 effettuato un backup del Master Boot Record, che costituisce i primi 512
 byte della partizione/dev/sda1
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Il flag 
\begin_inset Quotes eld
\end_inset

bs
\begin_inset Quotes erd
\end_inset

 indica la dimensione del blocco (block size), ad esempio anche opzioni
 come 
\begin_inset Quotes eld
\end_inset

bs=1M
\begin_inset Quotes erd
\end_inset

 o 
\begin_inset Quotes eld
\end_inset

bs=2G
\begin_inset Quotes erd
\end_inset

 sono valide, dove i suffissi M e G indicano corrispettivamente Megabyte
 e Gigabyte, non utilizzare un suffisso corrisponde quindi ad una dimensione
 in byte, di default se il block size non viene specificato la dimensione
 è fissata a 512 byte
\end_layout

\begin_layout Itemize
Il flag 
\begin_inset Quotes eld
\end_inset

count
\begin_inset Quotes erd
\end_inset

 indica quanti blocchi della dimensione del flag bs devono essere copiati,
 in questo caso, siccome ci interessano solo i primi 512 byte, il flag count
 è settato ad 1, mentre nel caso avessimo messo 
\begin_inset Quotes eld
\end_inset

count=2
\begin_inset Quotes erd
\end_inset

 allora in tutto avremmo copiato 1024 byte
\end_layout

\begin_layout Itemize
N.B.: Posso capire qual'è la mia partizione di boot, effettuando un 
\begin_inset Quotes eld
\end_inset

df -h
\begin_inset Quotes erd
\end_inset

 e visualizzando qual'è il device su cui è montata la partizione 
\begin_inset Quotes eld
\end_inset

/
\begin_inset Quotes erd
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
dd if=/dev/urandom of=a.log bs=1M count=2 //genera un file di 2MB con contenuto
 casuale
\end_layout

\begin_layout Standard
Altri esempi di utilizzo possono essere:
\end_layout

\begin_layout Itemize
dd if=/dev/zero of=/home/user/zero bs=1M count=1 //crea un file da 1MB di
 dimensione, riempendolo di zeri...
 Quest'operazione poteva essere effettuata anche attraverso i flag bs=1024
 count=1024
\end_layout

\begin_layout Itemize
dd if=/dev/zero of=/dev/sdb1 //cancella tutti i dati sulla partizione sdb1
 riempendola di zeri
\end_layout

\begin_layout Itemize
dd if=/dev/zero of=/dev/null bs=1M count=32768 //effettua un benchmark sulla
 banda di operazione CPU/Memoria, andando a leggere qualche GB di zeri e
 poi buttandoli via, il risultato sarà in B/s, più è alto e più il sistema
 è efficiente
\end_layout

\begin_layout Standard
per poter visualizzare un feedback sulla percentuale di completamento possiamo
 eseguire:
\end_layout

\begin_layout Itemize
sudo pkill -USR1 -n -x dd //manda un segnale al programma dd, quest'ultimo
 risponderà con la quantità di dati copiati
\end_layout

\begin_layout Standard
un'alternativa a dd che riporta anche informazioni sullo stato e percentuale
 di completamento è 
\begin_inset Quotes eld
\end_inset

dcfldd
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Nota che a volte quando cerchiamo di creare chiavette USB con immagini di
 alcuni sistemi operativi, e.g., slackware, gentoo, freebsd, è preferibile,
 prima di dare queste immagini in pasto a 
\begin_inset Quotes eld
\end_inset

dd
\begin_inset Quotes erd
\end_inset

 di eseguire un:
\end_layout

\begin_layout Itemize
isohybrid nome_immagine.iso //rende un iso ibrida in modo da poter essere
 leggibile sia da un sistema UEFI che ISO.
\end_layout

\begin_layout Subsection
Manipolazione avanzata di file
\end_layout

\begin_layout Standard
Vediamo ora alcuni comandi per la manipolazione di file.
\end_layout

\begin_layout Paragraph
Xargs
\end_layout

\begin_layout Standard
Un programma molto utile per eseguire uno specifico comando per ogni voce
 sullo standard output è xargs, vediamone un esempio applicativo:
\end_layout

\begin_layout Itemize
ls | grep test | xargs rm //rimuove tutti i file elencati, cioè tutti i
 file che hanno la parola 
\begin_inset Quotes eld
\end_inset

test
\begin_inset Quotes erd
\end_inset

 all'interno del loro nome
\end_layout

\begin_layout Paragraph
Sort
\end_layout

\begin_layout Standard
Sort è un programma utilizzato per riordinare i risultati sullo standard
 output
\end_layout

\begin_layout Itemize
ls -al | sort -n -k5 //this will sort the stdout numerically attraverso
 il flag 
\begin_inset Quotes eld
\end_inset

-n
\begin_inset Quotes erd
\end_inset

 in funzione della quinta colonna, attraverso il flag 
\begin_inset Quotes eld
\end_inset

-k5
\begin_inset Quotes erd
\end_inset

 in quanto il risultato di un 
\begin_inset Quotes eld
\end_inset

ls -al
\begin_inset Quotes erd
\end_inset

 fornisce come quinta colonna le dimensioni dei file, le colonne sono separate
 da uno spazio di default
\end_layout

\begin_layout Itemize
sort -n -k5 test.txt //stampa sullo standard output il file test.txt riordinato
 numericamente in funzione della quinta colonna
\end_layout

\begin_layout Itemize
sort -k7 -r test.txt > test_new.txt //riordina in modalità inversa, attraverso
 il flag 
\begin_inset Quotes eld
\end_inset

-r
\begin_inset Quotes erd
\end_inset

, in funzione della settima colonna il file test.txt e salva il risultato
 nel file 
\begin_inset Quotes eld
\end_inset

test_new.txt
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
sort -t"," -k1,3 test.txt //in questo caso viene usato come separatore il
 carattere 
\begin_inset Quotes eld
\end_inset

,
\begin_inset Quotes erd
\end_inset

 attraverso il flag 
\begin_inset Quotes eld
\end_inset

-t
\begin_inset Quotes erd
\end_inset

 e il riordinamento avviene in funzione della colonna 1 e della colonna
 3 sul file chiamato 
\begin_inset Quotes eld
\end_inset

test.txt
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Subsubsection*
Expand ed Unexpand
\end_layout

\begin_layout Standard
Questi due comandi vengono utilizzati solitamente per sostituire uno o una
 serie di spazi in un file con dei tab o viceversa, o ad esempio cambiare
 il numero di spazi da cui è composto un tab.
 Vediamo un esempio:
\end_layout

\begin_layout Itemize
expand myfile.txt > myfile2.txt //questo converte i caratteri tab in spazi
\end_layout

\begin_layout Itemize
expand –tabs=10 myfile.txt > myfile2.txt //espando a 10 spazi tutti i tab
 del file myfile.txt e salvo il risultato nel file myfile2.txt
\end_layout

\begin_layout Itemize
unexpand -a myfile.txt > myfile2.txt //converto tutti gli spazi in tab e salvo
 risultati in myfile2.txt
\end_layout

\begin_layout Paragraph
Paste
\end_layout

\begin_layout Standard
Paste è un programma che unisce le righe di due file, ma è molto utilizzato
 per visualizzare le differenze tra due file, in quanto sullo standard output
 i due file vengono affiancati; un esempio applicativo è:
\end_layout

\begin_layout Itemize
paste test1 test2 //stampa riga per riga i due file sullo standard output,
 molto utile nel momento in cui dobbiamo confrontare i due file
\end_layout

\begin_layout Itemize
paste -d: users.txt passwords.txt //in questo caso genereremo un file con
 le righe accoppiate e separate dal simbolo 
\begin_inset Quotes eld
\end_inset

:
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Paragraph
Tr
\end_layout

\begin_layout Standard
Il comando 
\begin_inset Quotes eld
\end_inset

tr
\begin_inset Quotes erd
\end_inset

 viene utilizzato per effettuare sostituzioni carattere per carattere, ad
 esempio:
\end_layout

\begin_layout Itemize
tr blah test < file.txt //questo comando 
\begin_inset Quotes eld
\end_inset

tradurrà
\begin_inset Quotes erd
\end_inset

 e cioè sostituerà all'interno del file file.txt il catattere 
\begin_inset Quotes eld
\end_inset

b
\begin_inset Quotes erd
\end_inset

 col carattere 
\begin_inset Quotes eld
\end_inset

t
\begin_inset Quotes erd
\end_inset

, il carattere 
\begin_inset Quotes eld
\end_inset

l
\begin_inset Quotes erd
\end_inset

 col carattere 
\begin_inset Quotes eld
\end_inset

e
\begin_inset Quotes erd
\end_inset

, il carattere 
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

 col carattere 
\begin_inset Quotes eld
\end_inset

s
\begin_inset Quotes erd
\end_inset

 e il carattere 
\begin_inset Quotes eld
\end_inset

h
\begin_inset Quotes erd
\end_inset

 col carattere 
\begin_inset Quotes eld
\end_inset

t
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
tr a-z A-Z < fileName//converte un testo in minuscolo in un testo in maiuscolo
\end_layout

\begin_layout Itemize
tr -d 'a-zA-Z' < fileName //col flag -d rimuoviamo tutti i caratteri menzionati
\end_layout

\begin_layout Itemize
tr -dc 'a-zA-Z' < fileName //col flag -c facciamo il complemento del set
 dei caratteri menzionati, quindi in questo caso con -dc in pratica eliminiamo
 tutti i caratteri dal file, eccetto quelli nel gruppo 'a-zA-Z'
\end_layout

\begin_layout Standard
N.B.: Per effettuare la sostituzione di stringhe il comando sed è più flessibile\SpecialChar endofsentence

\end_layout

\begin_layout Paragraph
Contare le linee di un file
\end_layout

\begin_layout Standard
Per contare le linee esistono diverse opzioni, alcune classiche opzioni
 sono:
\end_layout

\begin_layout Itemize
nl file.txt //stampa il numero di linee del file chiamato file.txt
\end_layout

\begin_layout Itemize
nl -s.
 file.txt //stampa il numero di linee del file menzionato inoltre accoda
 ad ogni numero un 
\begin_inset Quotes eld
\end_inset

.
\begin_inset Quotes erd
\end_inset

, il flag 
\begin_inset Quotes eld
\end_inset

-s
\begin_inset Quotes erd
\end_inset

 serve appunto a mettere una stringa dopo il numero di linea
\end_layout

\begin_layout Itemize
cat -n file.txt //stampa il numero di linee del file chiamato file.txt
\end_layout

\begin_layout Standard
Nel caso avessimo un file con righe ridondanti e vogliamo mostrare solo
 le righe uniche, quindi senza contare le righe ridondanti, utilizziamo
 il comando 
\begin_inset Quotes eld
\end_inset

uniq
\begin_inset Quotes erd
\end_inset

, ad esempio:
\end_layout

\begin_layout Itemize
cat file.txt | sort | uniq -u //oppure possiamo utilizzare 
\begin_inset Quotes eld
\end_inset

sort -u
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Paragraph
Fmt
\end_layout

\begin_layout Standard
E' possibile formattare il testo attraverso il comando 
\begin_inset Quotes eld
\end_inset

fmt
\begin_inset Quotes erd
\end_inset

, per vedere le diverse opzioni possiamo effettuare un 
\begin_inset Quotes eld
\end_inset

man fmt
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Paragraph
Uniq
\end_layout

\begin_layout Standard
Questo comando è utile per visualizzare le righe uniche all'interno di un
 file, deve essere usato sempre in coppia con 
\begin_inset Quotes eld
\end_inset

sort
\begin_inset Quotes erd
\end_inset

 altrimenti considera unica una riga solo se non è uguale alla precedente,
 vediamo qualche esempio di utilizzo
\end_layout

\begin_layout Itemize
cat data.txt | sort | uniq -c //mostra per ogni riga quante occorrenze ci
 sono
\end_layout

\begin_layout Itemize
cat data.txt | sort | uniq -u //mostra solo le righe uniche
\end_layout

\begin_layout Itemize
cat data.txt | sort | uniq | sort -n //mostra per ogni riga quante occorrenze
 ci sono ma questa volte secondo un ordine crescente, quindi le righe più
 rare saranno in alto
\end_layout

\begin_layout Subsection
Effettuare Backup
\end_layout

\begin_layout Standard
In informatica con il termine backup, copia di sicurezza o copia di riserva
 si indica la replicazione, su un qualunque supporto di memorizzazione,
 di materiale informativo archiviato nella memoria di massa dei computer
 al fine di prevenire la perdita definitiva dei dati in caso di eventi malevoli
 accidentali o intenzionali.
 Si tratta dunque di una misura di ridondanza fisica dei dati, tipica delle
 procedure di disaster recovery.
 [Wikipedia] 
\end_layout

\begin_layout Standard
Nei sistemi GNU/Linux Esistono diverse tecniche per effettuare backup, è
 da notare che in realtà esistono diverse tipologie di backup, ad esempio
 il metodo più semplice di backup sarebbe quello di effettuare una semplice
 copia attraverso il comando 
\begin_inset Quotes eld
\end_inset

cp
\begin_inset Quotes erd
\end_inset

, con: 
\end_layout

\begin_layout Itemize
cp -u mioFile mioFile2// in questo caso il file viene copiato solo nel caso
 in cui mioFile2 non esiste o nel caso in cui mioFile2 esistente è più vecchio,
 ma non avviene una sincronizzazione completa (cioè nel caso di intere directory
 i file eliminati nella directory sorgente rimangono nella directory destinatari
a se sono stati copiati in un altro momento precedente)
\end_layout

\begin_layout Standard
L'esempio visto qui sopra è veramente basilare e non fa altro che effettuare
 una semplice copia, mentre i programmi di backup generalmente possono presentar
e le seguenti funzionalità:
\end_layout

\begin_layout Itemize
Copia immagine di un disco rigido; 
\end_layout

\begin_layout Itemize
Copia selettiva di directory e singoli file; 
\end_layout

\begin_layout Itemize
Criteri di selezione per la ricerca dei contenuti salvati e per la scelta
 di quelli che devono essere oggetto di backup (per data, tipo di file,
 autore della modifica); 
\end_layout

\begin_layout Itemize
Compressione dei contenuti per ridurre la memoria richiesta per la copia;
 
\end_layout

\begin_layout Itemize
Sicurezza: protezione dei dati copiati attraverso password e crittografia.
\end_layout

\begin_layout Standard
Vediamo ora alcune tecniche per effettuare backup su sistemi GNU/Linux che
 prevedono l'utilizzo di Tar o Rsync.
\end_layout

\begin_layout Subsubsection
Backup con Tar
\end_layout

\begin_layout Standard
Un semplice modo di effettuare backup col comando Tar ed ottenere compressione
 è:
\end_layout

\begin_layout Itemize
tar -pczf mybackup.tar.gz /home/user/ //viene effettuato un backup della directory
 /home/user/ in un archivio chiamato mybackup.tar.gz, il flag 
\begin_inset Quotes eld
\end_inset

-p
\begin_inset Quotes erd
\end_inset

 indica di preservare la struttura dei permessi di tutti i file e il flag
 
\begin_inset Quotes eld
\end_inset

-z
\begin_inset Quotes erd
\end_inset

 di comprimere utilizzando l'algoritmo gzip
\end_layout

\begin_layout Standard
Un altro esempio molto interessante è quello di effettuare backup periodici
 utilizzando questa il programma tar, questo è possibile attraverso uno
 script in cui scriviamo:
\end_layout

\begin_layout Itemize
tar -pczf /home/backup/backup.`/bin/date +
\backslash
%y
\backslash
%m
\backslash
%d`.tar.gz home/user/ //crea archivi con la data nel nome, della directory
 /home/user
\end_layout

\begin_layout Standard
Un'altra opzione è quella di aggiungere questo comando a 
\begin_inset Quotes eld
\end_inset

cron
\begin_inset Quotes erd
\end_inset

, in modo da poterlo eseguire periodicamente.
\end_layout

\begin_layout Subsubsection
Backup con Rsync
\end_layout

\begin_layout Standard
Uno strumento veramente molto flessibile per effettuare backup è costituito
 da 
\begin_inset Quotes eld
\end_inset

rsync
\begin_inset Quotes erd
\end_inset

, molte distro hanno questo comando installato di default.
 Vediamo subito alcuni esempi:
\end_layout

\begin_layout Itemize
rsync -av sourceDir /var/backups/destDir //copia la directory sourceDir
 in destDir e lo fa in modalità 
\begin_inset Quotes eld
\end_inset

verbose
\begin_inset Quotes erd
\end_inset

 cioè stampando sullo standard output file per file copiato, il flag 
\begin_inset Quotes eld
\end_inset

-a
\begin_inset Quotes erd
\end_inset

 sta per archivio e costituisce la combinazione di più flag 
\begin_inset Quotes eld
\end_inset

-rlp
\begin_inset Quotes erd
\end_inset

 e quindi:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
copia ricorsivamente le directory 
\end_layout

\begin_layout Itemize
copia anche i link
\end_layout

\begin_layout Itemize
preserva la struttura dei permessi
\end_layout

\end_deeper
\begin_layout Itemize
rsync -avz –delete /media/sorgente /media/giuseppe/destinazione/ //viene
 effettuata una copia di backup da sorgente a destinazione, il flag 
\begin_inset Quotes eld
\end_inset

-z
\begin_inset Quotes erd
\end_inset

, indica di effettuare la compressione per il trasferimento, e l'opzione
 
\begin_inset Quotes eld
\end_inset

–delete
\begin_inset Quotes erd
\end_inset

 cancella i file in 
\begin_inset Quotes eld
\end_inset

destinazione
\begin_inset Quotes erd
\end_inset

 che non sono presenti in 
\begin_inset Quotes eld
\end_inset

sorgente
\begin_inset Quotes erd
\end_inset

, quindi 
\begin_inset Quotes eld
\end_inset

destinazione
\begin_inset Quotes erd
\end_inset

 diventa una copia esatta di 
\begin_inset Quotes eld
\end_inset

sorgente
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
rsync -avzi –delete –progress /media/sorgente /media/giuseppe/destinazione/
 //viene effettuata la stessa operazione precedente, solo che attraverso
 il flag 
\begin_inset Quotes eld
\end_inset

-i
\begin_inset Quotes erd
\end_inset

 vengono visualizzate le modifiche effettuate in destinazione e attraverso
 l'opzione 
\begin_inset Quotes eld
\end_inset

–progress
\begin_inset Quotes erd
\end_inset

 viene visualizzato lo stato del backup
\end_layout

\begin_layout Standard
Il programma rsync può anche essere usato per sincronizzare directory su
 (o da) server remoti, ad esempio:
\end_layout

\begin_layout Itemize
rsync -av gng@andromeda:/home/gng/mySourceFolder /home/marco/BackupServer/
\end_layout

\begin_layout Section
Processi
\end_layout

\begin_layout Standard
In soldoni un processo è un programma, i processi possono esistere in diversi
 stati, e possono comunicare tra loro attraverso i cosiddetti 
\begin_inset Quotes eld
\end_inset

segnali
\begin_inset Quotes erd
\end_inset

, che non sono altro che notifiche asincrone mandate ad un processo.
 Gli strumenti principali per visualizzare i processi attivi su una macchina
 sono:
\end_layout

\begin_layout Itemize
Top (Programma interattivo e dinamico)
\end_layout

\begin_layout Itemize
Ps (Programma statico)
\end_layout

\begin_layout Standard
N.B.: Esiste una categoria particolare di processi chiamata 
\begin_inset Quotes eld
\end_inset

demoni
\begin_inset Quotes erd
\end_inset

 (Su altri sistemi operativi possono essere chiamati servizi), sono processi
 che vengono lanciati in background automaticamente e non sono interattivi,
 non hanno un terminale di controllo.
 I demoni effettuano determinate azioni in determinati tempi o in risposta
 a determinati eventi.
 Nei sistemi GNU/Linux e derivati da Unix i nomi dei processi demone finiscono
 in 
\begin_inset Quotes eld
\end_inset

d
\begin_inset Quotes erd
\end_inset

 o in 'd[0,x]' come ksyslogd, kswapd0 o kthreadd.
\end_layout

\begin_layout Subsubsection
Differenza tra PID e TID
\end_layout

\begin_layout Standard
It is complicated: pid is process identifier; tid is thread identifier.
\end_layout

\begin_layout Standard
But as it happens, the kernel doesn't make a real distinction between them:
 threads are just like processes but they share some things (memory, file
 descriptors and so on...) with other instances of the same group.
\end_layout

\begin_layout Standard
So, a tid is actually the identifier of the schedulable object in the kernel
 (thread), while the pid is the identifier of the group of schedulable objects
 that share memory and fds (process).
\end_layout

\begin_layout Standard
But to make things more interesting, when a process has only one thread
 (the initial situation and in the good old times the only one) the pid
 and the tid are always the same.
 So any function that works with a tid will automatically work with a pid.
\end_layout

\begin_layout Standard
It is worth noting that many functions/system calls/command line utilities
 documented to work with pid actually use tids.
 But if the effect is process-wide you will simply not notice the difference.
 
\end_layout

\begin_layout Subsection
Top
\end_layout

\begin_layout Standard
Top è un programma interattivo e dinamico per la gestione dei processi.
 Per avviarlo basta scrivere in un terminale 
\begin_inset Quotes eld
\end_inset

top
\begin_inset Quotes erd
\end_inset

, a questo punto comparirà una schermata in cui:
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

Load average
\begin_inset Quotes erd
\end_inset

 tiene conto della media di utilizzo della CPU, il primo numero è al minuto,
 il secondo ogni 5 minuti e il terzo ogni 15 minuti, possiamo fare delle
 considerazioni su questi, ad esempio se il primo è molto alto e l'ultimo
 basso, allora c'è stato un picco nell'ultimo minuto di risorse richieste
 e viceversa, inoltre è da tenere a mente che possono essere un buono strumento
 per valutare se un server è troppo debole o troppo forte per il suo lavoro,
 ad esempio su una macchina con 4 processori ho una media costante molto
 più bassa rispetto al numero 4 allora, tutti quei processori sono sprecati
 per il mio sistema
\end_layout

\begin_layout Itemize
Con 
\begin_inset Quotes eld
\end_inset

Shift+P
\begin_inset Quotes erd
\end_inset

 ordina i processi per utilizzo cpu
\end_layout

\begin_layout Itemize
Con 
\begin_inset Quotes eld
\end_inset

Shift+M
\begin_inset Quotes erd
\end_inset

 ordina i processi per utilizzo della memoria RAM
\end_layout

\begin_layout Itemize
La colonna 
\begin_inset Quotes eld
\end_inset

NI
\begin_inset Quotes erd
\end_inset

 rappresenta la priorità di un processo: più è basso il numero più è alta
 la priorità assegnata al processo.
 Le priorità vanno da -20 a +19; -20 costituisce la priorità più alta che
 un processo possa avere, viceversa +19 è la più bassa.
\end_layout

\begin_layout Itemize
Con 
\begin_inset Quotes eld
\end_inset

r
\begin_inset Quotes erd
\end_inset

 posso cambiare la priorità di un processo, mi basta inserire il PID (Process
 ID) da ri-prioritarizzare e schiacciando invio posso inserire la nuova
 priorità.
 
\end_layout

\begin_layout Itemize
Con 
\begin_inset Quotes eld
\end_inset

k
\begin_inset Quotes erd
\end_inset

 termino un processo, anche in questo caso mi basta inserire il PID e il
 segnale con cui terminarlo.
 
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Segnale 15 chiusura normale
\end_layout

\begin_layout Itemize
Segnale -9 chiusura forzata
\end_layout

\end_deeper
\begin_layout Itemize
Con 
\begin_inset Quotes eld
\end_inset

q
\begin_inset Quotes erd
\end_inset

 esce dal programma
\end_layout

\begin_layout Itemize
Con 
\begin_inset Quotes eld
\end_inset

m
\begin_inset Quotes erd
\end_inset

 mostra o nasconde informazioni sulla memoria
\end_layout

\begin_layout Itemize
Con 
\begin_inset Quotes eld
\end_inset

s
\begin_inset Quotes erd
\end_inset

 cambia il tempo di aggiornamento della schemata di top (di default questo
 tempo è 3 secondi)
\end_layout

\begin_layout Standard
La schermata di top si aggiorna automaticamente ogni 3 secondi, ad ogni
 modo esistono altre modalità con cui lanciarlo per poter cambiare questa
 impostazione o richiedere feature specifiche:
\end_layout

\begin_layout Itemize
top -d 1 //aggiorna lo stato dei processi ogni secondo
\end_layout

\begin_layout Itemize
top -p 1 //si ottiene una versione di top con focus sul processo avento
 PID = 1
\end_layout

\begin_layout Itemize
top -p 1,2,3 //come il caso precedente, ma ora il focus è sui processi 1,
 2 and 3
\end_layout

\begin_layout Itemize
top -b //avvio top in modalità 
\begin_inset Quotes eld
\end_inset

batch
\begin_inset Quotes erd
\end_inset

, in questa modalità visualizzo solo i processi senza informazioni aggiuntive
\end_layout

\begin_layout Standard
Possiamo vedere una descrizione dettagliata del significato dei campi visualizza
ti da top, nella pagina di man di top, nella sezione 
\begin_inset Quotes eld
\end_inset

DESCRIPTIONS
\begin_inset Quotes erd
\end_inset

.
 Una variante molto comoda e più avanzata a 
\begin_inset Quotes eld
\end_inset

top
\begin_inset Quotes erd
\end_inset

 è 
\begin_inset Quotes eld
\end_inset

htop
\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_layout Standard
Con htop, possiamo abilitare/disabilitare la visualizzazione dei diversi
 thread associati allo stesso processo con 
\begin_inset Quotes eld
\end_inset

Shift+H
\begin_inset Quotes erd
\end_inset

, a common suggestion is, enabling "Display threads in a different color"
 and "Show custom thread names" under F2 / Display.
\end_layout

\begin_layout Subsection
PS
\end_layout

\begin_layout Standard
Ps è un programma statico per la gestione dei processi, viene molto utilizzato
 nella stesura di programmi o script che devono in qualche modo interagire
 con i processi, ps mi fornisce una fotografia al tempo in cui viene lanciato
 dei processi attivi sulla macchina.
 Lanciando il programma con 
\begin_inset Quotes eld
\end_inset

ps
\begin_inset Quotes erd
\end_inset

 mi mostrerà solo i processi attivi all'interno del mio terminale, dovremo
 quindi aggiungere dei parametri per effettuare operazioni più complesse.
 I'll have many columns, and terminals are identified by TTY (Teletype code),
 identifies the terminal that the process is running on.
 Other cases are:
\end_layout

\begin_layout Itemize
ps -e //mostra i processi in running sul sistema
\end_layout

\begin_layout Itemize
ps -x //mostra tutti i processi in running dell'utente che ha lanciato il
 comando
\end_layout

\begin_layout Itemize
ps -U username //mostra tutti i processi in running dell'utente username
\end_layout

\begin_layout Itemize
ps -aux //mostra tutti i processi in running mostrando anche informazioni
 aggiuntive come uso CPU, uso memoria, è la più comune applicazione di ps
\end_layout

\begin_layout Itemize
ps w > alldata.txt //scrive i risultati sul file alldata.txt
\end_layout

\begin_layout Itemize
ps -ef –forest | less //this willl explore and see which are the parents
 of the processes, this is useful in order to see who generated certain
 processes
\end_layout

\begin_layout Itemize
ps -U root –forest //mostra l'albero gerarchico di tutti i processi
\end_layout

\begin_layout Itemize
ps -l //mostra informazioni dettagliate sui processi, ad esempio qui possiamo
 visualizzare con VSZ quanto occupano in memoria (totale) (in kiB), mentre
 con RSS quanto stanno attualmente occupando in RAM (in KiB), nota che queste
 due possono essere diverse in quanto un processo può avere una parte in
 memoria e l'altra sull'area di swap
\end_layout

\begin_layout Subsection
Altre Informazioni sui processi
\end_layout

\begin_layout Standard
E' possibile reperire altre informazioni sui processi attraverso altri programmi
; ad esempio:
\end_layout

\begin_layout Itemize
pwdx processID //mi fornisce la directory in cui sta lavorando il processo
 con PID processID
\end_layout

\begin_layout Itemize
pidof processName //mi fornisce il PID del processo con nome 
\begin_inset Quotes eld
\end_inset

processName
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
pgrep processName //mi fornisce il PID o i PID del processo con nome 
\begin_inset Quotes eld
\end_inset

processName
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
un sommario sull'utilizzo dei processi è dato da:
\end_layout

\begin_layout Itemize
procinfo //mostra sommari e statistiche sui processi, vedere il 
\begin_inset Quotes eld
\end_inset

man procinfo
\begin_inset Quotes erd
\end_inset

 per la spiegazione di ogni singola stringa e per varie opzioni
\end_layout

\begin_layout Subsection
Nice e Renice
\end_layout

\begin_layout Standard
E' possibile lanciare programmi specificando il grado di priorità attraverso
 il comando 
\begin_inset Quotes eld
\end_inset

nice
\begin_inset Quotes erd
\end_inset

, ad esempio:
\end_layout

\begin_layout Itemize
nice programName //in questo modo lanceremo il programma con una priorità
 default che è uguale a 10
\end_layout

\begin_layout Itemize
nice -n 10 programName // = al caso precedente
\end_layout

\begin_layout Itemize
nice -10 programName // = al caso precedente
\end_layout

\begin_layout Standard
Molto utile è anche il comando 
\begin_inset Quotes eld
\end_inset

renice
\begin_inset Quotes erd
\end_inset

 che ci permette di cambiare la priorità di un processo già in running,
 alcuni esempi applicativi possono essere:
\end_layout

\begin_layout Itemize
renice -n -20 -p processID //cambia la priorità del processo associato al
 PID processID ad un valore di -20
\end_layout

\begin_layout Itemize
renice -n -20 -u root //cambia la priorità di tutti i processi attivi dall'utent
e root ad un valore di -20
\end_layout

\begin_layout Subsection
Background e Foreground
\end_layout

\begin_layout Standard
I programmi attivi che stiamo utilizzando interattivamente davanti al terminale
 si dicono in 
\begin_inset Quotes eld
\end_inset

foreground
\begin_inset Quotes erd
\end_inset

, mentre quelli attivi nascosti vengono detti in 
\begin_inset Quotes eld
\end_inset

background
\begin_inset Quotes erd
\end_inset

, può essere utile mandare processi in background nel momento in cui vogliamo
 effettuare operazioni lunghe con cui non c'è bisogno di interagire molto.
\end_layout

\begin_layout Standard
E' possibile mandare processi in background attraverso la combinazione di
 tasti 
\begin_inset Quotes eld
\end_inset

Ctrl+z
\begin_inset Quotes erd
\end_inset

.
 Ad esempio possiamo provare ad avviare da terminale il programma 
\begin_inset Quotes eld
\end_inset

nano
\begin_inset Quotes erd
\end_inset

, lanciandolo con 
\begin_inset Quotes eld
\end_inset

nano nomeFile
\begin_inset Quotes erd
\end_inset

, in questo momento nano è in foreground, nel momento in cui vogliamo passare
 ad un altra operazione, lo possiamo mettere in background attraverso la
 combinazione 
\begin_inset Quotes eld
\end_inset

Ctrl+z
\begin_inset Quotes erd
\end_inset

, alcuni comandi per gestire i processi in background/foreground sono:
\end_layout

\begin_layout Itemize
jobs //mi mostra tutti i programmi in background del terminale corrente
\end_layout

\begin_layout Itemize
fg processCode //mi riporta il programma associato al PID processCode in
 foreground, per poter visualizzare il PID del programma interessato, mi
 basta avviare prima 
\begin_inset Quotes eld
\end_inset

jobs
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
E' possibile anche avviare direttamente un programma inserendolo in background:
\end_layout

\begin_layout Itemize
./myProgram & //avvia myProgram direttamente in background, possiamo quindi
 continuare ad utilizzare il terminale per effettuare altre operazioni
\end_layout

\begin_layout Standard
oppure è possibile portare un comando in background anche con:
\end_layout

\begin_layout Itemize
bg processCode //dove processCode è il PID del processo visualizzabile con
 
\begin_inset Quotes eld
\end_inset

jobs
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
N.B.: E' bene tenere a mente che tutti i processi del terminale vengono terminati
 con nel momento in cui usciamo dal terminale, nel caso volessimo far sopravvive
re i nostri processi anche una volta usciti dal terminale dobbiamo effettuare
 un'operazione di 
\begin_inset Quotes eld
\end_inset

nohup
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsection
Uccidere Processi
\end_layout

\begin_layout Standard
E' possibile uccidere un processo mandandogli dei segnali, esistono tre
 tipi di segnali utili per la terminazione di un processo:
\end_layout

\begin_layout Itemize
1 - sigup //termina il programma e chiede al demone di rileggere i file
 di configurazione, solitamente questo è utilizzato con i demoni, visto
 che la loro particolarità è quella di riavviarsi una volta uccisi
\end_layout

\begin_layout Itemize
9 - sigterm //forza l'uscita
\end_layout

\begin_layout Itemize
15 - quit with shutdown //chiude prima tutti i file aperti dal processo,
 è una terminazione meno brusca rispetto al segnale 9
\end_layout

\begin_layout Standard
Esempi di utilizzo possono essere:
\end_layout

\begin_layout Itemize
kill -s 9 processID //uccide il processo con PID processID utilizzando il
 signale 9, è equivalente a 
\begin_inset Quotes eld
\end_inset

kill -9 processID
\begin_inset Quotes erd
\end_inset

, il comando 
\begin_inset Quotes eld
\end_inset

kill
\begin_inset Quotes erd
\end_inset

 ha bisogno del PID del processo
\end_layout

\begin_layout Itemize
pidof nomeProcess //visualizza il PID del processo chiamato 
\begin_inset Quotes eld
\end_inset

nomeProcesso
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
pkill nomeProcesso //uccide il processo chiamato 
\begin_inset Quotes eld
\end_inset

nomeProcesso
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
xkill //uccide il processo legato ad una determinata finestra grafica, dopo
 averlo lanciato, ci basta clickare sulla finestra del processo da terminare,
 potrebbe essere utile associarlo ad una determinata combinazione di tasti
 da tastiera+
\end_layout

\begin_layout Standard
Possiamo anche interrompere processi per farli procedere in un secondo momento
 con:
\end_layout

\begin_layout Itemize
kill -STOP processID //interrompi il processo attraverso il segnale 
\begin_inset Quotes eld
\end_inset

STOP
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
kill -CONT processID //continua il processo interrotto con 
\begin_inset Quotes eld
\end_inset

-STOP
\begin_inset Quotes erd
\end_inset

 attraverso il segnale 
\begin_inset Quotes eld
\end_inset

CONT
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Alcune distro hanno il comando 
\begin_inset Quotes eld
\end_inset

killall
\begin_inset Quotes erd
\end_inset

, ad esempio:
\end_layout

\begin_layout Itemize
killall -9 apache2 //manda il segnale 9 a tutti i processi associati ad
 apache2, è da notare che al comando 
\begin_inset Quotes eld
\end_inset

killall
\begin_inset Quotes erd
\end_inset

 possiamo anche passare il nome del processo a differenza del comando 
\begin_inset Quotes eld
\end_inset

kill
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Nel caso volessi chiudere tutti i programmi legati al mio terminale, mi
 basta lanciare il comando 
\begin_inset Quotes eld
\end_inset

exit
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsection
Nohup
\end_layout

\begin_layout Standard
Nel caso volessimo lanciare un programma e assicurarci che continui la sua
 esecuzione anche nel caso in cui il nostro sistema ci forza l'uscita, o
 veniamo sloggati o accidentalmente chiudiamo il nostro terminale, allora
 in questi casi si rivela utile l'utilizzo del comando 
\begin_inset Quotes eld
\end_inset

nohup
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Itemize
nohup commandName //lancia il comando in modalità 
\begin_inset Quotes eld
\end_inset

nohup
\begin_inset Quotes erd
\end_inset

, il programma continua a essere in 
\begin_inset Quotes eld
\end_inset

running
\begin_inset Quotes erd
\end_inset

, possiamo comunque concludere la sua esecuzione con un'operazione di kill
 come ad esempio: kill -9 processID
\end_layout

\begin_layout Standard
E' da tenere a mente che nohup creerà un file chiamato nohup.out che conterrà
 il contenuto dello standard output e dello standard error prodotto
\end_layout

\begin_layout Itemize
nohup commandName >/dev/null 2>&1 //in questo caso redirigo stdout e stderr
 in /dev/null
\end_layout

\begin_layout Standard
Per lanciare un processo in background, in modalità 
\begin_inset Quotes eld
\end_inset

nohup
\begin_inset Quotes erd
\end_inset

 possiamo effettuare:
\end_layout

\begin_layout Itemize
nohup programName & //lancia programName in background in modalità 
\begin_inset Quotes eld
\end_inset

nohup
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Un altro comando utile può essere:
\end_layout

\begin_layout Itemize
disown -a && exit //in questo caso tutti i processi attivi nella shell verranno
 lasciati in runnning e la shell verrà chiusa
\end_layout

\begin_layout Standard
La differenza tra nohup e disown, è che nohup è utilizzato all'avvio di
 un processo, mentre se un processo è già in running (ed è stato lanciato
 senza nohup) e vogliamo assicurarci che continui a runnare anche dopo la
 chiusura del terminale, allora possiamo sganciarlo dal terminale con 
\begin_inset Quotes eld
\end_inset

disown
\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_layout Itemize
disown -h [job-spec] where [job-spec] is the job number (like %1 for the
 first running job; find about your number with the jobs command) so that
 the job isn't killed when the terminal closes.
\end_layout

\begin_layout Standard
Suppose for some reason Ctrl+Z is also not working, go to another terminal,
 find the process id (using ps) and run:
\end_layout

\begin_layout Itemize
kill -20 PID && kill -18 PID //kill -20 (SIGTSTP) will suspend the process
 and kill -18 (SIGCONT) will resume the process, in background.
 So now, closing both your terminals won't stop your process.
 
\end_layout

\begin_layout Subsection
Lsof
\end_layout

\begin_layout Standard
Il programma lsof permette di capire quali file sono aperti dai vari processi,
 infatti lsof sta per 
\begin_inset Quotes eld
\end_inset

list opened files
\begin_inset Quotes erd
\end_inset

, vediamo alcuni esempi applicativi:
\end_layout

\begin_layout Itemize
lsof //elenca i file aperti col relativo proprietario e PID
\end_layout

\begin_layout Itemize
lsof /percorso/nomeFile //mostra il programma che tiene aperto il file indicato
 nel comando con relative informazioni, utile quando vogliamo smontare device
 ad esempio e non ci riusciamo, in quanto bloccati da qualche processo
\end_layout

\begin_layout Itemize
lsof -p 2589 //mostra informazioni relative ai file aperti dal processo
 con PID 2589
\end_layout

\begin_layout Itemize
lsof -i //mostra informazioni su tutti i processi attivi su tutte le porte,
 utile alternativa veloce a netstat/ss, se al posto di numeri di porta vediamo
 nomi relativi a servizi, ad esempio 
\begin_inset Quotes eld
\end_inset

nomeServizio
\begin_inset Quotes erd
\end_inset

 o 
\begin_inset Quotes eld
\end_inset

rtsp
\begin_inset Quotes erd
\end_inset

, allora cerchiamo questa stringa all'interno del file 
\begin_inset Quotes eld
\end_inset

/etc/services
\begin_inset Quotes erd
\end_inset

, ad esempio con un comodo grep oppure vedere il comando successivo
\end_layout

\begin_layout Itemize
lsof -i -n -P //mostra informazioni su tutti i processi attivi su tutte
 le porte, utile alternativa veloce a netstat/ss, in questo caso ci viene
 mostrato il nome della porta senza eventuale associazione del servizio
 basata sul file /etc/services
\end_layout

\begin_layout Itemize
lsof -i :80 //mostra tutti i processi attivi sulla porta 
\begin_inset Quotes eld
\end_inset

80
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
lsof -i :80 | grep LISTEN //mostra tutti i processi attivi sulla porta 
\begin_inset Quotes eld
\end_inset

80
\begin_inset Quotes erd
\end_inset

 nello stato 
\begin_inset Quotes eld
\end_inset

LISTEN
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
lsof -i -P -n :80 //visualizza quali processi stanno ascoltandando sulla
 porta 80
\end_layout

\begin_layout Itemize
lsof -i@172.16.12.5 //mostra connessioni aperte con l'indirizzo ip specificato
\end_layout

\begin_layout Itemize
lsof -i@172.16.12.5:22 //mostra connessioni aperte con l'indirizzo ip e la
 porta specificati
\end_layout

\begin_layout Itemize
lsof -iTCP //mostra solo le connessioni TCP
\end_layout

\begin_layout Itemize
lsof -iUDP //mostra solo le connessioni UDP
\end_layout

\begin_layout Itemize
lsof -i 6 //mostra solo il traffico ipv6
\end_layout

\begin_layout Itemize
lsof -i | grep -i LISTEN //mostra porte in ascolto che aspettanno connessioni
\end_layout

\begin_layout Itemize
lsof -i | grep -i ESTABLISHED //mostra connessioni stabilite
\end_layout

\begin_layout Itemize
lsof -u daniel //mostra i file aperti dall'utente 
\begin_inset Quotes eld
\end_inset

daniel
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
lsof -u ^daniel //mostra i file aperti da tutti gli utenti eccetto l'utente
 
\begin_inset Quotes eld
\end_inset

daniel
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
kill -9 `lsof -t -u daniel` //killiamo tutti i processi aperti dall'utente
 
\begin_inset Quotes eld
\end_inset

daniel
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
lsof -c nomeprogramma //vediamo l'elenco dei file e delle connessioni aperte
 dal programma specificato
\end_layout

\begin_layout Itemize
lsof +D /directory/ //mostra per ogni file aperto della directory indicata
 il processo che lo sta utilizzando con le relative informazioni
\end_layout

\begin_layout Itemize
lsof -u nomeUtente //mostra tutti i file aperti dall'utente 
\begin_inset Quotes eld
\end_inset

nomeUtente
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
kill -9 `lsof -t -u nomeUtente` //il flag 
\begin_inset Quotes eld
\end_inset

-t
\begin_inset Quotes erd
\end_inset

 permette di mostrare solo il PID relativo ai processi richiesti in questo
 modo riusciamo ad eseguire comandi sui processi, come in questo caso che
 viene usato kill per uccidere tutti i processi appartenenti all'utente
 
\begin_inset Quotes eld
\end_inset

nomeUtente
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
lsof -n -P -c nomeComando //elenca tutti i file aperti dal comando 
\begin_inset Quotes eld
\end_inset

nomeComando
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
lsof -n -P -u nomeUtente //elenca tutti i file aperti dall'utente menzionato
\end_layout

\begin_layout Itemize
sudo lsof -iTCP:631 -sTCP:LISTEN //guarda chi è in ascolto sulla porta TCP
 631, citando il process name
\end_layout

\begin_layout Standard
un'alternativa ad lsof è 
\begin_inset Quotes eld
\end_inset

fuser
\begin_inset Quotes erd
\end_inset

, vediamo alcuni esempi:
\end_layout

\begin_layout Itemize
fuser -v /mnt/myUsb //visualizza tutti i processi aperti (PID) relativi
 alla directory menzionata
\end_layout

\begin_layout Itemize
fuser -v -k /mnt/myDir //termina tutti i processi utilizzanti una determinata
 directory/file
\end_layout

\begin_layout Itemize
fuser -v -k -i /mnt/usb //termina tutti i processi utilizzanti una determinata
 directory/file interattivamente
\end_layout

\begin_layout Standard
nelle tabelle presentate da fuser, la simbologia è:
\end_layout

\begin_layout Itemize
c current directory 
\end_layout

\begin_layout Itemize
e executable being run 
\end_layout

\begin_layout Itemize
f open file.
 f is omitted in default display mode 
\end_layout

\begin_layout Itemize
F open file for writing.
 F is omitted in default display mode 
\end_layout

\begin_layout Itemize
r root directory 
\end_layout

\begin_layout Itemize
m mmap’ed file or shared library 
\end_layout

\begin_layout Subsection
Gestione dei demoni e dei processi
\end_layout

\begin_layout Standard
Storicamente (e ancora su alcune distro) il gestore di inizializzazione
 dei servizi su GNU/Linux è stato 
\begin_inset Quotes eld
\end_inset

sysVinit
\begin_inset Quotes erd
\end_inset

, che prevedeva un processo iniziale con PID=1 chiamato init, padre di tutti
 i processi e un insieme di 6 runlevel (stati del sistema) tra cui switchare.
 Oggigiorno la maggior parte delle distro più famose usa un gestore di inizializ
zazione dei servizi chiamato 
\begin_inset Quotes eld
\end_inset

systemd
\begin_inset Quotes erd
\end_inset

, che ha una gestione dei processi e dei demoni molto più complessa.
 Per capire quale systema di inizializzazione dei processi utilizza il nostro
 sistema possiamo effettuare:
\end_layout

\begin_layout Itemize
cat /proc/1/comm //stampa sullo standard output il comando relativo al processo
 con PID=1
\end_layout

\begin_layout Standard
Possiamo capire quale gestore dei demoni abbiamo anche attraverso questa
 strategia:
\end_layout

\begin_layout Standard
Before proceeding, you need to determine your system’s version of init.
 If you’re not sure, check your system as follows: 
\end_layout

\begin_layout Itemize
If your system has /usr/lib/systemd and /etc/systemd directories, you have
 systemd.
 Go to 6.4 systemd.
 
\end_layout

\begin_layout Itemize
If you have an /etc/init directory that contains several .conf files, you’re
 probably running Upstart (unless you’re running Debian 7, in which case
 you probably have System V init).
 Go to 6.5 Upstart.
 
\end_layout

\begin_layout Itemize
If neither of the above is true, but you have an /etc/inittab file, you’re
 probably running System V init.
 Go to 6.6 System V init.
 If your system has manual pages installed, viewing the init(8) manual page
 should help identify your version.
\end_layout

\begin_layout Subsubsection
SysVinit
\end_layout

\begin_layout Standard
Il sistema di gestione servizi sysVinit è molto semplice, in pratica è basato
 su 6 runlevel del sistema, ad ogni runlevel possiamo associare degli script.
 In pratica la totalità degli script vive nella directory 
\begin_inset Quotes eld
\end_inset

/etc/init.d/
\begin_inset Quotes erd
\end_inset

 questa directory contiene gli script che si occupano di lanciare o terminare
 i processi; in pratica l'inizio, il riavvio o la terminazione di un processo
 possono coinvolgere tutta una serie di passi da seguire, da qui la necessità
 di associare degli script ai processi.
 Però uno script associato ad un servizio che viene messo in questa directory
 non combinerà nulla, infatti se vogliamo runnare un determinato servizio,
 allora dovremmo creare un link simbolico in una delle directory 
\begin_inset Quotes eld
\end_inset

/etc/rc.x/
\begin_inset Quotes erd
\end_inset

 (dove 
\begin_inset Quotes eld
\end_inset

x
\begin_inset Quotes erd
\end_inset

 rappresenta il runlevel).
\end_layout

\begin_layout Subsubsection
Systemd
\end_layout

\begin_layout Standard
Systemd permette all'utente di creare diversi 
\begin_inset Quotes eld
\end_inset

stati
\begin_inset Quotes erd
\end_inset

 che forniscono all'utente un meccanismo flessibile per creare diverse configura
zioni in cui effettuare 
\begin_inset Quotes eld
\end_inset

boot
\begin_inset Quotes erd
\end_inset

, questi stati sono composti da più 
\begin_inset Quotes eld
\end_inset

unit file
\begin_inset Quotes erd
\end_inset

 che messi assieme formano i cosiddetti 
\begin_inset Quotes eld
\end_inset

target
\begin_inset Quotes erd
\end_inset

, i target hanno nomi significativi al posto di semplici numeri come avveniva
 in sysVinit, e gli 
\begin_inset Quotes eld
\end_inset

unit file
\begin_inset Quotes erd
\end_inset

 gestiscono servizi, socket, e mount.
 Gli 
\begin_inset Quotes eld
\end_inset

unit file
\begin_inset Quotes erd
\end_inset

 sono collocati in due directory:
\end_layout

\begin_layout Itemize
/etc/systemd/sytem/ //directory delegata a contenere gli unit file creati
 dall'utente e ha priorità sulla seconda
\end_layout

\begin_layout Itemize
/usr/lib/systemd/system/ //directory delegata a contenere gli unit file
 non creati dall'utente
\end_layout

\begin_layout Itemize
/lib/systemd/system/ //directory delegata a contenere gli unit file non
 creati dall'utente
\end_layout

\begin_layout Standard
Al boot systemd attiva di default il runlevel inteso dal file 
\begin_inset Quotes eld
\end_inset

default.target
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
I classici 6 runlevel di 
\begin_inset Quotes eld
\end_inset

sysVinit
\begin_inset Quotes erd
\end_inset

 sono sostituiti generalmente dai cosiddetti 
\begin_inset Quotes eld
\end_inset

target
\begin_inset Quotes erd
\end_inset

, vediamo i principali:
\end_layout

\begin_layout Itemize
systemd.unit=rescue.target //è un runlevel special per impostare le configurazioni
 di base o effettuare un recovery del sistema
\end_layout

\begin_layout Itemize
systemd.unit=emergency.target //è una bash shell, con la possibilità di avviare
 l'intero sistema
\end_layout

\begin_layout Itemize
systemd.unit=multi-user.target //avvia un sistema multi utente non grafico;
\end_layout

\begin_layout Itemize
systemd.unit=graphical.target //avvia un sistema multi utente grafico;
\end_layout

\begin_layout Standard
Per ulteriori dettagli su questi target e su altri target è consigliato
 eseguire un:
\end_layout

\begin_layout Itemize
man systemd.special //visualizza un man con la descrizione dei vari target
 possibili
\end_layout

\begin_layout Standard
Lo strumento principale per gestire i servizi con systemd è costituito dal
 programma 
\begin_inset Quotes eld
\end_inset

systemctl
\begin_inset Quotes erd
\end_inset

, vediamone alcuni esempi:
\end_layout

\begin_layout Itemize
systemctl //visualizza lo stato ed una breve descrizione di tutti i servizi
 presenti, è utilie se utilizzato in combinazione con 
\begin_inset Quotes eld
\end_inset

systemd-analyze blame
\begin_inset Quotes erd
\end_inset

 per capire cosa parte all'avvio
\end_layout

\begin_layout Itemize
systemctl start foo //avvia il servizio foo
\end_layout

\begin_layout Itemize
systemctl stop foo //ferma il servizio foo
\end_layout

\begin_layout Itemize
systemctl restart foo //riavvia il servizio foo
\end_layout

\begin_layout Itemize
systemctl status foo //visualizza lo stato del servizio foo
\end_layout

\begin_layout Itemize
systemctl enable foo //abilita il servizio foo, in questo modo, anche se
 riavvio il sistema, il servizio foo si avvia in automatico
\end_layout

\begin_layout Itemize
systemctl disable foo //disabilita il servizio foo, in questo modo, non
 si avvierà in automatico per i prossimi riavvi di sistema
\end_layout

\begin_layout Itemize
systemctl reload foo //ricarica i file di configurazione del servizio foo,
 utile quando cambiamo qualche configurazione
\end_layout

\begin_layout Itemize
systemctl daemon-reload //riavvia tutti i servizi e ricrea tutto l'albero
 di dipendenze dei servizi
\end_layout

\begin_layout Itemize
systemctl mask foo //nasconde un servizio, prevenendo quindi l'avvio automatico
 dinamico o anche manuale
\end_layout

\begin_layout Itemize
systemctl list-dependencies foo //elenca le dipendenze del servizio foo
\end_layout

\begin_layout Itemize
systemctl is-enabled foo //controlla se il servizio foo è attivo
\end_layout

\begin_layout Standard
E' da notare che systemd è compatibile con sysVinit, quindi i servizi possono
 anche essere gestiti attraverso i comandi start, stop, restart ecc...
 ad esempio:
\end_layout

\begin_layout Itemize
service NetworkManager stop //ferma il servizio chiamato 
\begin_inset Quotes eld
\end_inset

NetworkManager
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
può essere usato al posto di:
\end_layout

\begin_layout Itemize
systemctl stop NetworkManager //ferma il servizio chiamato 
\begin_inset Quotes eld
\end_inset

NetworkManager
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Possiamo passare dinamicamente da un target all'altro durante una sessione
 attraverso:
\end_layout

\begin_layout Itemize
systemctl isolate multi-user.target //entra nel target multi-user, che è
 simile al classico runlevel 3 di sysVinit
\end_layout

\begin_layout Itemize
systemctl isolate graphical.target //entra nel target graphical, che è simile
 al classico runlevel 5 di sysVinit
\end_layout

\begin_layout Standard
per cambiare il target default possiamo invece effettuare:
\end_layout

\begin_layout Itemize
systemctl set-default <nome del target>.target //cambia il target di default
 a 
\begin_inset Quotes eld
\end_inset

nome del target
\begin_inset Quotes erd
\end_inset

, è l'operazione analoga al cambio del runlevel di default su sysVinit
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
E' da notare che quello che viene effettuato in realtà quando viene lanciato
 questo comando è: 
\begin_inset Quotes eld
\end_inset

ln -sf /lib/systemd/system/<nome del target>.target /etc/systemd/system/default.ta
rget
\begin_inset Quotes erd
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
Altre istruzioni utili sono:
\end_layout

\begin_layout Itemize
systemctl get-default //mostra il target presente
\end_layout

\begin_layout Standard
Mentre un'altra directory utile in alcune distro è /etc/init.d/, questa directory
 viene dal sistema sysVinit e contiene gli script che si occupano di lanciare
 o terminare i processi; in pratica l'inizio, il riavvio o la terminazione
 di un processo possono coinvolgere tutta una serie di passi da seguire,
 da qui la necessità di associare degli script ai processi.
 Vediamo ora alcuni altri comandi che utilizzano systemd:
\end_layout

\begin_layout Itemize
systemd-analyze //analizza i tempi di boot, nel caso in cui non si usi systemd,
 questo comando può essere sostituito attraverso il programma 
\begin_inset Quotes eld
\end_inset

bootchart
\begin_inset Quotes erd
\end_inset

 o programmi che raccolgono e analizzano dati dal processo di boot
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
attenzione, in quanto su sistemi con firmware BIOS systemd non può ottenere
 come dato il tempo che questo ci ha messo ad inizializzarsi e a fare le
 sue cose, mentre con sistemi con firmware UEFI, il firmware fornisce dati
 al kernel come il tempo di avvio, vedremo infatti sui sistemi UEFI una
 voce aggiuntiva chiamata 
\begin_inset Quotes eld
\end_inset

firmware
\begin_inset Quotes erd
\end_inset

 questa si riferisce proprio al tempo di caricamento del firmware UEFI,
 un'altra voce aggiuntiva che incontriamo sui sistemi UEFI è 
\begin_inset Quotes eld
\end_inset

loader
\begin_inset Quotes erd
\end_inset

 questo è il tempo impiegato dal bootloader
\end_layout

\end_deeper
\begin_layout Itemize
systemd-analyze blame //visualizza i tempi di boot per ogni servizio al
 boot
\end_layout

\begin_layout Itemize
systemd-analyze plot > graph.svg //mi salva un'immagine con un grafico dei
 tempi di boot
\end_layout

\begin_layout Itemize
systemd-analyze crotical-chain //mi mostra il collo di bottiglia del sistema,
 visualizzando i target di systemd più esosi
\end_layout

\begin_layout Itemize
journalctl -u nomeServizio //visualizza il log relativo al servizio indicato
\end_layout

\begin_layout Itemize
systemctl status nomeServizio //fornisce informazioni sul servizio, come
 il file che lo avvia, il PID, eccetera
\end_layout

\begin_layout Itemize
systemctl list-dependencies –reverse nomeServizio //mostra in quale target
 è avviato il servizio indicato nel comando
\end_layout

\begin_layout Itemize
sudo systemctl show NetworkManager|grep FragmentPath //mostra il nome dello
 script che avvia il servizio
\end_layout

\begin_layout Standard
Attraverso i comandi sopracitati, possiamo quindi tenere sotto controllo
 il sistema, sapendo cosa viene avviato, quando viene avviato e da cosa
 (quale script, programma) viene avviato.
\end_layout

\begin_layout Paragraph
Creare un servizio per systemd
\end_layout

\begin_layout Standard
Per creare un servizio, dobbiamo creare uno 
\begin_inset Quotes eld
\end_inset

unit file
\begin_inset Quotes erd
\end_inset

, uno unit file molto minimale potrebbe essere:
\end_layout

\begin_layout Standard
——————————————————————————–——————————————–
\end_layout

\begin_layout Standard
[Unit]
\end_layout

\begin_layout Standard
Description=Possiamo inserire una breve descrizione del servizio qui
\end_layout

\begin_layout Standard
After=default.target
\end_layout

\begin_layout Standard
[Install]
\end_layout

\begin_layout Standard
WantedBy=default.target
\end_layout

\begin_layout Standard
[Service]
\end_layout

\begin_layout Standard
Type=forking
\end_layout

\begin_layout Standard
ExecStart=/usr/local/bin/myScript
\end_layout

\begin_layout Standard
——————————————————————————–——————————————–
\end_layout

\begin_layout Standard
Dove:
\end_layout

\begin_layout Itemize
nella sezione [Unit] indichiamo quando deve essere avviato rispetto a default.tar
get
\end_layout

\begin_layout Itemize
nella sezione [Install] indichiamo che è richiesto quando viene lanciato
 default.target
\end_layout

\begin_layout Itemize
nella sezione [Service] il Type=forking è necessario, in quanto nel nostro
 esempio stiamo eseguendo uno script di shell, in caso contrario dobbiamo
 eliminarlo, mentre in ExecStart indichiamo il programma da eseguire
\end_layout

\begin_layout Standard
Per installarlo spostiamo (o creiamo un link) il file all'interno della
 directory 
\begin_inset Quotes eld
\end_inset

/etc/systemd/system
\begin_inset Quotes erd
\end_inset

 ed eseguiamo:
\end_layout

\begin_layout Itemize
systemctl –system enable nomeServizio //dove nomeServizio è il nome del
 file
\end_layout

\begin_layout Standard
Possiamo verificare al prossimo riavvio se il modulo è stato caricato, col
 comando:
\end_layout

\begin_layout Itemize
systemctl –failed //visualizza i moduli che non sono stati caricati correttament
e
\end_layout

\begin_layout Standard
Se il nostro modulo è presente in questa lista, allora non è stato caricato
 correttamente e possiamo ispezionare il problema con:
\end_layout

\begin_layout Itemize
systemctl status nomeModulo //visualizza lo status del modulo	
\end_layout

\begin_layout Subsection
Superdaemons e xinet.d
\end_layout

\begin_layout Standard
Nei sistemi GNU/Linux esistono anche demoni particolari detti 
\begin_inset Quotes eld
\end_inset

superdemoni
\begin_inset Quotes erd
\end_inset

, questi superdemoni non sono altro che demoni il cui scopo è gestire altri
 demoni, uno dei più famosi è 
\begin_inset Quotes eld
\end_inset

xinet.d
\begin_inset Quotes erd
\end_inset

, che ha sostituito l'ormai obsoleto 
\begin_inset Quotes eld
\end_inset

inet.d
\begin_inset Quotes erd
\end_inset

, ma esistono anche altri pacchetti software che ci permettono di installare
 superdemoni.
\end_layout

\begin_layout Section
Mail
\end_layout

\begin_layout Standard
We'll use postfix as MTA, but there is even exim;
\end_layout

\begin_layout Itemize
sudo apt-get install postfix
\end_layout

\begin_layout Standard
then we run
\end_layout

\begin_layout Itemize
service postfix start //to start the service, or systemctl start postfix
\end_layout

\begin_layout Standard
The path where mail for individual users are stored is 
\begin_inset Quotes eld
\end_inset

/var/mail
\begin_inset Quotes erd
\end_inset

, l'utente root invece è diverso dagli altri utenti, in quanto lui può ricevere
 mail dal kernel, o dal sistema operativo per diversi avvisi.
 Vediamo alcuni esempi:
\end_layout

\begin_layout Itemize
mail -s 
\begin_inset Quotes eld
\end_inset

Questo è l'oggetto
\begin_inset Quotes erd
\end_inset

 indirizzo@mail //mandiamo una mail, all'indirizzo mail indicato, al posto
 dell'indirizzo avremmo potuto mettere anche il nome di qualche utente del
 sistema, una volta premuto invio, possiamo scrivere la mail, e terminare
 l'inserimento del corpo con 
\begin_inset Quotes eld
\end_inset

Ctrl+D
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
E' utile fare script ad esempio che mandano mail in automatico, ad esempio
 per scrivere direttamente mail con un file di corpo predefinito chiamato
 
\begin_inset Quotes eld
\end_inset

body.txt
\begin_inset Quotes erd
\end_inset

, possiamo effettuare, all'interno dello script l'istruzione:
\end_layout

\begin_layout Itemize
mail -s 
\begin_inset Quotes eld
\end_inset

Lo script è completato
\begin_inset Quotes erd
\end_inset

 < /root/bin/body.txt root
\end_layout

\begin_layout Standard
Per leggere le mail possiamo effettuare:
\end_layout

\begin_layout Itemize
mail -u //questo comando visualizzerà la lista delle mail, e aspetterà un
 input, ci basterà inserire l'id della mail interessata per leggerla, e
 schiacciare poi:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

r
\begin_inset Quotes erd
\end_inset

 per rispondere alla mail, e 
\begin_inset Quotes eld
\end_inset

Ctrl+D
\begin_inset Quotes erd
\end_inset

 per mandare la risposta una volta finito l'inserimento
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

d
\begin_inset Quotes erd
\end_inset

 per cancellare la mail
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

q
\begin_inset Quotes erd
\end_inset

 per uscire dal programma
\end_layout

\end_deeper
\begin_layout Standard
oppure per leggere la mail queue, cioè la coda di email (è dove le mail
 vengono salvate nel caso non riuscissero ad arrivare al server di destinazione,
 per motivi di diversa natura)
\end_layout

\begin_layout Subsection
Inoltro delle mail
\end_layout

\begin_layout Standard
Un altro file importante, è 
\begin_inset Quotes eld
\end_inset

/etc/aliases
\begin_inset Quotes erd
\end_inset

, questo file gestisce gli alias degli utenti, ad esempio nel caso volessi
 che sia i messaggi che arrivano a giuseppe arrivino anche a root, allora
 inserisco una riga con scritto:
\end_layout

\begin_layout Itemize
giuseppe: root //aggiunge un alias, potrebbe essere utile, nel caso bloccassimo
 degli utenti, o non ci dovessero essere più, ma abbiamo comunque bisogno
 di ricevere la mail al posto dell'utente giuseppe
\end_layout

\begin_layout Standard
possiamo ora lanciare 
\begin_inset Quotes eld
\end_inset

newaliases
\begin_inset Quotes erd
\end_inset

 per aggiornare gli alias degli utenti
\end_layout

\begin_layout Standard
Un'altra tecnica utilizzabile per l'inoltro delle mail è quella di creare
 un file chiamato 
\begin_inset Quotes eld
\end_inset

.forward
\begin_inset Quotes erd
\end_inset

 nella home directory di un utente, in questo file ci basta scrivere il
 nome utente a cui inoltrare le mail.
\end_layout

\begin_layout Section
Informazioni sul Sistema e Diagnostica
\end_layout

\begin_layout Subsection
Overview del Processo di Boot
\end_layout

\begin_layout Standard
A simplified view of the boot process looks like this: 
\end_layout

\begin_layout Enumerate
The machine’s BIOS or boot firmware loads and runs a boot loader.
\end_layout

\begin_layout Enumerate
The boot loader finds the kernel image on disk, loads it into memory, and
 starts it.
\end_layout

\begin_layout Enumerate
The kernel initializes the devices and its drivers.
 
\end_layout

\begin_layout Enumerate
The kernel mounts the root filesystem.
\end_layout

\begin_layout Enumerate
The kernel starts a program called init with a process ID of 1.
 This point is the user space start.
 
\end_layout

\begin_layout Enumerate
init sets the rest of the system processes in motion.
 
\end_layout

\begin_layout Enumerate
At some point, init starts a process allowing you to log in, usually at
 the end or near the end of the boot.
\end_layout

\begin_layout Standard
Inoltre allo startup, il kernel Linux effettua le inizializzazioni in quest'ordi
ne:
\end_layout

\begin_layout Enumerate
CPU Inspection
\end_layout

\begin_layout Enumerate
Memory Inspection
\end_layout

\begin_layout Enumerate
Device bus Discovery
\end_layout

\begin_layout Enumerate
Device discovery
\end_layout

\begin_layout Enumerate
Auxiliary kernel subsystem setup (networking, and so on)
\end_layout

\begin_layout Enumerate
Root filesystem mount
\end_layout

\begin_layout Enumerate
User space start
\end_layout

\begin_layout Standard
Solitamente i messaggi di boot sono contenuti in /var/log/kern.log ma dipende
 molto da come è configurato il sistema, possiamo ad esempio visualizzarli
 con 
\begin_inset Quotes eld
\end_inset

dmesg
\begin_inset Quotes erd
\end_inset

 o attraverso il nostro gestore di demoni, in quanto a volte il sistema
 cancella quei messaggi.
\end_layout

\begin_layout Subsection
Log
\end_layout

\begin_layout Subsubsection
Come visualizzare i Log
\end_layout

\begin_layout Standard
La directory /var contiene file che variano nel tempo, la directory 
\begin_inset Quotes eld
\end_inset

/var/log
\begin_inset Quotes erd
\end_inset

 contiene i log di sistema.
\end_layout

\begin_layout Itemize
tail -n 20 nomeFile //mi visualizza le ultime 20 linee, molto comodo per
 alcuni tipi di log file
\end_layout

\begin_layout Itemize
tail -n +2 nomeFile //visualizza tutto il file tranne la prima riga, considera
 che con +1 stampa tutto il file, quindi in + dobbiamo mettere il numero
 di righe che vogliamo escludere +1
\end_layout

\begin_layout Itemize
less //da less possiamo premere 
\begin_inset Quotes eld
\end_inset

-F
\begin_inset Quotes erd
\end_inset

 per entrare in modalità tail -f
\end_layout

\begin_layout Itemize
tail -f nomefile //rimane nel file in attesa di altre scritture, quindi
 ho una visualizzazione real time del file
\end_layout

\begin_layout Itemize
tail -100f nomefile //rimane nel file in attesa di altre scritture, quindi
 ho una visualizzazione real time del file, ma parto da almeno da 100 righe
 di visualizzazione, se disponibili
\end_layout

\begin_layout Itemize
head -n 20 nomeFile //mi visualizza le prime 20 linee, molto comodo per
 alcuni tipi di log file o file di configurazione
\end_layout

\begin_layout Itemize
watch -n 3 nomeFile //aggiorna il file sullo standard ouput, in tempo reale,
 ogni 3 secondi, utilizzato ad esempio con 
\begin_inset Quotes eld
\end_inset

/proc/net/wireless
\begin_inset Quotes erd
\end_inset

 per monitorare la qualità del segnale wifi
\end_layout

\begin_layout Standard
Un file per vedere i login è 
\begin_inset Quotes eld
\end_inset

/var/log/secure
\begin_inset Quotes erd
\end_inset

 sulle RedHat based mentre sulle Debian based è 
\begin_inset Quotes eld
\end_inset

var/log/auth.log
\begin_inset Quotes erd
\end_inset

.
 Per vedere i messaggi al boot possono esistere diversi file, a volte vengono
 salvati in 
\begin_inset Quotes eld
\end_inset

/var/log/dmesg
\begin_inset Quotes erd
\end_inset

, altre in 
\begin_inset Quotes eld
\end_inset

/var/log/boot
\begin_inset Quotes erd
\end_inset

 o in 
\begin_inset Quotes eld
\end_inset

var/log/syslog
\begin_inset Quotes erd
\end_inset

, questo dipende dalla distribuzione e dalla versione della distribuzione.
 Un reference per i file di log più comuni può essere 
\begin_inset CommandInset href
LatexCommand href
name "File di Log più comuni"
target "http://www.thegeekstuff.com/2011/08/linux-var-log-files/"

\end_inset

.
\end_layout

\begin_layout Standard
per copiare ed eliminare cartelle si usa cp e rm col flag -r, se uso anche
 il flag -f non gli importa dei parametri non esistenti, cancella tutto
 quello che può.
\end_layout

\begin_layout Subsubsection
Rsyslog e Syslog
\end_layout

\begin_layout Standard
Rsyslog e Syslog costituiscono due sistemi di gestione dei log, le distro
 Debian-based utilizzano rsyslogd, ma i concetti sono praticamente uguali
 ed anche i file di configurazione, rsyslog ci permette di gestire i log
 di vari programmi e con che livello di dettaglio riceverli.
 I file di configurazione di rsyslog, sono nella directory 
\begin_inset Quotes eld
\end_inset

/etc/
\begin_inset Quotes erd
\end_inset

, il file di configurazione principale è 
\begin_inset Quotes eld
\end_inset

rsyslog.conf
\begin_inset Quotes erd
\end_inset

, mentre 
\begin_inset Quotes eld
\end_inset

rsyslog.d
\begin_inset Quotes erd
\end_inset

 è una directory che contiene altri file di configurazione di rsyslog che
 vengono applicati.
 L'unica differenza tra che interessa a noi tra rsyslog e syslog è che il
 file di configurazione principale nel caso di syslog invece di chiamarsi
 
\begin_inset Quotes eld
\end_inset

rsyslog.conf
\begin_inset Quotes erd
\end_inset

 si chiama 
\begin_inset Quotes eld
\end_inset

syslog.conf
\begin_inset Quotes erd
\end_inset

 e la directory contenente gli script anzichè chiamarsi 
\begin_inset Quotes eld
\end_inset

rsyslog.d
\begin_inset Quotes erd
\end_inset

 si chiama 
\begin_inset Quotes eld
\end_inset

syslog.d
\begin_inset Quotes erd
\end_inset

.
 Vediamo un esempio di file 
\begin_inset Quotes eld
\end_inset

/etc/rsyslog.conf
\begin_inset Quotes erd
\end_inset

 (che potrebbe anche essere 
\begin_inset Quotes eld
\end_inset

syslog.conf
\begin_inset Quotes erd
\end_inset

):
\end_layout

\begin_layout Standard
——————————————————————————–—
\end_layout

\begin_layout Standard
$IncludeConfig /etc/rsyslog.d/*.conf #include i file di configurazione all'interno
 della directory specificata
\end_layout

\begin_layout Standard
cron.* /var/log/cron #indica che tutti i file di log di cron, sono contenuti
 nella directory indicata
\end_layout

\begin_layout Standard
*.emerg /var/log/emergency #indica che tutti i messaggi di tipo emergency
 devono essere collocati nella directory indicata
\end_layout

\begin_layout Standard
uucp,news.crit /var/log/spooler #indica che tutti i file di log di uucp di
 tipo 
\begin_inset Quotes eld
\end_inset

critico
\begin_inset Quotes erd
\end_inset

 e di news di tipo 
\begin_inset Quotes eld
\end_inset

critico
\begin_inset Quotes erd
\end_inset

 
\end_layout

\begin_layout Standard
#vengono salvati nella directory indicata
\end_layout

\begin_layout Standard
#la virgola ci permette di indicare più programmi contemporaneamente, mentre
 il punto, indica il livello di gravità dei messaggi
\end_layout

\begin_layout Standard
#auth.emerg; uucp, news.crit /var/log/auth #indica che i messaggi di log di
 tipo emergency del programma auth e i 
\end_layout

\begin_layout Standard
#messaggi di tipo critical dei programmi uucp e news verranno salvati nella
 directory indicata, il simbolo 
\begin_inset Quotes erd
\end_inset

;
\begin_inset Quotes erd
\end_inset

 
\end_layout

\begin_layout Standard
#è utilizzato per separare programmi con diversi tipi di messaggi
\end_layout

\begin_layout Standard
——————————————————————————–—
\end_layout

\begin_layout Standard
La stringa dopo il punto indica il cosiddetto 
\begin_inset Quotes eld
\end_inset

severity level
\begin_inset Quotes erd
\end_inset

 dei messaggi (7 = debug, 6 = info, 5 = notice, 4 = warning, 3 = err, 2
 = crit, 1 = alert, 0 = emerg, x = nothing), vediamo una spiegazione dettagliata
:
\end_layout

\begin_layout Itemize
7 - DEBUG:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Info useful to developers for debugging the app, not useful during operations
\end_layout

\end_deeper
\begin_layout Itemize
6 - INFORMATIONAL:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Normal operational messages - may be harvested for reporting, measuring
 throughput, etc - no action required
\end_layout

\end_deeper
\begin_layout Itemize
5 - NOTICE:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Events that are unusual but not error conditions - might be summarized in
 an email to developers or admins to spot potential problems - no immediate
 action required
\end_layout

\end_deeper
\begin_layout Itemize
4 - WARNING:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Warning messages - not an error, but indication that an error will occur
 if action is not taken, e.g.
 file system 85% full - each item must be resolved within a given time
\end_layout

\end_deeper
\begin_layout Itemize
3 - ERROR:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Non-urgent failures - these should be relayed to developers or admins; each
 item must be resolved within a given time
\end_layout

\end_deeper
\begin_layout Itemize
2 - ALERT:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Should be corrected immediately - notify staff who can fix the problem -
 example is loss of backup ISP connection
\end_layout

\end_deeper
\begin_layout Itemize
1 - CRITICAL:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Should be corrected immediately, but indicates failure in a primary system
 - fix CRITICAL problems before ALERT - example is loss of primary ISP connectio
n
\end_layout

\end_deeper
\begin_layout Itemize
0 - EMERGENCY:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
A "panic" condition - notify all tech staff on call? (earthquake? tornado?)
 - affects multiple apps/servers/sites...
\end_layout

\end_deeper
\begin_layout Subsubsection
Logger
\end_layout

\begin_layout Standard
Il programma 
\begin_inset Quotes eld
\end_inset

logger
\begin_inset Quotes erd
\end_inset

 ci permette di scrivere nei file di log.
 Vediamo alcuni esempi applicativi:
\end_layout

\begin_layout Itemize
logger ciao will //manda il messaggio 
\begin_inset Quotes eld
\end_inset

ciao
\begin_inset Quotes erd
\end_inset

 all'interno del file di log 
\begin_inset Quotes eld
\end_inset

/var/log/messages
\begin_inset Quotes erd
\end_inset

, che è la directory di default in cui vengono scritti i log con logger
\end_layout

\begin_layout Itemize
logger -s error message //visualizza il messaggio 
\begin_inset Quotes eld
\end_inset

error message
\begin_inset Quotes erd
\end_inset

 sullo standard error, utile quando si scrivono script, come etichetta dell'erro
re viene visualizzato il nome dell'utente che ha lanciato il comando
\end_layout

\begin_layout Itemize
logger -t backupscript -s error message //visualizza il messaggio 
\begin_inset Quotes eld
\end_inset

error message
\begin_inset Quotes erd
\end_inset

 sullo standard error, utile quando si scrivono script, come autore dell'errore
 viene visualizzato 
\begin_inset Quotes eld
\end_inset

backupscript
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
logger -f /var/log/cron Ciao Errore //specifica il file di log in cui va
 a scrivere attraverso il flag 
\begin_inset Quotes eld
\end_inset

-f
\begin_inset Quotes erd
\end_inset

 (file)
\end_layout

\begin_layout Itemize
logger -pcrit ciao //specifica il livello di priorità attraverso il flag
 
\begin_inset Quotes eld
\end_inset

-p
\begin_inset Quotes erd
\end_inset

 che in questo caso è 
\begin_inset Quotes eld
\end_inset

critical
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
logger -t backup -i Error while trying to backup //scrive un errore nel
 file di default di log 
\begin_inset Quotes eld
\end_inset

/var/log/messages
\begin_inset Quotes erd
\end_inset

 con autore 
\begin_inset Quotes eld
\end_inset

backup
\begin_inset Quotes erd
\end_inset

 riportando anche il PID del process che l'ha generato, questo avviene attravers
o il flag 
\begin_inset Quotes eld
\end_inset

-i
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Subsubsection
Logrotate
\end_layout

\begin_layout Standard
Un programma molto utile per gestire i log è 
\begin_inset Quotes eld
\end_inset

logrotate
\begin_inset Quotes erd
\end_inset

, esiste un file chiamato 
\begin_inset Quotes eld
\end_inset

/etc/logrotate.conf
\begin_inset Quotes erd
\end_inset

 che è il file di configurazione generale di logrotate e poi una directory
 chiamata 
\begin_inset Quotes eld
\end_inset

/etc/logrotate.d
\begin_inset Quotes erd
\end_inset

 che contiene file di configurazione aggiuntivi che vengono applicati, infatti
 molti programmi che vengono installati, salvano un file in questa directory
 per non andare a sovrascrivere o mettere mano al file di configurazione
 principale.
 Nel file 
\begin_inset Quotes eld
\end_inset

logrotate.conf
\begin_inset Quotes erd
\end_inset

, c'è scritto per quanto tempo vengono tenuti in memoria i log ed altre
 informazioni, vediamo un esempio di un file di configurazione all'interno
 della directory 
\begin_inset Quotes eld
\end_inset

logrotate.d/apache2
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Standard
——————————————————————————–———-
\end_layout

\begin_layout Standard
/var/log/httpd/*log {
\end_layout

\begin_layout Standard
daily #lavora coi log su base giornaliera, altri esempi di opzioni valide
 sono 
\begin_inset Quotes eld
\end_inset

monthly
\begin_inset Quotes erd
\end_inset

 
\end_layout

\begin_layout Standard
#(prende come riferimento il primogiorno del mese) o 
\begin_inset Quotes eld
\end_inset

yearly
\begin_inset Quotes erd
\end_inset

 (prende come riferimento il primo giorno dell'anno)
\end_layout

\begin_layout Standard
missingok # se un file di configurazione non esiste, va bene lo stesso,
 passa al prossimo
\end_layout

\begin_layout Standard
rotate 2 # teniamo i file archiviati per due rotazioni, in questo caso due
 giorni e poi li eliminiamo
\end_layout

\begin_layout Standard
compress #comprimi i file di log, cioè anzichè creare una copia, crea un
 archivio in cui dentro viene inserita una copia
\end_layout

\begin_layout Standard
delaycompress #non vengono tutti compressi, ma prima vengono copiati al
 primo passi, e poi 
\end_layout

\begin_layout Standard
#alla rotazione successiva vengono archiviati
\end_layout

\begin_layout Standard
notifempty #non viene salvato nulla se i file di log sono vuoti, perchè
 sprecare risorse ?
\end_layout

\begin_layout Standard
create 640 root adm #assegna agli archivi creati il proprietario 
\begin_inset Quotes eld
\end_inset

root
\begin_inset Quotes erd
\end_inset

 e il gruppo 
\begin_inset Quotes eld
\end_inset

adm
\begin_inset Quotes erd
\end_inset

 e permessi 640
\end_layout

\begin_layout Standard
sharedscripts #condivide gli script che seguono per tutti i file i log,
 se non esistesse questa istruzione, 
\end_layout

\begin_layout Standard
#allora gli script che seguono verrebbero eseguiti per tutti i file di log
 di apache
\end_layout

\begin_layout Standard
postrotate /etc/init.d/apache2 reload >/dev/null #esegue uno script dopo
 la rotazione
\end_layout

\begin_layout Standard
endscript
\end_layout

\begin_layout Standard
prerotate if [-d /etc/logrotate.d/httpd-prerotate ]; then 
\backslash
 #esegue uno script prima di effettuare una rotazione
\end_layout

\begin_layout Standard
run-parts /etc/logrotate.d/httpd-prerotate; 
\backslash

\end_layout

\begin_layout Standard
fi; 
\backslash

\end_layout

\begin_layout Standard
endscript
\end_layout

\begin_layout Standard
——————————————————————————–———-
\end_layout

\begin_layout Subsection
Boot di un sistema GNU/Linux
\end_layout

\begin_layout Subsubsection
Principio di funzionamento del boot
\end_layout

\begin_layout Standard
Il boot di un sistema GNU/Linux è composto da varie fasi che si susseguono:
\end_layout

\begin_layout Enumerate
Power-Up/Reset: L'elettronica della macchina si accende
\end_layout

\begin_layout Enumerate
System Startup (BIOS/BootMonitor): Viene visualizzata la schermata di startup,
 vengono eseguite delle procedure basilari atte a verificare che l'hardware
 connesso sia funzionante, oppure assegnazione dei range di memoria, IRQ,
 DMA, eccetera.
 
\end_layout

\begin_layout Enumerate
Stage 1 bootloader (Master Boot Record): L'MBR è installato nel settore
 zero dell'Hard Disk quasi sempre (potrebbe anche essere installato in un
 altro settore), lo stage 1 ha lo scopo di capire dove è localizzato il
 Bootloader
\end_layout

\begin_layout Enumerate
Stage 2 bootloader (Lilo, Grub, etc...): Lo stage 2 ha lo scopo di localizzare
 i kernel presenti negli schemi di partizione
\end_layout

\begin_layout Enumerate
Kernel (Linux): In questa fase viene lanciato il kernel, vengono caricati
 i moduli eccetera.
\end_layout

\begin_layout Enumerate
Init/Systemd: Viene avviato il processo iniziale chiamato 
\begin_inset Quotes eld
\end_inset

init
\begin_inset Quotes erd
\end_inset

 (se si utilizza sysVinit) e questo processo termina l'avvio del sistema
 operativo e permette l'inizia dello user-space, quindi le applicazioni
 utente
\end_layout

\begin_layout Subsubsection
Log di Boot
\end_layout

\begin_layout Standard
Per visualizzare il log di boot di un sistema GNU/Linux dobbiamo visualizzare
 il file 
\begin_inset Quotes eld
\end_inset

/var/log/messages
\begin_inset Quotes erd
\end_inset

, quindi:
\end_layout

\begin_layout Itemize
cat 
\begin_inset Quotes eld
\end_inset

/var/log/messages
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
oppure eseguire:
\end_layout

\begin_layout Itemize
dmesg //visualizza tutte le informazioni a partire dal boot (dmesg sta per
 
\begin_inset Quotes eld
\end_inset

diagnostic message
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Itemize
dmesg -T|sed -e 's|
\backslash
(^.*'`date +%Y`']
\backslash
)
\backslash
(.*
\backslash
)|
\backslash
x1b[0;34m
\backslash
1
\backslash
x1b[0m - 
\backslash
2|g' //visualizza i messaggi di dmesg con un formato leggibile delle date
\end_layout

\begin_layout Itemize
dmesg -C //pulisce il log di dmesg
\end_layout

\begin_layout Itemize
echo "<n>Debug info" > /dev/kmsg //possiamo scrivere nei log del kernel
 anche da userspace
\end_layout

\begin_layout Subsection
Boot Loaders
\end_layout

\begin_layout Standard
All'inizio del processo di boot, prima che il kernel venga lanciato, l'obiettivo
 del boot loader sembra semplice, deve caricare il kernel in memoria e lanciarlo
 con un set di parametri, quindi le domande a cui il boot loader deve rispondere
 sono:
\end_layout

\begin_layout Itemize
Dove sono i kernel?
\end_layout

\begin_layout Itemize
Quali parametri devono essere passati al kernel al suo avvio?
\end_layout

\begin_layout Standard
Le risposte (tipicamente) sono che il kernel e i suoi parametri sono da
 qualche parte sul root filesystem.
\end_layout

\begin_layout Standard
Siccome i parametri da passare al kernel sono da qualche parte su uno degli
 hard disk, ho bisogno di relativi driver dell'hard disk per poterli trovare,
 e siccome non posso caricare i driver in quanto non ho ancora caricato
 il kernel, i boot loader risolvono il problema riuscendo ad accedere al
 disco per reperire i parametri attraverso le interfacce BIOS o UEFI; questo
 è possibile grazie al firmware sull'hardware dell'HDD che permette al BIOS
 o UEFI di accedere all'HDD, grazie agli LBA (Logical Block Addressing);
 nonostante siano accessi con performance molto povere, questo non ci interessa,
 in quanto una volta caricato il kernel, verranno caricati i suoi driver
 ad alte prestazioni; solitamente i boot loader sono gli unici programmi
 ad usare il BIOS o il UEFI per gli accessi al disco.
\end_layout

\begin_layout Standard
The filesystem question is trickier.
 Most modern boot loaders can read partition tables and have built-in support
 for read-only access to filesystems.
 Thus, they can find and read files.
 This capability makes it far easier to dynamically configure and enhance
 the boot loader.
 Linux boot loaders have not always had this capability; without it, configuring
 the boot loader was more difficult.
\end_layout

\begin_layout Subsection
Grub
\end_layout

\begin_layout Standard
Grub sta per Grand Unified Boot Loader, per essere sicuri di avviarlo, tenere
 premuto il tasto 
\begin_inset Quotes eld
\end_inset

Shift
\begin_inset Quotes erd
\end_inset

, dall'avvio del pc, e una volta presente la schermata di scelta di grub,
 premiamo 
\begin_inset Quotes eld
\end_inset

Esc
\begin_inset Quotes erd
\end_inset

 per accedere al prompt di Grub; possiamo premere 
\begin_inset Quotes eld
\end_inset

e
\begin_inset Quotes erd
\end_inset

 per vedere la configurazione del boot loader per l'opzione di default di
 grub; non dobbiamo farci confondere dai comandi, in quanto anche se vediamo
 
\begin_inset Quotes eld
\end_inset

insmod
\begin_inset Quotes erd
\end_inset

, in realtà non stiamo usando lo stesso 
\begin_inset Quotes eld
\end_inset

insmod
\begin_inset Quotes erd
\end_inset

 di linux, ma Grub è un mondo a parte, solo che la nomenclatura è lasciata
 uguale a quella dei comandi Unix per questioni di semplicità; possiamo
 cambiare queste impostazioni sia in modo temporaneo, che permanente all'interno
 di Grub.
\end_layout

\begin_layout Standard
N.B.: una volta avviato un kernel da un menu entry, possiamo a sistema operativo
 avviato controllare il nome del menu entry lanciato con:
\end_layout

\begin_layout Itemize
cat /proc/cmdline
\end_layout

\begin_layout Subsubsection
Esplorare i dispositivi e le partizioni da Grub
\end_layout

\begin_layout Standard
Grub ha un proprio schema di device-addressing.
 Ad esempio il primo HDD trovato è chiamato 
\begin_inset Quotes eld
\end_inset

hd0
\begin_inset Quotes erd
\end_inset

, seguito da 
\begin_inset Quotes eld
\end_inset

hd1
\begin_inset Quotes erd
\end_inset

, e così via.
 Grub può cercare tutte le partizioni su uno specifico UUID per trovare
 dove un kernel può risiedere, questo avviene grazie al comando 
\begin_inset Quotes eld
\end_inset

search
\begin_inset Quotes erd
\end_inset

.
 Vediamo alcuni comandi di grub:
\end_layout

\begin_layout Itemize
ls //mostra la lista di device riconosciuti da Grub
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
l'output sarà una cosa tipo: 
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
(hd0) (hd0,msdos1) (hd0,msdos5)
\end_layout

\end_deeper
\begin_layout Standard
dove (hd0) rappresenta l'HDD, e le due stringhe successive racchiuse tra
 parentesi tonde sono le partizioni, indicate con 
\begin_inset Quotes eld
\end_inset

msdos
\begin_inset Quotes erd
\end_inset

, questo indica che la tabella di partizione sul disco su cui risiedono
 è di tipo MBR, nel caso in cui fosse stata GPT, sarebbero iniziate con
 
\begin_inset Quotes eld
\end_inset

gpt
\begin_inset Quotes erd
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
ls -l //mostra la lista di device riconosciuti da Grub, con più dettagli
\end_layout

\begin_layout Itemize
echo $root //mostra la partizione, di dove Grub, pensa di trovare il kernel
 da lanciare
\end_layout

\begin_layout Itemize
ls (hd0,msdos1)/ //mostra tutti i file su una partizione, utile per capire
 ad esempio di quale partizione stiamo parlando, a volte riconosciamo una
 partizione dai file contenuti in quest'ultima
\end_layout

\begin_layout Itemize
ls (hd0,msdos1)/miaDir/ciao/ //è un modo per navigare un filesystem da grub
\end_layout

\begin_layout Itemize
ls ($root)/ //mostra i file sulla partizione riconosciuta come root
\end_layout

\begin_layout Itemize
ls /($root)/boot //mostra i file contenuti nella directory 
\begin_inset Quotes eld
\end_inset

/boot
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
set //mostra le variabili di GRUB
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
una variabile molto importante è $prefix, questa indica dove Grub si aspetta
 di trovare la sua configurazione
\end_layout

\end_deeper
\begin_layout Itemize
linux (hd0,gpt1)/boot/vmlinuz-4.1.2 root=/dev/sda1 //imposta il percorso del
 kernel da caricare, e la posizione della root directory da usare, nota
 che questo kernel sarà caricato solo quando lanceremo il comando 
\begin_inset Quotes eld
\end_inset

boot
\begin_inset Quotes erd
\end_inset

, attenzione se il kernel prevedeva anche un initial ram disk, allora il
 boot non andrà a buon fine, dobbiamo settare anche l'initial ram disk
\end_layout

\begin_layout Itemize
linux (hd0,gpt1)/boot/vmlinuz-4.1.2 root=/dev/sda1 nomodeset //imposta il
 percorso del kernel da caricare, e la posizione della root directory da
 usare, nota che questo kernel sarà caricato solo quando lanceremo il comando
 
\begin_inset Quotes eld
\end_inset

boot
\begin_inset Quotes erd
\end_inset

, attenzione se il kernel prevedeva anche un initial ram disk, allora il
 boot non andrà a buon fine, dobbiamo settare anche l'initial ram disk,
 inoltre imposta l'opzione chiamata nomodeset utile per avviare alcune distribuz
ioni, che ad esempio usano di default driver proprietari, nel caso non venisse
 inserita potrebbe compromettere il boot del sistema operativo
\end_layout

\begin_layout Itemize
initrd (hd0,1)/percorso/al/initrd.img //in questo caso impostiamo anche il
 percorso per l'initial ram disk, possiamo lanciare il kernel con 
\begin_inset Quotes eld
\end_inset

boot
\begin_inset Quotes erd
\end_inset

 se sia kernel e initial ram disk sono correttamente settati, forse al posto
 di 1 ci va 
\begin_inset Quotes eld
\end_inset

gpt1
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
boot //comando utilizzato per effettuare il boot della configurazione attuale,
 si utilizza una volta impostato ad esempio il kernel da bootare o se presente
 l'initramfs
\end_layout

\begin_layout Itemize
chainloader (hd0,1)+1 //avvia un altro bootloader contenuto sull'hard disk
 0 alla partizione uno, forse al posto di 1 ci va 
\begin_inset Quotes eld
\end_inset

gpt1
\begin_inset Quotes erd
\end_inset

, questo è utile per avviare sistemi operativi come Windows che contengono
 boot loader propri
\end_layout

\begin_layout Standard
N.B.: Il parametro passato al comando 
\begin_inset Quotes eld
\end_inset

linux
\begin_inset Quotes erd
\end_inset

 è chiamato 
\begin_inset Quotes eld
\end_inset

kernel command line
\begin_inset Quotes erd
\end_inset

 e i suoi parametri sono chiamati 
\begin_inset Quotes eld
\end_inset

kernel command line parameters
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Subsubsection
Kernel Command Line
\end_layout

\begin_layout Standard
Vediamo alcune opzioni famose da lanciare con il kernel:
\end_layout

\begin_layout Itemize
init=/path/al/programma //imposta il primo processo da eseguire, solitamente
 questo è il gestore di demoni, ma può essere utile talvolta impostarlo
 diversamente per poter ad esempio accedere ad una shell usiamo 
\begin_inset Quotes eld
\end_inset

init=/bin/sh
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
root=/dev/sda3 //imposta il percorso su cui è contenuta la partizione dove
 è presente il mountpoint di root 
\begin_inset Quotes eld
\end_inset

/
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
quiet //impone il valore loglevel ad 1, in pratica il valore di loglevel
 decide quali messaggi del kernel vengono stampati sui terminali tty, quindi
 se impostato al valore 
\begin_inset Quotes eld
\end_inset

n
\begin_inset Quotes erd
\end_inset

 mostrerà solo i messaggi di log di minore di 
\begin_inset Quotes eld
\end_inset

n
\begin_inset Quotes erd
\end_inset

, in questo caso viene impostato al livello 1, quindi in tty verranno mostrati
 solo i messaggi del kernel del livello 0 cioè di 
\begin_inset Quotes eld
\end_inset

EMERGENCY
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
loglevel=5 //impone il valore di loglevel a 
\begin_inset Quotes eld
\end_inset

n
\begin_inset Quotes erd
\end_inset

 dove n è compreso tra '0' e '8' estremi compresi, di default, se non impostato
 questo valore è uguale a 7, cioè vengono stampati nel terminale i messaggi
 dal livello 6 in giù
\end_layout

\begin_layout Itemize
debug //impone il loglevel della console al livello più alto, 
\begin_inset Quotes eld
\end_inset

8
\begin_inset Quotes erd
\end_inset

, in modo da poter visualizzare tutti i messaggi di log
\end_layout

\begin_layout Itemize
rdinit=/bin/mioPrg //impone il programma da far partire all'avvio dell'initramfs
, di default questo è impostato ad 
\begin_inset Quotes eld
\end_inset

/init
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
ro //monta il fs in modalità read only, solitamente si usa in quanto prima
 viene eseguito un filesystem check prima di essere rimontato in rw
\end_layout

\begin_layout Itemize
rootfstype= //impone il tipo di filesystem, la maggior parte delle volte
 funziona l'autodetect e quindi non abbiamo bisogno di questa opzione, ma
 nel caso ad esempio di filesystem come 
\begin_inset Quotes eld
\end_inset

jffs2
\begin_inset Quotes erd
\end_inset

 abbiamo bisogno di impostarlo
\end_layout

\begin_layout Itemize
rootwait //aspetta in modo indefinito la detection del root device, solitamente
 è necessario con device di tipo mmc come le flash card
\end_layout

\begin_layout Itemize
rw //monta il fs in read/write
\end_layout

\begin_layout Itemize
panic= //definisce il comportamento da assumere quando avviene un kernel
 panic, le opzioni sono:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
0: (opzione di default) non succede nulla, al video rimane mostrato il kernel
 panic
\end_layout

\begin_layout Itemize
7: (o qualsiasi altro numero positivo) aspetta 7 secondi prima di riavviarsi
\end_layout

\begin_layout Itemize
-5: (o qualsiasi altro numero negativo) si riavvia immediatamente
\end_layout

\end_deeper
\begin_layout Itemize
rootdelay= //impone un numero di secondi da aspettare prima di montare il
 root filesystem, di default è a 0, ma è utile se il device ci mette tempo
 ad effettuare il probing dell'hardware, vedi anche rootwait
\end_layout

\begin_layout Itemize
lpj= //questi sono i 
\begin_inset Quotes eld
\end_inset

loops per jiffies
\begin_inset Quotes erd
\end_inset

, è un parametro calcolato ogni volta che effettuiamo il boot, ad ogni modo
 se sappiamo che l'hardware non cambierà significativamente vale la pena
 imporlo manualmente per risparmiare circa 250ms al boot, dopo il primo
 boot vediamo quale è il parametro nella stringa 
\begin_inset Quotes eld
\end_inset

lpj=
\begin_inset Quotes erd
\end_inset

, per farlo eseguiamo un
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
dmesg | grep -iA5 
\begin_inset Quotes eld
\end_inset

calibrating
\begin_inset Quotes erd
\end_inset

 //una volta visto il valore qui, possiamo andarlo ad impostare nell'opzione
 in modo da risparmiare tempo
\end_layout

\end_deeper
\begin_layout Standard
N.B.(Jiffies): The x86 family processors send an interrupt every 4ms, Linux
 sees this interrupt and tries to see how many loops (without doing anything)
 it can execute before the next interrupt, allowing us to calculate BogoMIPS
 per jiffy and then CPU speed.
 So at boot time, Linux has no clue of actual CPU speed, just the fact that
 it knows it's an x86 and will receive that interrupt every 250 Hz.
 So then, the 250 Hz (and consequently the jiffies value) accuracy is dependent
 on the CPU crystal?
\end_layout

\begin_layout Standard
The jiffy at this point is the minimum distance between two interrupts.
\end_layout

\begin_layout Standard
Possiamo partire in un livello più basso ad esempio per non far partire
 xorg, ad esempio andando ad impostare dopo quiet 
\begin_inset Quotes eld
\end_inset

3
\begin_inset Quotes erd
\end_inset

 o il numero corrispettivo alla modalità che preferiamo.
\end_layout

\begin_layout Subsubsection
Configurazione di Grub
\end_layout

\begin_layout Standard
La configurazione di Grub è contenuta in un file chiamato 
\begin_inset Quotes eld
\end_inset

grub.cfg
\begin_inset Quotes erd
\end_inset

, e diversi moduli caricabili 
\begin_inset Quotes eld
\end_inset

.mod
\begin_inset Quotes erd
\end_inset

, la directory in cui è contenuto questo file di configurazione è solitamente
 /boot/grub oppure /boot/grub2.
 ATTENZIONE: Non modifichiamo direttamente 
\begin_inset Quotes eld
\end_inset

grub.cfg
\begin_inset Quotes erd
\end_inset

 (a meno che non sappiamo precisamente quello che stiamo facendo), ma utilizziam
o i comandi 
\begin_inset Quotes eld
\end_inset

grub-mkconfig
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

grub2-mkconfig
\begin_inset Quotes erd
\end_inset

 (a differenza della distro)
\end_layout

\begin_layout Standard
If you want to make changes to your GRUB configuration, you won’t edit your
 grub.cfg file directly because it’s automatically generated and the system
 occasionally overwrites it.
 You’ll add your new configuration elsewhere, then run grub-mkconfig to
 generate the new configuration.
\end_layout

\begin_layout Standard
Upon further inspection, you’ll find that every file in /etc/grub.d is a
 shell script that produces a piece of the grub.cfg file.
 The grub-mkconfig command itself is a shell script that runs everything
 in /etc/grub.d.
 Quindi possiamo lanciare senza modifiche permanenti:
\end_layout

\begin_layout Itemize
grub-mkconfig //mostra la configurazione sullo stdout, se non aggiorno la
 configurazione non diventa permanente
\end_layout

\begin_layout Itemize
grub-mkconfig -o /boot/grub/grub.cfg //rende le modifiche effettuate permanenti,
 è utile anche nel momento in cui vengono aggiunti nuovi kernel, in automatico,
 questo comando cerca file che iniziano per 
\begin_inset Quotes eld
\end_inset

vmlinuz-*
\begin_inset Quotes erd
\end_inset

 e per 
\begin_inset Quotes eld
\end_inset

System.map-*
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Per installare grub, possiamo eseguire:
\end_layout

\begin_layout Itemize
grub-install /dev/sda //in questo caso viene installato grub sul disco /dev/sda,
 in questo caso verrà utilizzata la directory di default che è 
\begin_inset Quotes eld
\end_inset

/boot
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
grub-install –boot-directory=/mnt/boot /dev/sdc //questo è utile quando
 dobbiamo installare grub su un altro dispositivo che abbiamo montato, o
 quando vogliamo installare grub in un altra directorym altra possibile
 opzione è utilizzare 
\begin_inset Quotes eld
\end_inset

–root-directory
\begin_inset Quotes erd
\end_inset

 e passargli la directory di root dopo aver montato sia il mountpoint /
 che quello di /boot se esiste
\end_layout

\begin_layout Itemize
grub-install –efi-directory=efi_dir –-bootloader-id=name //installa grub
 in un sistema UEFI, dove il bootloader id è il nome dato a grub, nel menu
 di boot UEFI, ed efi directory è la posizione della directory di UEFI che
 solitamente è in /boot/efi/efi o in /boot/efi
\end_layout

\begin_layout Standard
Grub, supporta anche l'avvio di altri boot-loaders, quest'operazione è chiamata
 
\begin_inset Quotes eld
\end_inset

ChainLoading
\begin_inset Quotes erd
\end_inset

, ed è usata ad esempio quando si vuole installare un sistema Linux in dual
 boot con un sistema Windows, in quanto per avviare quest'ultimo viene lanciato
 il suo boot-loader.
 Possiamo modificare alcune impostazioni di GRUB2 andando a creare un file
 chiamato 
\begin_inset Quotes eld
\end_inset

/etc/default/grub
\begin_inset Quotes erd
\end_inset

, questo file conterrà alcune opzioni che verranno interpretate dal comando
 
\begin_inset Quotes eld
\end_inset

grub-mkconfig
\begin_inset Quotes erd
\end_inset

, nel momento in cui andremo a costruire il file grub.cfg, vediamo alcuni
 esempi di opzioni che possiamo aggiungere a questo file:
\end_layout

\begin_layout Itemize
GRUB_DEFAULT=0 //imposta come voce selezionata di default la prima nel menu
\end_layout

\begin_layout Itemize
GRUB_DEFAULT=4 //imposta come voce selezionata di default la quinta nel
 menu
\end_layout

\begin_layout Itemize
GRUB_DEFAULT="Previous Linux Versions>2" //possiamo anche utilizzare le
 stringhe in questo caso selezioniamo la terza voce nel sottomenu chiamato
 
\begin_inset Quotes eld
\end_inset

Previous Linux Versions
\begin_inset Quotes erd
\end_inset

, per vedere queste stringhe dobbiamo consultare il file 
\begin_inset Quotes eld
\end_inset

/boot/grub/grub.cfg
\begin_inset Quotes erd
\end_inset

 e vedere le corrispettive 
\begin_inset Quotes eld
\end_inset

menuentry
\begin_inset Quotes erd
\end_inset

, al posto del numero della voce nel sottomenu è preferibile inserire la
 stringa corrispettiva che vediamo nel menuentry nel file citato
\end_layout

\begin_layout Itemize
GRUB_DEFAULT="Previous Linux Versions>Linux Generic 4.2.34" //in questo caso
 viene scelta come opzione di default la voce 
\begin_inset Quotes eld
\end_inset

Linux Generic 4.2.34
\begin_inset Quotes erd
\end_inset

 contenuta all'interno del sottomenu 
\begin_inset Quotes eld
\end_inset

Previous Linux Versions
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
GRUB_DISABLE_SUBMENU=y //in questo caso non vengono creati sottomenu nel
 menu di grub
\end_layout

\begin_layout Standard
una volta cambiate una di queste voci, dobbiamo eseguire:
\end_layout

\begin_layout Itemize
sudo update-grub
\end_layout

\begin_layout Subsubsection
Il file grub.cfg
\end_layout

\begin_layout Standard
Il file grub.cfg, è il file principale di configurazione di grub, questo
 è formato da istruzioni di Grub, ogni entry, è delineata da 
\begin_inset Quotes eld
\end_inset

menuentry
\begin_inset Quotes erd
\end_inset

, oppure possiamo trovare più 
\begin_inset Quotes eld
\end_inset

menuentry
\begin_inset Quotes erd
\end_inset

 all'interno di un 
\begin_inset Quotes eld
\end_inset

submenu
\begin_inset Quotes erd
\end_inset

, possiamo cancellare la sezione 
\begin_inset Quotes eld
\end_inset

submenu
\begin_inset Quotes erd
\end_inset

 per non avere una voce contenente più sottovoci, cosa che avviene comunemente
 per non avere un menu pieno di voci, grub utilizza questo comportamento
 di default per avere un menu più ordinato.
 Da questo file possiamo:
\end_layout

\begin_layout Itemize
Cambiare l'ordine delle menu entries
\end_layout

\begin_layout Itemize
Cambiare il titolo delle menu entries
\end_layout

\begin_layout Itemize
Cambiare l'organizzazione di submenu, per avere macro voci e sottovoci
\end_layout

\begin_layout Paragraph
Grub Note aggiuntive
\end_layout

\begin_layout Standard
Grub 2 has various differences from grub1, anyway we have a directory called
 /boot/grub/ and there are many files here.
\end_layout

\begin_layout Standard
The file grub.cfg in this directory, this file contains what is displayed
 into the boot process and other parameters passed to grub in the booting
 process.
 Per una procedura di installazione semplificata basta eseguire:
\end_layout

\begin_layout Itemize
sudo grub-install /dev/sda //installa grub nella partizion/dev/sda, se esiste
 già un bootloader su un'altra partizione, quest'ultimo viene sovrascritto
\end_layout

\begin_layout Itemize
sudo grub-install –recheck /dev/sda //rigenera il file di configurazione
 in caso di errori
\end_layout

\begin_layout Standard
DA AGGIUNGERE grub mkconfig, e grub update
\end_layout

\begin_layout Subsubsection
Sicurezza di Grub
\end_layout

\begin_layout Itemize
grub-mkpasswd-pbkdf2 //genera un hash che ci servirà per la password di
 GRUB, questa dobbiamo salvarla da qualche parte temporanemente per scriverla
 in un file di configurazione di GRUB.
\end_layout

\begin_layout Standard
Ora scriviamo nel file 
\begin_inset Quotes eld
\end_inset

custom
\begin_inset Quotes erd
\end_inset

 di grub situato in 
\begin_inset Quotes eld
\end_inset

/etc/grub.d/40_custom
\begin_inset Quotes erd
\end_inset

 e mettiamo in append il seguente contenuto:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

set superusers="username" 
\end_layout

\begin_layout Plain Layout

password_pbkdf2 username <passwordHash>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
dove per: 
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

username
\begin_inset Quotes erd
\end_inset

: specificheremo un utente che deve essere separato da quelli di sistema,
 cioè è preferibile usare un nome utente non presente sul sistema
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

passwordHash
\begin_inset Quotes erd
\end_inset

: è l'hash della password generato dal comando 
\begin_inset Quotes eld
\end_inset

grub-mkpasswd-pbkdf2
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Ovviamente è sempre necessario avviare 
\begin_inset Quotes eld
\end_inset

grub-mkconfig
\begin_inset Quotes erd
\end_inset

 per aggiornare il file di configurazione.
\end_layout

\begin_layout Standard
E' possibile anche proteggere singole voci di menu (ad esempio le recovery
 mode, o alcuni sistemi operativi), questo è possibile andando a modificare
 il file grub.cfg, in questo modo:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

set superusers="root" 
\end_layout

\begin_layout Plain Layout

password_pbkdf2 root grub.pbkdf2.sha512.10000.biglongstring 
\end_layout

\begin_layout Plain Layout

password user1 insecure
\end_layout

\begin_layout Plain Layout

menuentry "May be run by any user" --unrestricted { 	
\end_layout

\begin_layout Plain Layout

	set root=(hd0,1) 	
\end_layout

\begin_layout Plain Layout

	linux /vmlinuz 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

menuentry "Superusers only" --users "" { 	
\end_layout

\begin_layout Plain Layout

	set root=(hd0,1) 	
\end_layout

\begin_layout Plain Layout

	linux /vmlinuz single 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

menuentry "May be run by user1 or a superuser" --users user1 { 	
\end_layout

\begin_layout Plain Layout

	set root=(hd0,2) 	
\end_layout

\begin_layout Plain Layout

	chainloader +1 
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Bypassare Grub per avere una shell minimale
\end_layout

\begin_layout Standard
Per bypassare grub, possiamo aggiungere all'opzione da bootare attraverso
 il comando 
\begin_inset Quotes eld
\end_inset

e
\begin_inset Quotes erd
\end_inset

 da grub, la stringa:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

init=/bin/sh
\end_layout

\end_inset


\end_layout

\begin_layout Standard
questa stringa va inserita tra le opzioni di lancio del kernel, una volta
 entrati in questa shell molto probabilmente avremo il filesystem montato
 in modalità read-only, possiamo quindi rimontarlo runtime in modalità read-writ
e attraverso il comando:
\end_layout

\begin_layout Itemize
mount -o remount,rw / //rimonto il filesystem in modalità read/write
\end_layout

\begin_layout Subsection
Uname
\end_layout

\begin_layout Standard
Col comando 
\begin_inset Quotes eld
\end_inset

uname
\begin_inset Quotes erd
\end_inset

 richiedo informazioni sul sistema.
 Uname può essere utile quando si deve installare un nuovo kernel per il
 nostro sistema.
 Vediamo alcuni esempi: 
\end_layout

\begin_layout Itemize
uname -o // mostra il sistema operativo 
\begin_inset Quotes eld
\end_inset

OS
\begin_inset Quotes erd
\end_inset

 l'alternativa è 
\begin_inset Quotes eld
\end_inset

uname –operating-system
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
uname -n //mostra il 
\begin_inset Quotes eld
\end_inset

nodename
\begin_inset Quotes erd
\end_inset

 che è il nome della macchina, l'alternativa è 
\begin_inset Quotes eld
\end_inset

uname –nodename
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
uname -s //mostra il nome del kernel
\end_layout

\begin_layout Itemize
uname -m //mostra l'architettura della cpu
\end_layout

\begin_layout Itemize
uname -v //mostra la data di rilascio della versione di kernel utilizzata
\end_layout

\begin_layout Itemize
uname -r //mi fornisce la vesione del kernel
\end_layout

\begin_layout Itemize
uname -a //mostra tutto
\end_layout

\begin_layout Standard
Per vedere la versione dell'OS (o ad esempio la distribuzione in uso) ci
 sono più strade:
\end_layout

\begin_layout Itemize
analizzare il file /etc/issue, ad esempio 
\begin_inset Quotes eld
\end_inset

cat /etc/issue
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
analizzare il file /proc/version
\end_layout

\begin_layout Itemize
mostrare i file in /etc/ che hanno la parola 
\begin_inset Quotes eld
\end_inset

release
\begin_inset Quotes erd
\end_inset

 e analizzarli, 
\begin_inset Quotes eld
\end_inset

ls /etc/*release*
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Subsection
Sistema UEFI o BIOS ?
\end_layout

\begin_layout Standard
Per capire se abbiamo effettuato il boot all'interno di un sistema UEFI
 o BIOS, il metodo più semplice è quello di effettuare un:
\end_layout

\begin_layout Itemize
ls /sys/firmware/efi //se questo file esiste allora il sistema è bootato
 in UEFI, altrimenti abbiamo effettuato il boot in BIOS
\end_layout

\begin_layout Subsection
Informazioni sull'Hardware
\end_layout

\begin_layout Standard
Le informazioni sull'hardware possono essere trovate nella directory /proc,
 anche se esistono diversi programmi molto leggeri e utili per fare un'ispezione
 dell'hardware, senza impazzire all'interno del filesystem proc.
\end_layout

\begin_layout Standard
Opzioni comuni per l'ispezione dell'hardware sono:
\end_layout

\begin_layout Itemize
dmidecode
\end_layout

\begin_layout Itemize
lshw
\end_layout

\begin_layout Itemize
hwinfo
\end_layout

\begin_layout Itemize
inxi
\end_layout

\begin_layout Itemize
hardinfo (GUI program)
\end_layout

\begin_layout Standard
Un programma molto utile per poter visualizzare informazioni relative all'SMBIOS
 (System Management BIOS) è 
\begin_inset Quotes eld
\end_inset

dmidecode
\begin_inset Quotes erd
\end_inset

, nel mondo del computing, le specifiche SMBIOS (detto anche 
\begin_inset Quotes eld
\end_inset

tabella DMI
\begin_inset Quotes erd
\end_inset

) definiscono strutture dati e relativi metodi di accesso che possono essere
 usati per leggere informazioni salvate nel BIOS di un computer.
 Il programma dmidecode analizza e visualizza i dati dell'SMBIOS, queste
 informazioni costituiscono solitamente:
\end_layout

\begin_layout Itemize
produttore del sistema
\end_layout

\begin_layout Itemize
nome del modello
\end_layout

\begin_layout Itemize
numero di serie
\end_layout

\begin_layout Itemize
versione firmware
\end_layout

\begin_layout Itemize
CPU sockets
\end_layout

\begin_layout Itemize
slot di espansione (compresi AGP, PCI e ISA)
\end_layout

\begin_layout Itemize
slot di moduli di memoria
\end_layout

\begin_layout Itemize
lista di porte di I/O (Input/Output)
\end_layout

\begin_layout Itemize
ecc...
\end_layout

\begin_layout Standard
Per poter visualizzare queste informazioni, basta un semplice:
\end_layout

\begin_layout Itemize
dmidecode //visualizza le informazioni contenute nell'SMBIOS
\end_layout

\begin_layout Itemize
dmidecode -s bios-version //visualizza la versione del bios
\end_layout

\begin_layout Itemize
dmidecode -t bios //visualizza tutte le informazioni sul bios
\end_layout

\begin_layout Itemize
dmidecode -t system //visualizza tutte le informazioni sul sistema
\end_layout

\begin_layout Itemize
dmidecode -t baseboard //visualizza informazioni sulla baseboard (o motherboard)
, cioè sulla scheda madre
\end_layout

\begin_layout Itemize
dmidecode -t chassis //visualizza informazioni sullo chassis
\end_layout

\begin_layout Itemize
dmidecode -t memory //visualizza informazioni sulla memoria
\end_layout

\begin_layout Itemize
dmidecode -t cache //visualizza informazioni sulla cache
\end_layout

\begin_layout Itemize
dmidecode -t processor  //visualizza informazioni sul processore
\end_layout

\begin_layout Itemize
dmidecode -t connector //visualizza informazioni sui connettori
\end_layout

\begin_layout Itemize
dmidecode -t slot ////visualizza informazioni sugli slot
\end_layout

\begin_layout Standard
Un altro programma molto utile e leggero è 
\begin_inset Quotes eld
\end_inset

lshw
\begin_inset Quotes erd
\end_inset

, possiamo utilizzarlo al meglio se eseguito coi permessi di root, ci basterà
 eseguire:
\end_layout

\begin_layout Itemize
lshw //visualizza le informazioni sull'hardware
\end_layout

\begin_layout Itemize
lshw -short //visualizza un resoconto breve sull'hardware
\end_layout

\begin_layout Itemize
lshw -class processor //visualizza informazioni sul processore
\end_layout

\begin_layout Itemize
lshw -html > hardware.html //fornisce l'output in un carino formato HTML
\end_layout

\begin_layout Standard
Altro programma utile ancora è 
\begin_inset Quotes eld
\end_inset

hwinfo
\begin_inset Quotes erd
\end_inset

, questo è più dettagliato di 
\begin_inset Quotes eld
\end_inset

lshw
\begin_inset Quotes erd
\end_inset

 e per usarlo eseguiamo:
\end_layout

\begin_layout Itemize
hwinfo //mostra informazioni sull'hardware
\end_layout

\begin_layout Itemize
hwinfo –bios //mostra informazioni sul bios
\end_layout

\begin_layout Standard
Altro programma ancora è 
\begin_inset Quotes eld
\end_inset

inxi
\begin_inset Quotes erd
\end_inset

, infatti questo è un programma molto completo e user-friendly per mostrare
 informazioni, vediamo alcuni esempi:
\end_layout

\begin_layout Itemize
inxi //mostra un ouput riassuntivo con relativamente poche informazioni
\end_layout

\begin_layout Itemize
inxi -v 7 //mostra tutte le informazioni sulle periferiche
\end_layout

\begin_layout Itemize
inxi -Fxz //ottimo sommario di tutte le periferiche della macchina con varie
 catatteristiche
\end_layout

\begin_layout Standard
anche nel caso di questo programma è consigliabile avviarlo con i diritti
 di amministratore.
\end_layout

\begin_layout Standard
Un comando molto utile e dettagliato per creare report dell'hardware in
 html è 
\begin_inset Quotes eld
\end_inset

hardinfo
\begin_inset Quotes erd
\end_inset

, possiamo lanciarlo semplicemente eseguendo:
\end_layout

\begin_layout Itemize
hardinfo
\end_layout

\begin_layout Subsection
Memoria Centrale
\end_layout

\begin_layout Standard
Un programma che ci permette di visualizzare informazioni sulla memoria
 è Free, possiamo lanciarlo eseguendo 
\begin_inset Quotes eld
\end_inset

free
\begin_inset Quotes erd
\end_inset

 da terminale:
\end_layout

\begin_layout Itemize
free //ci mostra delle informazioni sulla memoria in kB
\end_layout

\begin_layout Itemize
free -b //ci mostra delle informazioni sulla memoria in B
\end_layout

\begin_layout Itemize
free -m //ci mostra delle informazioni sulla memoria in MB
\end_layout

\begin_layout Itemize
free -s 2 //ci mostra informazioni che si aggiornano ogni 2 secondi, comportamen
to simile al comando top
\end_layout

\begin_layout Itemize
free -ms 2 //comando molto comodo per vedere informazioni aggiornate ogni
 due secondi della memoria in MB
\end_layout

\begin_layout Standard
Questo comando può rivelarsi utile anche per capire se la nostra memoria
 RAM è sufficiente vedendo quando swap viene utilizzato.
 Un'altra opzioni per poter visualizzare informazioni sulla memoria è quella
 di stampare il file 
\begin_inset Quotes eld
\end_inset

/proc/meminfo
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
cat /proc/meminfo //stampa informazioni sulla memoria
\end_layout

\begin_layout Standard
Possiamo dare un'occhiata a cosa c'è in RAM (non so a cosa possa servire,
 ma si può fare), utilizzando:
\end_layout

\begin_layout Itemize
sudo dd if=/dev/mem | cat | strings //visualizza il contenuto della RAM
 sullo standard output
\end_layout

\begin_layout Subsection
Memoria Rigida
\end_layout

\begin_layout Standard
Per poter visualizzare informazioni per quanto riguarda la memoria rigida,
 vengono utilizzati solitamente i programmi:
\end_layout

\begin_layout Itemize
du (per ricordarlo pensiamo a 
\begin_inset Quotes eld
\end_inset

disk usage
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Itemize
df (per ricordarlo pensiamo a 
\begin_inset Quotes eld
\end_inset

disk filesystem
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Standard
Vediamo subito qualche esempio applicativo con 
\begin_inset Quotes eld
\end_inset

du
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Itemize
du //visualizza l'elenco dei file con lo spazio occupato nella directory
 corrente
\end_layout

\begin_layout Itemize
du -h //visualizza l'elenco dei file con lo spazio occupato nella directory
 corrente, ma in un formato 
\begin_inset Quotes eld
\end_inset

human readable
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
du -s * //mostra lo spazio utilizzato dalla directory in cui sono
\end_layout

\begin_layout Itemize
cd /; sudo du -s //mostra lo spazio occupato totale dal disco in cui è montata
 la root partition
\end_layout

\begin_layout Itemize
du -sh nomeFile //visualizza lo spazio occupato dal file nomeFile, il flag
 
\begin_inset Quotes eld
\end_inset

-s
\begin_inset Quotes erd
\end_inset

 sta per summary, e ci permette di visualizzare un resoconto del file
\end_layout

\begin_layout Itemize
du -sh * //fa un resoconto delle dimensioni di tutti i file in una directory,
 ad esempio se eseguiamo 
\begin_inset Quotes eld
\end_inset

du -sh /*
\begin_inset Quotes erd
\end_inset

 vediamo la dimensione delle varie cartelle principali del nostro filesystem,
 molto utile, peccato però che non visualizza le dimensioni dei file nascosti
\end_layout

\begin_layout Itemize
du -cxh -d1 | sort -rh //fa un resoconto delle dimensioni di tutti i file
 in una directory, simile ad 
\begin_inset Quotes eld
\end_inset

du -sh *
\begin_inset Quotes erd
\end_inset

, col vantaggio che mostra anche le dimensioni per i file/directory nascosti,
 il flag 
\begin_inset Quotes eld
\end_inset

x
\begin_inset Quotes erd
\end_inset

 esclude file e directory su altri filesystem, il flag 
\begin_inset Quotes eld
\end_inset

c
\begin_inset Quotes erd
\end_inset

 fa un totale, mentre il flag 
\begin_inset Quotes eld
\end_inset

-h
\begin_inset Quotes erd
\end_inset

 nel sort, è utilizzato appositamente per ordinare per dimensione file (quindi
 ad esempio 1G è più grande di 1K, ecc...) mentre il flag 
\begin_inset Quotes eld
\end_inset

-r
\begin_inset Quotes erd
\end_inset

 nel sort serve a mostrare i file più grandi per primi, quindi ordiniamo
 la lista in ordine decrescente
\end_layout

\begin_layout Itemize
du -sh nomeDirectory //visualizza lo spazio totale occupato dalla directory
 nomeDirectory
\end_layout

\begin_layout Itemize
du -ah nomeDirectory //visualizza l'elenco di tutti i file contenuti nella
 directory con le relative dimensioni
\end_layout

\begin_layout Standard
Un tool molto utile per visualizzare lo spazio occupato e poter navigare
 nelle directory è 
\begin_inset Quotes eld
\end_inset

ncdu
\begin_inset Quotes erd
\end_inset

, una volta installato ci basterà eseguire:
\end_layout

\begin_layout Itemize
ncdu //effettua uno scanning delle directory e delle sottodirectory a partire
 dalla directory corrente e fornisce un'interfaccia interattiva all'utente
 per poter navigare nelle directory e visualizzare le varie dimensioni per
 le varie directory e file
\end_layout

\begin_layout Standard
mentre con 
\begin_inset Quotes eld
\end_inset

df
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
df //visualizza i diversi filesystem in utilizzo con le relative dimensioni
 e percentuali di occupazioni, possiamo notare che:
\begin_inset Formula 
\[
SpazioTotale>SpazioOccupato+SpazioLibero
\]

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
questo avviene perchè, nella visualizzazione non viene contato nello spazio
 occupato e in quello libero, il 
\begin_inset Quotes eld
\end_inset

reserved space
\begin_inset Quotes erd
\end_inset

, cioè quello spazio che viene lasciato per sicurezza per evitare crash
 del sistema o instabilità in caso di mancanza di spazio, solitamente è
 il 5% dello spazio totale
\end_layout

\end_deeper
\begin_layout Itemize
df -h //visualizza le informazioni per i diversi filesystem in utilizzo
 in modalità 
\begin_inset Quotes eld
\end_inset

human readable
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
df -ah //visualizza tutti i filesystem, anche quelli virtuali utilizzati
 dal kernel
\end_layout

\begin_layout Itemize
df -i //visualizza il numero di inode disponibili, molto utile ad esempio
 può capitare di non finire lo spazio su un disco, ma il sistema operativo
 si lamenta di spazio insufficiente, in realtà molto probabilmente abbiamo
 finito gli inode a disposizione, altri casi in cui non possiamo scrivere
 è quando sono presenti filesystem read only come ad esempio: lo squashfs,
 in questi casi infatti possiamo accorgercene lanciando un 
\begin_inset Quotes eld
\end_inset

 file -s /dev/loop0 
\begin_inset Quotes eld
\end_inset

 dove 
\begin_inset Quotes eld
\end_inset

/dev/loop0
\begin_inset Quotes erd
\end_inset

 corrisponde al dispositivo su cui abbiamo sospetti dello squashfs
\end_layout

\begin_layout Standard
Possiamo anche fare uso di strumenti come 
\begin_inset Quotes eld
\end_inset

fdisk
\begin_inset Quotes erd
\end_inset

 per visualizzare lo spazio totale di device non montati, questo è possibile
 attraverso il comando:
\end_layout

\begin_layout Itemize
lsblk //comando che visualizza tutte le partizioni con relative dimensioni
 per ogni disco (migliore!!)
\end_layout

\begin_layout Itemize
fdisk -l | grep Disk //visualizza lo spazio totale presente su un dispositivo
 di memoria
\end_layout

\begin_layout Itemize
fdisk -l | grep sda //mostra tutte le dimensioni delle varie partizioni
 assegnate al disco fda
\end_layout

\begin_layout Standard
N.B.:The POSIX standard defines a block size of 512 bytes.
 However, this size is harder to read, so by default, the df and du output
 in most Linux distributions is in 1024-byte blocks.
 If you insist on displaying the numbers in 512-byte blocks, set the POSIXLY_COR
RECT environment variable.
 To explicitly specify 1024-byte blocks, use the -k option (both utilities
 support this).
 The df program also has a -m option to list capacities in 1MB blocks and
 a -h option to take a best guess at what a person can read.
\end_layout

\begin_layout Standard
HOWLINUXWORKS pag72 devo iniziare 4.2.11
\end_layout

\begin_layout Subsection
lspci, lsusb, lscpu, lsblk, lsscsi, lspcmcia, lshw, lsdev, usbview
\end_layout

\begin_layout Standard
Esistono tre comandi molto utili per visualizzare le periferiche hardware
 su una macchina:
\end_layout

\begin_layout Itemize
lspci //mostra le periferiche pci 
\end_layout

\begin_layout Itemize
lspci -k //mostra le periferiche pci, con i relativi driver hardware in
 uso, molto utile nel momento in cui vogliamo capire a quale periferica
 è associato o meno un driver
\end_layout

\begin_layout Itemize
lspci -v //mostra le periferiche pci, e molte informazioni su ogni periferica,
 anche i moduli in uso, è più completa rispetto a 
\begin_inset Quotes eld
\end_inset

lspci -k
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
lsusb //mostra le periferiche usb della macchina, posso vedere bus number
 e device number, e utilizzarli per localizzare il device file della periferica
 interessata in 
\begin_inset Quotes eld
\end_inset

/dev/bus/usb/busNumber/deviceNumber
\begin_inset Quotes erd
\end_inset

, nota che un device comunque può creare più di un device file, non c'è
 una corrispondenza 1:1
\end_layout

\begin_layout Itemize
lsusb -v//mostra le periferiche usb della macchina, con annesse informazioni
 come vendorId, productId e altri dettagli più tecnici
\end_layout

\begin_layout Itemize
lscpu //mostra informazioni riguardanti il sistema CPU
\end_layout

\begin_layout Itemize
lsscsi //mostra le periferiche utilizzanti il protocollo scsi (solitamente
 HDD, Lettori ottici, ecc...)
\end_layout

\begin_layout Itemize
lspcmcia //mostra tutte le periferiche pcmcia
\end_layout

\begin_layout Itemize
lsblk //mostra tutti i dispositivi di archiviazione, posso utilizzarlo per
 mostrare i numeri associati al device, il mio device sarà in /dev/block/firstNu
mber:secondNumber, questo comando è UTILISSIMO per visualizzare le dimensioni
 delle partizioni per i device per ogni dispositivo
\end_layout

\begin_layout Itemize
usbview //fornisce ulteriori informazioni attraverso un programma GUI sull'USB
\end_layout

\begin_layout Itemize
nproc //mostra il numero di CPU, utile quando dobbiamo impostare la variabile
 MAKEOPTS
\end_layout

\begin_layout Standard
un'ultra utilità più avanzata utilizzata da programmatori di basso livello
 è:
\end_layout

\begin_layout Itemize
lsdev //questo mostrerà cosa il kernel vede come Device e i corrispettivi
 DMA, IRQ, I/O Ports 
\end_layout

\begin_layout Standard
per avere informazioni invece sulle seriali, possiamo utilizzare il programma
 
\begin_inset Quotes eld
\end_inset

setserial
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsection
Moduli del Kernel
\end_layout

\begin_layout Standard
Esistono diversi comandi per poter gestire i moduli del kernel in uso, vediamone
 alcuni:
\end_layout

\begin_layout Itemize
lsmod //elenca i moduli installati correntemente nel kernel, elabora e formatta
 in modo leggibile informazioni da /proc/modules
\end_layout

\begin_layout Itemize
ls -Rl /lib/modules/$(uname -r) //elenca tutti i moduli disponibili per
 il mio kernel, è da notare che tutti i moduli sono collocati nella directory
 /lib/modules, mentre i moduli caricati dal sistema sono nella memoria del
 kernel e possiamo visualizzarli in /proc/modules
\end_layout

\begin_layout Itemize
insmod percorsoModulo //inserisce il modulo, attenzione, questo comando
 è oggigiorno sostituito nella pratica da modprobe, in quanto, modprobe
 carica tutti i moduli dipendenza in automatico ed inoltre non c'è bisogno
 di specificare l'intero percorso al modulo
\end_layout

\begin_layout Itemize
rmmod nomeModulo //rimuove un singolo modulo caricato
\end_layout

\begin_layout Itemize
modinfo nomeModulo //mostra informazioni e dipendenze del modulo indicato,
 come ad esempio anche alcune opzioni con cui può essere caricato, indicate
 nelle voci 
\begin_inset Quotes eld
\end_inset

parm:
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
cd /sys/module/<nome_modulo>/parameters //visualizza i parametri correnti
 del modulo caricato
\end_layout

\begin_layout Standard
Un comando molto versatile e più recente per gestire i moduli del kernel
 è 
\begin_inset Quotes eld
\end_inset

modprobe
\begin_inset Quotes erd
\end_inset

, l'utilizzo di questo comando quando possibile è sempre consigliato rispetto
 ai comandi 
\begin_inset Quotes eld
\end_inset

insmod
\begin_inset Quotes erd
\end_inset

 ed 
\begin_inset Quotes eld
\end_inset

rmmod
\begin_inset Quotes erd
\end_inset

 in quanto gestisce anche le dipendenze, vediamo alcuni esempi:
\end_layout

\begin_layout Itemize
modprobe nomeModulo //carica il modulo nomeModulo con le relative dipendenze
\end_layout

\begin_layout Itemize
modprobe -v nomeModulo //carica il modulo nomeModulo con le relative dipendenze,
 mostrando cosa ha caricato attraverso la modalità 
\begin_inset Quotes eld
\end_inset

verbose
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
modprob -r nomeModulo //rimuove il modulo se è caricato, quindi non dovremmo
 più vederlo in lsmod mentre è ancora visualizzabile come modulo disponibile
 in /lib/modules, modprob -r è quivalente a lanciare rmmod, ma risolve le
 dipendenze
\end_layout

\begin_layout Itemize
modprobe -rv nomeModulo //rimuove il modulo e visualizza le informazioni
 
\begin_inset Quotes eld
\end_inset

verbose
\begin_inset Quotes erd
\end_inset

 a schermo, indicando anche i moduli dipendenza rimossi
\end_layout

\begin_layout Itemize
modprobe sr_mod xa_test=1 //carica il modulo sr_mod con le necessarie dipendenze
 e l'opzione xa_test=1
\end_layout

\begin_layout Standard
Possiamo rendere permanenti le opzioni con cui carichiamo i moduli attraverso
 il file 
\begin_inset Quotes eld
\end_inset

modprobe.conf
\begin_inset Quotes erd
\end_inset

 o attraverso la creazione di appositi file nella directory 
\begin_inset Quotes eld
\end_inset

/etc/modprobe.d/file.conf
\begin_inset Quotes erd
\end_inset

.
 Ad esempio nel caso volessimo che tutte le volte che il modulo 
\begin_inset Quotes eld
\end_inset

sr_mod
\begin_inset Quotes erd
\end_inset

 venga caricato l'opzione 
\begin_inset Quotes eld
\end_inset

xa_test=1
\begin_inset Quotes erd
\end_inset

 deve essere attiva, allora creiamo un file chiamato 
\begin_inset Quotes eld
\end_inset

whatever.conf
\begin_inset Quotes erd
\end_inset

 (l'importante è che sia .conf, anche se per convenzione utilizziamo file
 con lo stesso nome del modulo interessato) con scritto:
\end_layout

\begin_layout Standard
—————————————————-
\end_layout

\begin_layout Standard
options sr_mod xa_test=1
\end_layout

\begin_layout Standard
—————————————————-
\end_layout

\begin_layout Standard
Possiamo visualizzare le opzioni dei moduli correntemente caricati attraverso:
\end_layout

\begin_layout Itemize
cat /sys/module/nomeModulo/parameters/parameterName //visualizza informazioni
 sulle opzioni caricate dal modulo chiamato 
\begin_inset Quotes eld
\end_inset

nomeModulo
\begin_inset Quotes erd
\end_inset

, se il file parameterName che rappresenta il nome parametro esiste, allora
 quell'opzione è caricata e il suo contenuto è il valore assegnato a quell'opzio
ne
\end_layout

\begin_layout Subsection
Diagnostica e Manutenzione dei dispositivi di Memoria
\end_layout

\begin_layout Subsubsection
Ext Partition Monitoring
\end_layout

\begin_layout Standard
Esistono generalmente due strumenti per la diagnostica e la riparazione
 di partizioni di dispositivi di memoria:
\end_layout

\begin_layout Itemize
fsck //diagnostica e ripara dispositivi di memoria di qualsiasi filesystem
\end_layout

\begin_layout Itemize
e2fsck //diagnostica e ripara dispositvi di memoria con filesystem ext2/ext3/ext
4
\end_layout

\begin_layout Standard
I due programmi sono collocati nella directory /sbin, infatti in questa
 directory esistono diversi strumenti per la diagnostica di filesystem ma
 molti sono link, infatti possiamo eseguire il comando sotto riportato per
 rendercene conto:
\end_layout

\begin_layout Itemize
ls -al /sbin/fs* //elenca tutti gli strumenti per effettuare diagnostica
 di dispositivi di memoria
\end_layout

\begin_layout Standard
La diagnostica può essere effettuata solo se i dispositivi di memoria non
 sono montati, una volta smontati possiamo:
\end_layout

\begin_layout Itemize
fsck /dev/sdb1 //effettua un controllo sulla partizione 1 del dispositivo
 /dev/sdb, il risultato 
\begin_inset Quotes eld
\end_inset

clean
\begin_inset Quotes erd
\end_inset

, indica un filesystem corretto senza inodes rotti o persi
\end_layout

\begin_layout Itemize
fsck -f /dev/sdb1 //effettua un controllo forzato sulla partizione indicata
\end_layout

\begin_layout Itemize
fsck -a /dev/sdb1 //effettua un controllo e automaticamente effettua le
 riparazioni necessarie sulla partizione 1 del dispositivo /dev/sdb
\end_layout

\begin_layout Standard
WARNING:You should never use fsck on a mounted filesystem because the kernel
 may alter the disk data as you run the check, causing runtime mismatches
 that can crash your system and corrupt files.
 There is only one exception: If you mount the root partition read-only
 in single-user mode, you may use fsck on it.
\end_layout

\begin_layout Standard
Dopo aver effettuato un fsck, possiamo rimontare la partizione root o riavviando
 o eseguendo:
\end_layout

\begin_layout Itemize
mount -o remount / //rimonta la partizione di root
\end_layout

\begin_layout Standard
Inoltre se un filesystem check trova un inode senza nome, quindi una sorta
 di file corrotto, lo ripara e lo mette in una directory chiamata 
\begin_inset Quotes eld
\end_inset

lost+found
\begin_inset Quotes erd
\end_inset

, con un numero al posto del nome del file.
\end_layout

\begin_layout Standard
Nel caso volessimo forzare un check al prossimo riavvio di sistema possiamo
 creare un file nella directory radice della partizione chiamato 
\begin_inset Quotes eld
\end_inset

forcefsck
\begin_inset Quotes erd
\end_inset

 vuoto con:
\end_layout

\begin_layout Itemize
sudo touch /forcefsck //viene forzato un check del disco al prossimo riavvio,
 il file viene automaticamente eliminato dopo il check
\end_layout

\begin_layout Standard
Tutti i comandi 
\begin_inset Quotes eld
\end_inset

e2fsck
\begin_inset Quotes erd
\end_inset

 hanno gli stessi flag del comando 
\begin_inset Quotes eld
\end_inset

fsck
\begin_inset Quotes erd
\end_inset

, quindi possiamo eseguire tutti i comandi sopra riportati anche con 
\begin_inset Quotes eld
\end_inset

e2fsck
\begin_inset Quotes erd
\end_inset

 per filesystem di tipo 
\begin_inset Quotes eld
\end_inset

ext
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
E' possibile anche utilizzare lo strumento 
\begin_inset Quotes eld
\end_inset

debugfs
\begin_inset Quotes erd
\end_inset

 per effettuare il debug di filesystem di tipo ext, ci permette quindi di
 operare con partizioni danneggiate e non, possiamo avviarlo con:
\end_layout

\begin_layout Itemize
debugfs /dev/myDevice //avvia debugfs in modalità read-only
\end_layout

\begin_layout Itemize
debugfs -w /dev/myDevice //avvia debugfs in modalità read/write
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
ls //elenca i file
\end_layout

\begin_layout Itemize
ls -ld //elenca tutti i file, anche quelli eliminati
\end_layout

\end_deeper
\begin_layout Standard
Si aprirà un prompt, a cui potremmo dare i comandi trovati nella lista che
 compare col comando 
\begin_inset Quotes eld
\end_inset

help
\begin_inset Quotes erd
\end_inset

 digitato dal prompt di debugfs, sono disponibili tantissime opzioni, ed
 è molto chiaro il loro utilizzo attraverso la descrizione riportata; un
 caso d'uso potrebbe essere ad esempio un file che abbiamo cancellato e
 vogliamo recuperare, o controllare la frammentazione del disco o per un
 determinato inode, possiamo uscire dal programma attraverso la direttiva
 
\begin_inset Quotes eld
\end_inset

quit
\begin_inset Quotes erd
\end_inset

.
 Si ricorda che un'altra utility per visualizzare informazioni su una partizione
 ext é:
\end_layout

\begin_layout Itemize
dumpe2fs /dev/myDevice //visualizza informazioni sul device, numero di blocchi,
 numero di inode, blocchi liberi, nomero di mount effettuate, e numero massimo
 di mount prima del filesystem check, o il check interval temporale, e tanti
 altri dettagli sulla partizione
\end_layout

\begin_layout Standard
N.B.: Per effettuare il recovery di file cancellati su file system ext è molto
 utile il programma 
\begin_inset Quotes eld
\end_inset

extundelete
\begin_inset Quotes erd
\end_inset

, oppure altri programma molto usati e semplici da usare sono 
\begin_inset Quotes eld
\end_inset

foremost
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

scalpel
\begin_inset Quotes erd
\end_inset

, che dovrebbero essere anche indipendenti dal filesystem, quindi funzionano
 anche su filesystem non ext4 (DA VERIFICARE).
\end_layout

\begin_layout Standard
Possiamo recuperare file di test se conosciamo qualche stringa specifica
 del file, come stringa interna (meglio) o nome del file (peggio) con grep,
 ad esempio:
\end_layout

\begin_layout Itemize
grep -a -C 200 -F 'Unique string in text file' /dev/sdXN > OutputFile 
\end_layout

\begin_layout Subsubsection
Hardware Monitoring di dischi con SMART
\end_layout

\begin_layout Standard
Smartmontools (S.M.A.R.T.
 Monitoring Tools) is a set of utility programs (smartctl and smartd) to
 control and monitor computer storage systems using the Self-Monitoring,
 Analysis and Reporting Technology (S.M.A.R.T.) system built into most modern
 (P)ATA, Serial ATA and SCSI hard drives.
 Innanzitutto dobbiamo installare il pacchetto 
\begin_inset Quotes eld
\end_inset

smartmontools
\begin_inset Quotes erd
\end_inset

, quindi:
\end_layout

\begin_layout Itemize
apt-get install smartmontools
\end_layout

\begin_layout Standard
Una volta installato, avremo a disposizione il comando 
\begin_inset Quotes eld
\end_inset

smartctl
\begin_inset Quotes erd
\end_inset

 e il demone 
\begin_inset Quotes eld
\end_inset

smartd
\begin_inset Quotes erd
\end_inset

, vediamo alcuni esempi di comandi con smartctl:
\end_layout

\begin_layout Itemize
smartctl -s on /dev/sda //abilita smartctl sull'hard disk /dev/sda
\end_layout

\begin_layout Itemize
smartctl -i /dev/sdb //mostra informazioni 
\begin_inset Quotes eld
\end_inset

-i
\begin_inset Quotes erd
\end_inset

 sul disco montato in /dev/sdb, molto utile, possiamo visualizzare la marca,
 la velocità di rotazione ( e.g.
 7200 rpm, 5400 rpm, ecc...), la capacità, le versione del firmware, il numero
 seriale, il LU WWN Id che è come un MAC address per gli hard disk, eccetera...
\end_layout

\begin_layout Standard
Nel caso il comando 
\begin_inset Quotes eld
\end_inset

smartctl -i
\begin_inset Quotes erd
\end_inset

 dovesse fallire, allora questo vuol dire che smartctl ha bisogno di informazion
i aggiuntive sull'interfaccia utilizzata dal nostro device, dovremo quindi
 eseguire:
\end_layout

\begin_layout Itemize
sudo smartctl -d scsi -i /dev/sda //dove al posto di type inseriamo ata,scsi,sat
 o altre opzioni visualizzabili dal man di smartctl
\end_layout

\begin_layout Itemize
sudo smartctl -a /dev/sda //mostra informazioni dettagliate per un hard
 disk IDE
\end_layout

\begin_layout Itemize
sudo smartctl -a -d ata /dev/sda //mostra informazioni dettagliate per un
 hard disk SATA
\end_layout

\begin_layout Itemize
smartctl -H /dev/sdb //mostra informazioni sullo stato di salute dell'hard
 disk 
\begin_inset Quotes eld
\end_inset

-H
\begin_inset Quotes erd
\end_inset

 sta per health, utile per monitorare la salute o eventuali anomalie di
 un HD
\end_layout

\begin_layout Itemize
sudo smartctl -c /dev/sda //elenca i vari tipi di test disponibili con una
 stima della durata, solitamente la maggior parte degli hard drive supporta
 questi test, i due test più comuni solo il test 
\begin_inset Quotes eld
\end_inset

short
\begin_inset Quotes erd
\end_inset

 e l'
\begin_inset Quotes erd
\end_inset

extended
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
sudo smartctl -t short /dev/sda //esegue un test di tipo 
\begin_inset Quotes eld
\end_inset

short
\begin_inset Quotes erd
\end_inset

 sul device indicato in background, non mostra i risultati a schermo, quelli
 devono essere visualizzati con un successivo comando
\end_layout

\begin_layout Itemize
sudo smartctl -t long /dev/sda //esegue il test di tipo 
\begin_inset Quotes eld
\end_inset

extended
\begin_inset Quotes erd
\end_inset

 sul device indicato, non mostra i risultati a schermo, quelli devono essere
 visualizzati con un successivo comando
\end_layout

\begin_layout Itemize
sudo smartctl -l selftest /dev/sda //mostra i risultati a schermo dell'ultimo
 test effettuato, possiamo visualizzare il numero di ore di vita dell'hard
 drive
\end_layout

\begin_layout Standard
Un utile front-end grafico per smartmontools è 
\begin_inset Quotes eld
\end_inset

GSmartControl
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Paragraph
Approfondimento sul sistema S.M.A.R.T
\end_layout

\begin_layout Standard
Self-Monitoring, Analysis, and Reporting Technology, o S.M.A.R.T., è un sistema
 di monitoraggio per dischi rigidi e per SSD, per rilevare e fornire diversi
 indicatori di affidabilità, nella speranza di anticipare i malfunzionamenti.
\end_layout

\begin_layout Section
Gestione dei Dispositivi di Memoria
\end_layout

\begin_layout Subsection
Premessa sui dispositivi di memoria
\end_layout

\begin_layout Standard
Ogni dispositivo di memoria, può essere suddiviso in più partizioni, ma
 prima di poter essere suddiviso bisogna scegliere una cosidetta 
\begin_inset Quotes eld
\end_inset

tabella delle partizioni
\begin_inset Quotes erd
\end_inset

, che costituisce uno schema di partizionamento del disco.
 I due schemi più utilizzati peri sistemi Personal Computer sono:
\end_layout

\begin_layout Itemize
DOS (o MBR)
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
MBR (Master Boot Record): è un sistema di partizionamento che supporta fino
 a un massimo di 4 partizioni, anche se è stata escogitata una soluzione
 attraverso le cosiddette 
\begin_inset Quotes eld
\end_inset

partizioni estese
\begin_inset Quotes erd
\end_inset

, che possono contenere una o più 
\begin_inset Quotes eld
\end_inset

partizioni logiche
\begin_inset Quotes erd
\end_inset

; l'MBR inoltre non supporta partizioni con capacità maggiore a 2TB
\end_layout

\end_deeper
\begin_layout Itemize
GPT 
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
GPT (GUID Partition Table or Globally Unique Identifier Partition Table):
 è sistema di partizionamento più recente, supera limiti dovuti al vecchio
 schema MBR)
\end_layout

\end_deeper
\begin_layout Standard
E' da notare che però sui dischi d'avvio di un sistema operativo, la scelta
 dello schema di partizionamento deve essere accurata in quanto, in base
 all'interfaccia firmware della macchina la mia scelta potrebbe essere forzata
 ad un determinata tabella di partizioni.
\end_layout

\begin_layout Paragraph
Nota sui firmware
\end_layout

\begin_layout Standard
Nei meno recenti personal computer, esisteva un firmware chiamato BIOS (Basic
 Input/Output System), questo è un sistema veramente basilare che si occupa
 di effettuare un esiguo numero di operazioni primitive atte il corretto
 avvio della macchina, una delle operazioni è costituita dall'avvio del
 boot-loader, cioè il programma che si occupa di gestire l'avvio di un sistema
 operativo da un disco.
 Secondo il BIOS, il disco da cui avviare il boot-loader può essere sia
 con tabella delle partizioni GPT che MBR.
 Nei sistemi più recenti esiste un meccanismo più complesso composto da
 uno strato più ad alto livello rispetto al firmware, questo strato è chiamato
 UEFI (Unified Extensible Firmware Interface) e costituisce un'interfaccia
 tra il firmware e i sistemi operativi, in questo caso la tabella delle
 partizioni deve necessariamente essere GPT, almenochè il sistema non supporti
 la modalità CSM (Compatibility Support Mode) che permette di emulare la
 modalità BIOS, permettendo a sistemi che non supportano UEFI di avviarsi
 come se avessero BIOS.
\end_layout

\begin_layout Subsection
Schemi di Partizionamento Minimali
\end_layout

\begin_layout Standard
Per quanto riguarda schemi di partizionamento minimali possiamo distinguere
 alcune configurazioni possibili e comunemente utilizzate nella stragrande
 maggioranza dei casi:
\end_layout

\begin_layout Paragraph
BIOS+MBR+GRUB
\end_layout

\begin_layout Standard
In questo caso non c'è nessun vincolo sulle partizioni:
\end_layout

\begin_layout Itemize
1 partizione di root /
\end_layout

\begin_layout Itemize
1 partizione di /boot (consigliabile, ma nella pratica, non necessaria)
\end_layout

\begin_layout Standard
In realtà su alcuni sistemi molto molto vecchi, è consigliabile per sicurezza
 fare comunque una partizione di /boot in quanto questa è la prima partizione/di
rectory che viene cercata dal BIOS e alcuni BIOS vecchi non riescono a concepire
 una directory/partizione di boot troppo grande.
 Per alcune features potrebbe essere necessaria una partizione da 1MB, questo
 accade ad esempio quando abbiamo più sistemi operativi diversi (si parla
 di Windows), dove i bootloader magari hanno bisogno di più spazio, in quanto
 non ci stanno tutti nei 446 byte del boot sector
\end_layout

\begin_layout Paragraph
BIOS+GPT+GRUB
\end_layout

\begin_layout Standard
In questo caso dovremo creare:
\end_layout

\begin_layout Itemize
1 partizione da 1MB marcata come BIOS Boot o bios_grub (a differenza del
 programma con cui creiamo le partizioni)
\end_layout

\begin_layout Itemize
1 partizione di root /
\end_layout

\begin_layout Standard
non è necessaria una partizione separata di /boot.
\end_layout

\begin_layout Standard
N.B.:It's necessary to have a separate /boot partition only if you want full
 disk encryption or something similar, or if you have an ancient computer
 that wouldn't work with a 64-bit distro anyway, a separate /boot also means
 you can reinstall without having to recompile a kernel.
\end_layout

\begin_layout Standard
N.B.:we need a 1MB partition because the whole grub stage1 is too big to fit
 in the 446 bytes of the mbr boot sector, it needs to "spill over" somewhere.
 on GPT, you must reserve this spill over space explicitly, while on bios+mbr
 it's not mandatory because it can (mostly) safely embed between the MBR
 and the first partition, but it's not safe on GPT there are other things
 which could decide to try to use that dead space, so it's still recommended
 to reserve the space explicitly.
\end_layout

\begin_layout Standard
N.B.:some BIOSes have a bug with booting from a GPT label in BIOS mode, Lenovo
 and HP are known for this.
\end_layout

\begin_layout Paragraph
UEFI+GPT+GRUB
\end_layout

\begin_layout Standard
Nel caso si avesse un sistema UEFI, allora dobbiamo creare 
\end_layout

\begin_layout Itemize
1 partizione ESP (EFI System Partition) che può andare dai 20MB ai 550MB
 con filesystem vfat (dipende, da se ci metto dentro i kernel o no, metterci
 i kernel ha questo vantaggio 
\begin_inset Quotes eld
\end_inset

well one advantage is that if you efistub-enable them, then you can still
 boot them if grub went missing or broke
\begin_inset Quotes erd
\end_inset

), questa deve essere montata da qualche parte, solitamente è in /boot oppure
 in /boot/efi, anche se posso mettere qualsiasi directory, l'unica restrizione
 è quella di montarla prima di installare grub
\end_layout

\begin_layout Itemize
1 partizione di root /
\end_layout

\begin_layout Standard
N.B.: Quando si parla di partizioni 
\begin_inset Quotes eld
\end_inset

/boot
\begin_inset Quotes erd
\end_inset

 dobbiamo ricordare che possiamo scegliere se farle ext2 o ext4, a questo
 punto dobbiamo considerare la compatibilità del boot loader, nel caso di
 GRUB ormai è tutto supportate però:
\end_layout

\begin_layout Itemize
ext2: più piccolo overhead, siamo sicuri che funziona con tutte le versioni
 di grub
\end_layout

\begin_layout Itemize
ext4: overhead maggiore, dovrebbe funzionare sulle versioni più recenti
 ed alcuni dicono che nonostante abbiamo overhead maggiore, avere ext4 velocizzi
 il boot
\end_layout

\begin_layout Subsection
Partizioni Separate vs Partizione Unica
\end_layout

\begin_layout Standard
A molti utenti principianti di GNU/Linux viene consigliato implementare
 una partizione unica per l'installazione del sistema, ma perchè allora
 usare partizioni separate per le varie directory come 
\begin_inset Quotes eld
\end_inset

/home
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

/usr
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

/var
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

/tmp
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

/
\begin_inset Quotes erd
\end_inset

, i motivi principali che stanno alla base di questa scelta sono:
\end_layout

\begin_layout Enumerate
Minimizing loss: If /usr is on separate partition a damaged /usr does not
 mean that you cannot recover /etc
\end_layout

\begin_layout Enumerate
Security: / cannot be always ro (/root may need to be rw etc.) but /usr can.
 It can be used to made ro as much as possible
\end_layout

\begin_layout Enumerate
Using different filesystems: I may want to use different system for /tmp
 (not reliable but fast for many files) and /home (have to be reliable).
 Similary /var contains data while /usr not so /usr stability can be sacrifice
 but not so much as /tmp
\end_layout

\begin_layout Enumerate
Duration of fsck: Smaller partitions means that checking one is faster
\end_layout

\begin_layout Enumerate
Mentioned filling up of partions, although other method is quotas
\end_layout

\begin_layout Standard
Altre buone ragioni per tenere la partizione 
\begin_inset Quotes eld
\end_inset

/home
\begin_inset Quotes erd
\end_inset

 separata dal resto sono:
\end_layout

\begin_layout Itemize
Crittografia: Possiamo di decidere i nostri dati, in quanto nella partizione
 home sono contenuti tutti i dati personali
\end_layout

\begin_layout Itemize
Persistenza: Possiamo mantenere i nostri dati, senza dover ricopiare tutto
 quando vogliamo eseguire una formattazione
\end_layout

\begin_layout Standard
Invece altre buone ragioni per tenere la partizione 
\begin_inset Quotes eld
\end_inset

/usr
\begin_inset Quotes erd
\end_inset

 separata dal resto sono:
\end_layout

\begin_layout Itemize
A separate /usr can be useful if you have several machines sharing the same
 OS.
 They can share a single central /usr instead of duplicating it on every
 system.
 /usr can be mounted read-only; mount a partition read-only is useful to
 keep malicious users (or processes) from overwriting or replacing binaries
 there with trojans.
 So if your ssh binary lives in /usr/local/bin and /usr/local is mounted
 read-only, it's going to be tough for anyone to replace that binary
\end_layout

\begin_layout Standard
Nota sulla partizione di swap: Inoltre è bene tenere a mente che la partizione
 di swap deve essere almeno della dimensione della 
\begin_inset Quotes eld
\end_inset

RAM
\begin_inset Quotes erd
\end_inset

 nel caso si volesse utilizzare l'opzione di sospensione del computer.
\end_layout

\begin_layout Standard
ATTENZIONE: Directory essenziali al booting del sistema (e cioè /etc ed
 /usr, fatta eccezione per /boot) devono essere sulla stessa partizione
 del rootfs (cioè 
\begin_inset Quotes eld
\end_inset

/
\begin_inset Quotes erd
\end_inset

) o in userspace montati nelle prime fasi dell'avvio da initramfs.
\end_layout

\begin_layout Subsection
Creazione di partizioni e loro gestione
\end_layout

\begin_layout Standard
I dispositivi di memoria (come tutti gli altri dispositvi) possono essere
 visualizzati nella directory /dev/.
 Una volta localizzato il nostro dispositivo in /dev, ad esempio /dev/sda,
 possiamo gestire le partizioni attraverso diversi programmi esistenti come
 il famoso fdisk (se la tabella delle partizioni è MBR) o gdisk (se la tabella
 delle partizioni è GPT), esiste anche un programma molto diffuso oggigiorno
 chiamato 
\begin_inset Quotes eld
\end_inset

parted
\begin_inset Quotes erd
\end_inset

 che supporta sia sistemi MBR che GPT, ha anche un front-end grafico chiamato
 
\begin_inset Quotes eld
\end_inset

gparted
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsubsection
Dischi e Geometria delle Partizioni
\end_layout

\begin_layout Standard
Un Hard Disk, è composto da uno o più piatti magnetici, su questi piatti
 magnetici c'è un braccio elettro-meccanico che simile ad un disco in vinile
 scorre delle circonferenze, che vengono chiamate cilindri, in quanto in
 una vista 3D, più circonferenze su piatti diversi e quindi aventi lo stesso
 asse, possiamo vederli come cilindri.
 Ogni cilindro può essere diviso in più parti chiamate 
\begin_inset Quotes eld
\end_inset

settori
\begin_inset Quotes erd
\end_inset

; questo modo di pensare ai dischi è chiamato CHS (Cylinder-Head-Sector),
 dove Head, sta ad indicare la punta del braccio elettro-meccanico che scorre
 il disco.
 Un cilindro se è acceduto da una sola testina (Head) può essere chiamato
 
\begin_inset Quotes eld
\end_inset

traccia
\begin_inset Quotes erd
\end_inset

.
 Ci sono strumenti in Linux e su altri sistemi operativi che riportano il
 numero di cilindri e tracce, ma questo numero è in realtà fittizio, in
 quanto, non tiene conto di molti fattori caratteristici dei moderni dispositivi
 di memoria; infatti il sistema operativo utilizza l'LBA (Logical Block
 Addressing) per fare riferimento ad uno specifico blocco dell'HDD.
 Un file utile a vedere dove inizia una partizione è:
\end_layout

\begin_layout Itemize
cat /sys/block/sda/sda2/start //visualizza il byte a cui inizia la partizione
 sda2 a partire dall'inizio dell'HDD o SSD, se è divisibile per 4096 (2MB)
 per un SSD allora va bene, altrimenti potrei avere performance ridotte,
 per cattivo allineamento
\end_layout

\begin_layout Subsubsection
fdisk
\end_layout

\begin_layout Standard
nella seguente sezione si farà riferimento ad fdisk.
 Vediamo alcuni esempi applicativi di fdisk:
\end_layout

\begin_layout Itemize
fdisk -l /dev/sda //elenca le partizioni attuali sul dispositivo /dev/sda
\end_layout

\begin_layout Itemize
fdisk /dev/sda //avvia il programma fdisk sul drive sda, in modo da permetterci
 una gestione delle partizioni
\end_layout

\begin_layout Standard
ora da fdisk abbiamo diverse opzioni:
\end_layout

\begin_layout Itemize
p //stampa le partizioni attuali
\end_layout

\begin_layout Itemize
m //lista dei comandi a disposizione all'interno di fdisk
\end_layout

\begin_layout Itemize
n //crea una nuova partizione
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
quando viene creata una nuova partizione, viene richiesto il settore iniziale,
 qui normalmente premiamo Invio, e per il settore finale, diamo valori come
 +300M (per dire 300MB a partire dal settore iniziale), oppure +5G (per
 dire 5GB a partire dal settore iniziale)
\end_layout

\end_deeper
\begin_layout Itemize
d //elimina una partizione
\end_layout

\begin_layout Itemize
q //esce senza salvare le modifiche
\end_layout

\begin_layout Itemize
w //scrive le modifiche sul disco, le modifiche non vengono effettuate,
 finchè non viene lanciato questo comando
\end_layout

\begin_layout Itemize
a //rende una partizione bootable
\end_layout

\begin_layout Itemize
t //permette di specificare il tipo di partizione, questo è solo un ID della
 partizione, non viene effettuata nessuna formattazione, l'operazione di
 formattazione deve essere comunque effettuata successivamente alla gestione
 delle partizioni di fdisk
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Quindi il tipo di partizione è solo un byte, un flag all'interno della tabella
 delle partizioni che aiuta il sistema operativo a capire come gestire quella
 partizione
\end_layout

\end_deeper
\begin_layout Standard
Un'altra opzione potrebbe essere quella di copiare una tabella delle partizioni
 da un device all'altro, questo è possibile attraverso un programma chiamato
 
\begin_inset Quotes eld
\end_inset

sfdisk
\begin_inset Quotes erd
\end_inset

, vediamo come:
\end_layout

\begin_layout Itemize
sfdisk -d /dev/sdb | sfdisk –force /dev/sdc //in questo caso andiamo a copiare
 la tabella delle partizioni di sdb su sdc
\end_layout

\begin_layout Standard
Una volta che le partizioni sono state create, avremo sda1, sda2, eccetera,
 possiamo poi formattarle utilizzando il comando mkfs, ad esempio:
\end_layout

\begin_layout Itemize
mkfs -t ext4 /dev/sda1 //formatta la partizione sda1 del disco 
\begin_inset Quotes eld
\end_inset

sda
\begin_inset Quotes erd
\end_inset

 con filesystem ext4
\end_layout

\begin_layout Standard
N.B.: Un file di configurazione molto importante è /etc/fstab, infatti coi
 comandi 
\begin_inset Quotes eld
\end_inset

mount -a
\begin_inset Quotes erd
\end_inset

, e 
\begin_inset Quotes eld
\end_inset

umount -a
\begin_inset Quotes erd
\end_inset

 possiamo montare e smontare tutto quello che è specificato all'interno
 di questo file.
\end_layout

\begin_layout Subsubsection
Parted
\end_layout

\begin_layout Standard
N.B.: Parted non chiede di confermare le modifiche all'utente, le applica
 direttamente, quindi attenzione a quello che si fa, inoltre per impratichirci
 possiamo provare ad eseguirlo su un dispositivo USB su cui abbiamo dati
 non importanti.
\end_layout

\begin_layout Standard
Il programma 
\begin_inset Quotes eld
\end_inset

parted
\begin_inset Quotes erd
\end_inset

, è un tool molto comodo per gestire le partizioni in quanto supporta sia
 i sistemi MBR che GPT, vediamo come usarlo:
\end_layout

\begin_layout Itemize
parted -l //visualizza informazioni sul disco, sulla tabella di partizioni
 e sulle varie partizioni
\end_layout

\begin_layout Standard
se vogliamo essere sicuri di aver applicato delle modifiche ad una tabella
 di partizioni possiamo utilizzare vari modi per verificare i cambiamenti
 ad esempio:
\end_layout

\begin_layout Itemize
visualizzare il file /proc/partitions
\end_layout

\begin_layout Itemize
visualizzare il contenuto di /sys/block/device/ o in /dev
\end_layout

\begin_layout Itemize
blockdev –rereadpt /dev/sdf //rilegge la partition table del device /dev/sdf
\end_layout

\begin_layout Subsection
Analizzare, formattare, montare e smontare una partizione
\end_layout

\begin_layout Subsubsection
Analisi del filesystem di partizioni
\end_layout

\begin_layout Standard
Prima che il computer possa usare qualsiasi dispositivo di memoria (come
 Hard Drive, CD-ROM o dischi di rete), il sistema operativo deve renderlo
 accessibile attraverso il filesystem del sistema in uso; questo processo
 è chiamato 
\begin_inset Quotes eld
\end_inset

mounting
\begin_inset Quotes erd
\end_inset

, e noi possiamo accedere ai file solo di dispositivi che sono stati montati.
 Prima di montare un filesystem dobbiamo però sapere il tipo di filesystem
 che possiede.
 Nel caso non conoscessimo il tipo di filesystem di un determinato dispositivo,
 possiamo fare uso del comando:
\end_layout

\begin_layout Itemize
blkid
\end_layout

\begin_layout Standard
o in alternativa:
\end_layout

\begin_layout Itemize
file -sL /dev/deviceName
\end_layout

\begin_layout Standard
o in alternativa:
\end_layout

\begin_layout Itemize
df -hT
\end_layout

\begin_layout Standard
o in alternativa:
\end_layout

\begin_layout Itemize
fsck -N /dev/sda1
\end_layout

\begin_layout Standard
Altri comandi utili per analizzare filesystem sono:
\end_layout

\begin_layout Itemize
lsblk //visualizza device e partizioni con uno schema ad albero, molto carino
\end_layout

\begin_layout Itemize
mount | column -t //visualizza le partizioni attualmente montate
\end_layout

\begin_layout Subsubsection
Formattazione di partizioni
\end_layout

\begin_layout Standard
Una volta che conosciamo il tipo di filesystem, possiamo formattare il nostro
 dispositivo con:
\end_layout

\begin_layout Itemize
mkfs -t ext3 /dev/myDevice //formatta il dispositivo myDevice e attraverso
 il flag 
\begin_inset Quotes eld
\end_inset

-t
\begin_inset Quotes erd
\end_inset

 specifico il tipo di filesystem con cui formattarlo, se non specifico il
 tipo allora di default verrà usato il filesystem ext2fs
\end_layout

\begin_layout Itemize
mke2fs -t ext3 /dev/sdb1//completamente equivalente al comando precedente
\end_layout

\begin_layout Itemize
mkfs.ext4 -U 
\begin_inset Quotes eld
\end_inset

ab955ff4-fc2e-40f2-97b3-6fd37b10e7fa
\begin_inset Quotes erd
\end_inset

 /dev/sdb1 //in questo modo formatto la partizione indicata, utilizzando
 l'UUID specificato, questo può essere utile, per fare in modo di non andare
 tute le volte a modificare l'UUID nel file 
\begin_inset Quotes eld
\end_inset

fstab
\begin_inset Quotes erd
\end_inset

 ogniqualvolta formattiamo
\end_layout

\begin_layout Itemize
mke2fs -L myUSBKey /dev/sdb1 //imposta la label 
\begin_inset Quotes eld
\end_inset

myUSBKey
\begin_inset Quotes erd
\end_inset

 sulla partizione sdb1
\end_layout

\begin_layout Itemize
mkfs -t ext3 /dev/myDevice -m 10 //formatta il dispositivo come nel caso
 precedente, ma in questo caso lo spazio di riserva (reserve free space)
 è cambiato al 10%, (di default è al 5%) lo spazio di riserva è spazio riservato
 all'utente root che gli altri utenti non possono usare, e per l'online
 defrag
\end_layout

\begin_layout Itemize
mkfs -t ext3 /dev/myDevice -c //in questo caso viene effettuato un bad block
 check (controllo su settori danneggiati del disco) su ogni settore della
 partizione prima di crearla, per verificare il corretto funzionamento del
 dispositivo
\end_layout

\begin_layout Itemize
mkisofs -V nomeLabel -J -r -o /tmp/boot.iso /boot //crea un file iso chiamato
 boot.iso, 
\begin_inset Quotes eld
\end_inset

-o
\begin_inset Quotes erd
\end_inset

 specifica il nome del file di output, della directory 
\begin_inset Quotes eld
\end_inset

/boot
\begin_inset Quotes erd
\end_inset

 e diamo come nome alla label 
\begin_inset Quotes eld
\end_inset

nomeLabel
\begin_inset Quotes erd
\end_inset

, attraverso il flag 
\begin_inset Quotes eld
\end_inset

-V
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

-J
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

-r
\begin_inset Quotes erd
\end_inset

 indicano di usare un filesystem simile a quello dei CD, nello specifico
 
\begin_inset Quotes eld
\end_inset

-J
\begin_inset Quotes erd
\end_inset

 indica l'opzione Joliet, cioè il poter utilizzare nei nomi dei file sia
 lettere maiuscole che minuscole, nel caso fosse omessa, i nomi sarebbero
 tutti in maiuscolo, il comando 
\begin_inset Quotes eld
\end_inset

mkisofs –help
\begin_inset Quotes erd
\end_inset

 può tornare utile
\end_layout

\begin_layout Standard
Nei casi precedenti sono stati creati solo filesystem di tipo 
\begin_inset Quotes eld
\end_inset

ext3
\begin_inset Quotes erd
\end_inset

 ma per sapere invece quali sono le opzioni disponibili col flag 
\begin_inset Quotes eld
\end_inset

-t
\begin_inset Quotes erd
\end_inset

 attraverso il comando mount, o comunque per capire cosa inserire in funzione
 di un determinato filesystem risultato da uno dei comandi precedenti, allora
 possiamo usare 
\begin_inset Quotes eld
\end_inset

man mount
\begin_inset Quotes erd
\end_inset

; oppure eseguire un:
\end_layout

\begin_layout Itemize
ls -l /sbin/mkfs.* //visualizza tutti i possibili comandi per formattare
\end_layout

\begin_layout Subsubsection
Mounting e unmounting di partizioni
\end_layout

\begin_layout Standard
Per montare un filesystem possiamo effettuare:
\end_layout

\begin_layout Itemize
mount /dev/myDevice /home/user/mountDir //monta il dispositivo di tipo ext2fs
 myDevice nella directory 
\begin_inset Quotes eld
\end_inset

mountDir
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
mount -t ntfs-3g /dev/myDevice /home/user/mountDir //monta il dispositivo
 myDevice con filesystem 
\begin_inset Quotes eld
\end_inset

ntfs
\begin_inset Quotes erd
\end_inset

 in 
\begin_inset Quotes eld
\end_inset

mountDir
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
a volte potrebbe capitare che per qualche motivo non mi faccia montare partizion
i ntfs, perchè magari il sistema era in ibernazione in windows o per il
 fast restarting, o per shutdown impropri, allora posso usare 
\begin_inset Quotes eld
\end_inset

ntfsfix
\begin_inset Quotes erd
\end_inset

 un programma incluso nei pacchetti che mi abilitano il supporto per ntfs,
 ed eseguiamo:
\end_layout

\begin_layout Itemize
sudo ntfsfix /dev/sda5 //dove 
\begin_inset Quotes eld
\end_inset

/dev/sda5
\begin_inset Quotes erd
\end_inset

 in questo caso è il nome della partizione NTFS corrotta, a volte può essere
 necessario utilizzare il flag 
\begin_inset Quotes eld
\end_inset

-b
\begin_inset Quotes erd
\end_inset

 per ripristinare i bad block
\end_layout

\begin_layout Itemize
mount -o loop /home/img.iso /mnt/iso //montiamo un'immagine ISO
\end_layout

\begin_layout Itemize
mount -a //monta tutti i filesystem indicati nel file fstab
\end_layout

\begin_layout Itemize
mount UUID=a9011c2b-1c03-4288-b3fe-8ba961ab0898 /home/extra //monta il device
 con l'UUID specificato nella directory menzionata
\end_layout

\begin_layout Itemize
mount -n -t ntfs-3g /dev/myDevice /home/user/mountDir //monta un device
 senza scrivere sul file /etc/mtab, utile quando si deve fare troubleshooting
 in un ambiente read-only o in single-user mode, in quanto questo file non
 è disponibile in alcune modalità di recovery o di funzionamento del sistema
 operativo, ma ci serve comunque montare un device
\end_layout

\begin_layout Itemize
mount -n -o remount / //rimonta un filesystem, in modalità read-write, se
 si è in modalità read only
\end_layout

\begin_layout Itemize
mount | column -t //visualizza i filesystem montati
\end_layout

\begin_layout Standard
comandi di mount utili quando ad esempio dobbiamo installare un sistema
 da terminaleo quando dobbiamo utilizzare un sistema da live cd sono:
\end_layout

\begin_layout Itemize
mount -t proc proc /mnt/gentoo/proc //monta un filesystem di tipo proc 
\end_layout

\begin_layout Itemize
mount –rbind /sys /mnt/gentoo/sys //l'opzione 
\begin_inset Quotes eld
\end_inset

–rbind
\begin_inset Quotes erd
\end_inset

 permette di eseguire un mount di un filesystem su un altra directory, esiste
 anche 
\begin_inset Quotes eld
\end_inset

–bind
\begin_inset Quotes erd
\end_inset

, ma quest'ultimo esegue un mount di un file su un altro file
\end_layout

\begin_layout Itemize
mount –make-rslave /mnt/gentoo/sys //in questo caso indichiamo che il filesystem
 montato nel comando precedente opera secondo politiche 
\begin_inset Quotes eld
\end_inset

rslave
\begin_inset Quotes erd
\end_inset

, questo significa che se qualcosa viene modificato dal padre, le modifiche
 vengono applicate anche al filesystem figlio, mentre non vale il viceversa
\end_layout

\begin_layout Itemize
mount –rbind /dev /mnt/gentoo/dev //stessa operazione avviene anche per
 il filesystem /dev
\end_layout

\begin_layout Itemize
mount –make-rslave /mnt/gentoo/dev
\end_layout

\begin_layout Standard
Per smontare una periferica, possiamo usare:
\end_layout

\begin_layout Itemize
umount /home/user/mountDir //smonta il dispositivo che era stato montato
 nella directory 
\begin_inset Quotes eld
\end_inset

mountDir
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
sync; umount //in questo caso scriviamo tutto quello che dobbiamo scrivere
 sul device montato e smontiamo
\end_layout

\begin_layout Standard
in alternativa possiamo usare:
\end_layout

\begin_layout Itemize
umount /dev/myDevice //smonta il dispositivo myDevice
\end_layout

\begin_layout Standard
entrambi i comandi hanno esattamente lo stesso effetto.
 Il comando sync è utilizzato per scrivere i dati in cache sul dispositivo/i,
 una storia interessante è che nei tempi antichi in cui venivano usate versioni
 ormai troppo vecchie di Unix prima di spegnere un sistema bisognava sempre
 lanciare la coppia di comandi 
\begin_inset Quotes eld
\end_inset

sync
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

park
\begin_inset Quotes erd
\end_inset

, dove il secondo serviva a posizionare le testine dei dischi in una posizione
 di riposo, questo preveniva in caso di sbalzi di tensione o blackout di
 spaccare il disco, in quanto la testina con forti sbalzi di segnale poteva
 spaccare il disco;
\end_layout

\begin_layout Standard
N.B.: Per abilitare il diritto di poter scrivere, leggere o eseguire su un
 dispositivo di memoria esterno, abbiamo due opzioni:
\end_layout

\begin_layout Itemize
se la periferica è specificata nel file fstab, allora dovremo abilitare
 l'opzione 
\begin_inset Quotes eld
\end_inset

user
\begin_inset Quotes erd
\end_inset

 e settare una appropriata umask
\end_layout

\begin_layout Itemize
se la periferica non è specificata nel file fstab, possiamo:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
cambiare i diritti della directory dove il filesystem viene montato
\end_layout

\begin_layout Itemize
cambiare gruppo di appartenenza alla directory dove il filesystem viene
 montato
\end_layout

\end_deeper
\begin_layout Subsubsection
Gestire file immagine e partizioni contenute
\end_layout

\begin_layout Standard
Per poter gestire file immagine, sfruttiamo la funzionalità di loopback
 del kernel di linux, quindi possiamo creare un device virtuale per contenere
 l'immagine, possiamo eseguirlo con:
\end_layout

\begin_layout Itemize
sudo modprobe loop //questo monta il modulo loop, per poter sfruttare le
 funzionalità di loopback
\end_layout

\begin_layout Itemize
sudo losetup -f //questo ci permette di ottenere un nuovo device di loopback,
 ad esempio /dev/loop0 o se questo è già presente allora /dev/loop1 e così
 via
\end_layout

\begin_layout Itemize
sudo losetup /dev/loop0 myimage.img //questo permette di montare un'immagine
 su un dispositivo
\end_layout

\begin_layout Itemize
sudo partprobe /dev/loop0 //questo indica al kernel che /dev/loop0 non è
 una partizione semplice ma al suo interno esistono diverse partizioni,
 quindi indica al kernel di caricare queste partizioni
\end_layout

\begin_layout Standard
Adesso possiamo ad esempio aprire le nostre partizioni e modificarle o formattar
le con:
\end_layout

\begin_layout Itemize
sudo gparted /dev/loop0
\end_layout

\begin_layout Standard
possiamo anche montarle attraverso una semplice mount, infatti ad esempio
 nel caso volessimo montare /dev/loop0p1 eseguo:
\end_layout

\begin_layout Itemize
mount /dev/loop0p1 /mnt/ //una volta montata posso copiare/rimuovere e fare
 quello che voglio, come se fosse una comune chiavetta USB
\end_layout

\begin_layout Standard
ipotizziamo di voler effettuare lo shrinking di una partizione sul file
 immagine, allora quello che dobbiamo eseguire è:
\end_layout

\begin_layout Itemize
fdisk -l myimage.img //in questo modo vediamo quando finisce la partizione,
 dobbiamo leggere la voce 
\begin_inset Quotes eld
\end_inset

End
\begin_inset Quotes erd
\end_inset

 ad esempio se questa fosse 
\begin_inset Quotes eld
\end_inset

9181183
\begin_inset Quotes erd
\end_inset

 allora per troncare la partizione dopo quel byte dovremmo effettuare
\end_layout

\begin_layout Itemize
truncate --size=$[(9181183+1)*512] myimage.img
\end_layout

\begin_layout Standard
per rimuovere un device di loopback eseguiamo:
\end_layout

\begin_layout Itemize
sudo losetup -d /dev/loop0 //rimuove il device di loopback /dev/loop0
\end_layout

\begin_layout Subsubsection
Dove montare una partizione
\end_layout

\begin_layout Standard
Esistono diverse posizioni sui sistemi GNU/Linux dove per convenzione vengono
 montate le partizioni, vediamo alcuni casi d'uso:
\end_layout

\begin_layout Itemize
/mnt/ //utilizzata per filesystem di dispositivi non rimovibili dalla macchina,
 come partizioni fisse su uno dei nostri hard disk, o filesystem di rete,
 è il posto adatto anche per mount che vengono effettuate manualmente
\end_layout

\begin_layout Itemize
/media/ //utilizzata per dispositivi che rimuoviamo dalla nostra macchina,
 come chiavette USB, hard disk esterni, floppy disk, CD-ROM, DVD, eccetera.
\end_layout

\begin_layout Itemize
/run/media/username/ //permette di effettuare le stesse cose di 
\begin_inset Quotes eld
\end_inset

/media
\begin_inset Quotes erd
\end_inset

, ma differenziando per username riesco a controllare meglio i diritti che
 ogni utente ha sulla partizione
\end_layout

\begin_layout Subsubsection
Visualizzare le partizioni attualmente montate
\end_layout

\begin_layout Standard
Per visualizzare le partizioni montate in un determinato istante possiamo
 procedere in 3 modalità analoghe:
\end_layout

\begin_layout Itemize
mount //esegue il comando mount senza flag, questo visualizza i filesystem
 montati
\end_layout

\begin_layout Itemize
cat /etc/mtab //visualizza il file 
\begin_inset Quotes eld
\end_inset

mtab
\begin_inset Quotes erd
\end_inset

, questo è un file di sola-lettura e non ha senso modificarlo, costituisce
 il system runtime mount database
\end_layout

\begin_layout Itemize
cat /proc/mounts //visualizza il file 
\begin_inset Quotes eld
\end_inset

mounts
\begin_inset Quotes erd
\end_inset

, questo è un file di sola-lettura e non ha senso modificarlo
\end_layout

\begin_layout Subsubsection
Recovery di partizioni ntfs
\end_layout

\begin_layout Standard
Un buon programma per recuperare file da partizioni corrotte o file che
 sono stati cancellati su partizioni ntfs è 
\begin_inset Quotes eld
\end_inset

testdisk
\begin_inset Quotes erd
\end_inset

.
 Una volta avviato con i diritti di root (i.e.
 sudo) basterà fargli fare un 
\begin_inset Quotes eld
\end_inset

analyze
\begin_inset Quotes erd
\end_inset

 sull'Hard Disk desiderato per recuperare iniziale il processo di analisi
 e ricostruzione della partizione, una volta ricostruita comparirà una voce
 in basso 
\begin_inset Quotes eld
\end_inset

P
\begin_inset Quotes erd
\end_inset

 (n.b.
 : in questo programma le azioni disponibili sono sempre o in basso o in
 alto) che ci permetterà di elencare i file sulla partizione ed eventualmente
 copiarli.
 
\end_layout

\begin_layout Subsection
Il file 
\begin_inset Quotes eld
\end_inset

fstab
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Il file 
\begin_inset Quotes eld
\end_inset

fstab
\begin_inset Quotes erd
\end_inset

 situato in /etc/fstab è un file utilizzato per mantenere informazioni su
 filesystem statici (cioè filesystem che sono frequentemente montati su
 un computer).
 Aggiungere una voce al file fstab è semplice, è bene tenere a mente che
 generalmente è composto da 6 colonne:
\end_layout

\begin_layout Itemize
la prima, rappresenta il percorso del dispositivo (eg /dev/sda1)
\end_layout

\begin_layout Itemize
la seconda, rappresenta la directory in cui vogliamo montare il nostro dispositi
vo (eg /mnt/mySda1)
\end_layout

\begin_layout Itemize
la terza, reppresenta il tipo (o i tipi) di filesystem (ad ogni modo è possibile
 anche l'opzione 
\begin_inset Quotes eld
\end_inset

auto
\begin_inset Quotes erd
\end_inset

, che lascia al kernel il compito di rilevare il tipo di filesystem sul
 dispositivo)
\end_layout

\begin_layout Itemize
la quarta, è utilizzata per indicare diverse opzioni separate da una virgola,
 le opzioni possono essere:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
uid: imposta il proprietario dei file che vengono montati
\end_layout

\begin_layout Itemize
umask: imposta la umask di default per la partizione montata 
\end_layout

\begin_layout Itemize
auto/noauto: monta/non monta in automatico la partizione dopo il boot, ATTENZION
E, è importante non impostare questa opzione per chiavette USB o altri dispositi
vi che vengono normalmente rimossi dal computer, in quanto a boot, se non
 trova la partizione che deve montare entra in una 
\begin_inset Quotes eld
\end_inset

Emergency Mode
\begin_inset Quotes erd
\end_inset

 o in genere una shell di recovery.
 E' una modalità utile invece per partizioni che montiamo in automatico
 al boot, come una partizione dati utente eccetera.
\end_layout

\begin_layout Itemize
exec/noexec: permette/non permette di eseguire file eseguibili contenuti
 nella partizione montata (utile per evitare virus che cercano di essere
 lanciati in automatico)
\end_layout

\begin_layout Itemize
ro/rw: il filesystem può essere montato in sola lettura (read only) o in
 lettura e scrittura (read & write)
\end_layout

\begin_layout Itemize
user/nouser: permette/non permette a utenti normali (cioè non root) di montare
 il dispositivo
\end_layout

\begin_layout Itemize
sync/async: imposta la scrittura dei file sincrona/asincrona, cioè quando
 ad esempio viene lanciato un comando di copia verso una chiavetta se l'opzione
 sincrona è attiva, i file vengono copiati subito nel momento del lancio
 del comando, mentre nel caso di modalità asincrona i file vengono copiati
 quando la partizione viene smontata o quando viene eseguito il comando
 
\begin_inset Quotes eld
\end_inset

sync
\begin_inset Quotes erd
\end_inset

, è buona norma utilizzare infatti il comando 
\begin_inset Quotes eld
\end_inset

sync
\begin_inset Quotes erd
\end_inset

 prima di smontare una partizione montata con 
\begin_inset Quotes eld
\end_inset

async
\begin_inset Quotes erd
\end_inset

; meglio utilizzare la modalità 
\begin_inset Quotes eld
\end_inset

async
\begin_inset Quotes erd
\end_inset

, in quanto ci permette di velocizzare il tutto consumando meno anche i
 dispositivi, la modalità sync non andrebbe mai utilizzata, va utilizzata
 solo nel caso in cui vogliamo smontare un dispositivo senza effettuare
 
\begin_inset Quotes eld
\end_inset

umount
\begin_inset Quotes erd
\end_inset

, o dove comunque le politiche di caching vengono gestite autonomamente
 come in un ramdisk (memoria RAM) o in un database, insomma in casi d'uso
 molto particolari, i sistemi operativi Microsoft, solitamente utilizzano
 una politica async ma con un periodo di flush molto breve.
\end_layout

\begin_layout Itemize
defaults: imposta diverse opzioni, infatti defaults costituisce: rw,suid,dev,exe
c,auto.nouser, e async
\end_layout

\end_deeper
\begin_layout Itemize
la quinta, rappresenta la modalità 
\begin_inset Quotes eld
\end_inset

dump
\begin_inset Quotes erd
\end_inset

, in questo caso possiamo impostare questo valore a 0 (non impostato) o
 1 (impostato), se vale 1, allora l'utility di dump effettuerà il backup
 della partizione, questa è una tenica old school per effettuare backup
\end_layout

\begin_layout Itemize
la sesta, rappresenta il 
\begin_inset Quotes eld
\end_inset

Filesystem check
\begin_inset Quotes erd
\end_inset

 (o fsck), in questo caso i valori possibili sono 0 (non impostato) o valore
 positivo diverso da zero (impostato), se è impostata, permette al computer
 di effettuare un controllo di integrità del filesystem al riavvio nel caso
 di crash di sistema o sorgono problemi legati al disco, l'intero rappresenta
 l'ordine della partizione nel controllo di integrità, ad esempio se abbiamo
 impostato 1, allora questa sarà la prima partizione ad essere sottoposta
 al controllo di integrità, se abbiamo impostato 2 sarà la seconda partizione
 ad essere sottoposta al controllo di integrità e così via
\end_layout

\begin_layout Standard
N.B.: E' sempre buona norma utilizzare gli UUID dei device, visualizzabili
 con comandi tipo 
\begin_inset Quotes eld
\end_inset

blkid
\begin_inset Quotes erd
\end_inset

, in quanto più sicuri rispetto all'indicare la partizione.
\end_layout

\begin_layout Standard
N.B.2: Normalmente per le chiavette USB o per dispositivi rimovibili è sconsigliat
o utilizzare fstab, ma si rimanda la gestione dell'automount a Desktop Environme
nt/Window Manager o programmi come autofs; ad esempio in XFCE, bisogna installar
e i pacchetti 
\begin_inset Quotes eld
\end_inset

thunar-volman
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

gvfs
\begin_inset Quotes erd
\end_inset

 ed aggiungere l'utente con cui si vuole poter scrivere sui dispositivi
 al gruppo 
\begin_inset Quotes eld
\end_inset

plugdev
\begin_inset Quotes erd
\end_inset

, mentre con altri file manager basta includere l'utente nel gruppo 
\begin_inset Quotes eld
\end_inset

plugdev
\begin_inset Quotes erd
\end_inset

, se il gruppo non esiste, bisogna crearlo.
\end_layout

\begin_layout Standard
Although the /etc/fstab file has been the traditional way to represent filesyste
ms and their mount points, two new alternatives have appeared.
 The first is an /etc/fstab.d directory that contains individual filesystem
 configuration files (one file for each filesystem).
 The idea is very similar to many other configuration directories that you’ll
 see throughout this book.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#Vediamo un esempio di automount per partizioni ntfs
\end_layout

\begin_layout Plain Layout

UUID=2832buin2iu923j292anwd982   /media/user/C ntfs   permissions	0	2
\end_layout

\begin_layout Plain Layout

#Oppure avremmo potuto specificare il device attraverso il device file al
 posto dell'UUID
\end_layout

\begin_layout Plain Layout

#ma questa pratica è sconsigliata, per completezza riportiamo comunque un
 esempio
\end_layout

\begin_layout Plain Layout

/dev/sdb1  /media/user/C ntfs   permissions	0	2
\end_layout

\end_inset


\end_layout

\begin_layout Standard
oppure per montare un filesystem di tipo ext4 possiamo ad esempio aggiungere
 al file:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#In questo caso per semplicità abbiamo inserito il percorso al path file
\end_layout

\begin_layout Plain Layout

#ma ricordiamo che è sempre consigliato inserire il codice UUID
\end_layout

\begin_layout Plain Layout

/dev/sda3   /mnt/myPart  ext4    defaults    0   2
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Swap
\end_layout

\begin_layout Standard
Con il termine swap si intende, in informatica, l'estensione della capacità
 della memoria volatile complessiva del computer, oltre il limite imposto
 dalla quantità di RAM installata, attraverso l'utilizzo di uno spazio su
 un altro supporto fisico di memorizzazione, ad esempio il disco fisso.
 L'uso dello swap è una delle tecniche impiegate dal sistema operativo per
 la gestione della memoria virtuale.
 Vediamo come impostare della memoria come swap su un sistema:
\end_layout

\begin_layout Itemize
sudo dd if=/dev/zero of=/mnt/swap.swp bs=1024 count=800k //crea un file da
 800MB che viene salvato in /mnt/, questo file lo vogliamo utilizzare come
 swap, altra directory possibile sarebbe stata 
\begin_inset Quotes eld
\end_inset

~/swap.swp
\begin_inset Quotes erd
\end_inset

 per crearlo all'interno della home directory; un'alternativa a 
\begin_inset Quotes eld
\end_inset

dd
\begin_inset Quotes erd
\end_inset

 sarebbe stata utilizzare 
\begin_inset Quotes eld
\end_inset

fallocate -l 800M /mnt/swap.swp
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
fallocate -l 1k file //crea un file da un 1k
\end_layout

\begin_layout Standard
Questo file creato dovrebbe essere appartenente all'utente di 
\begin_inset Quotes eld
\end_inset

root
\begin_inset Quotes erd
\end_inset

 e con permessi 
\begin_inset Quotes eld
\end_inset

0600
\begin_inset Quotes erd
\end_inset

, quindi eseguiamo:
\end_layout

\begin_layout Itemize
sudo chmod 0600 swap.swp //impone come permessi 0600 sul file, il proprietario
 dovrebbe già essere 
\begin_inset Quotes eld
\end_inset

root
\begin_inset Quotes erd
\end_inset

 in quanto il file è stato creato attraverso sudo
\end_layout

\begin_layout Standard
per essere sicuri che appartenga a root eseguiamo:
\end_layout

\begin_layout Itemize
chown root:root swap.swp
\end_layout

\begin_layout Itemize
mkswap swap.swp //imposta il filesystem utilizzato dalle partizioni di swap
 sul file indicato, nel caso avessimo utilizzato una prtizione avremmo dovuto
 mettere al posto di 
\begin_inset Quotes eld
\end_inset

swap.swp
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

/dev/myPartition
\begin_inset Quotes erd
\end_inset

, dove 
\begin_inset Quotes eld
\end_inset

myPartition
\begin_inset Quotes erd
\end_inset

 indica la partizione
\end_layout

\begin_layout Itemize
swapon swap.swp //attiva il file swap.swp come spazio di swap
\end_layout

\begin_layout Standard
per renderlo fisso, dobbiamo aggiornare il file fstab con una stringa così:
\end_layout

\begin_layout Itemize
/percorso/alFile/Swap none swap sw 0 0
\end_layout

\begin_layout Standard
Possiamo verificare le modifiche apportate attraverso:
\end_layout

\begin_layout Itemize
free -m //visualizza informazioni sulla memoria
\end_layout

\begin_layout Standard
Una volta riavviato il sistema, lo spazio di swap non sarà attivo, per rendere
 questa memoria di swap permanente dovremo moddificare il file 
\begin_inset Quotes eld
\end_inset

/etc/fstab
\begin_inset Quotes erd
\end_inset

 aggiungendo una riga del tipo:
\end_layout

\begin_layout Itemize
/percorsoAlFileDiSwap/swap.swp / swap defaults
\end_layout

\begin_layout Standard
Altri comandi utili sono:
\end_layout

\begin_layout Itemize
swapoff -a //disattiva tutte le partizioni di swap indicate nel file 
\begin_inset Quotes eld
\end_inset

/etc/fstab
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
swapon -a //attiva tutte le partizioni di swap indicate nel file 
\begin_inset Quotes eld
\end_inset

/etc/fstab
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Quanto Swap fare?
\end_layout

\begin_layout Standard
Tanto tempo fa una regola empirica era fare una partizione/file di swap
 di due volte la quantità fisica di RAM, ma oggi non è più necessario, basta
 un po' di swap.
\end_layout

\begin_layout Subsection
Gestione dello spazio su disco con Quota
\end_layout

\begin_layout Standard
Quota è un famoso software utilizzato per gestire spazio su disco per gli
 utenti e per i gruppi.
 Possiamo ad esempio limitare le dimensioni dei file o delle directory che
 un utente può possedere o con cui può operare.
\end_layout

\begin_layout Subsubsection
Preparazione della macchina per l'utilizzo di Quota
\end_layout

\begin_layout Standard
Innanzitutto dobbiamo installare i pacchetti 
\begin_inset Quotes eld
\end_inset

quota
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

quotatool
\begin_inset Quotes erd
\end_inset

, vediamo come fare su una macchina Debian-based:
\end_layout

\begin_layout Itemize
sudo apt-get install quota quotatool
\end_layout

\begin_layout Standard
Dopo aver installato quest istrumenti, dobbiamo specificare le partizioni
 su cui vogliamo usare quota, per farlo, andremo nel file /etc/fstab e aggiunger
emo nella colonna delle opzioni (cioè la quarta colonna) le opzioni 
\begin_inset Quotes eld
\end_inset

usrquota, grpquota
\begin_inset Quotes erd
\end_inset

 per poter usare quota sia sugli utenti che sui gruppi.
\end_layout

\begin_layout Standard
Il prossimo passo è quello di creare un paio di file coi diritti di root,
 quindi usando 
\begin_inset Quotes eld
\end_inset

sudo
\begin_inset Quotes erd
\end_inset

 nella directory root 
\begin_inset Quotes eld
\end_inset

/
\begin_inset Quotes erd
\end_inset

 chiamati:
\end_layout

\begin_layout Itemize
/quota.user (nelle versioni più recenti, il file è chiamato 
\begin_inset Quotes eld
\end_inset

aquota.user
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Itemize
/quota.group (nelle versioni più recenti, il file è chiamato 
\begin_inset Quotes eld
\end_inset

aquota.group
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Standard
Quindi eseguiamo, dopo averli creati:
\end_layout

\begin_layout Itemize
sudo chmod 600 /quota.*
\end_layout

\begin_layout Standard
una volta effettuata questa operazione, effettuiamo un remount della partizione
 di root 
\begin_inset Quotes eld
\end_inset

/
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Itemize
sudo mount -o remount /
\end_layout

\begin_layout Standard
Infine, dobbiamo creare un database, e attivare quota facendo:
\end_layout

\begin_layout Itemize
sudo quotacheck -avugm //genera un database per il programma quota, dove:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
a: controlla tutti i filesystem montati (non di rete) nel file /etc/mtab
\end_layout

\begin_layout Itemize
v: attiva la modalità verbose
\end_layout

\begin_layout Itemize
u: solo gli utenti elencati nel file /etc/mtab devono essere controllati,
 questa opzione è di default
\end_layout

\begin_layout Itemize
g: solo i gruppi elencati nel file /etc/mtab devono essere controllati
\end_layout

\begin_layout Itemize
m: non provare a rimontare i filesystem in modalità di sola lettura (read-only)
\end_layout

\begin_layout Itemize
N.B.: E' possibile inserire come flag 
\begin_inset Quotes eld
\end_inset

-c
\begin_inset Quotes erd
\end_inset

 per creare i file quota.user e quota.group, in modo da non doverli creare
 manualmente
\end_layout

\end_deeper
\begin_layout Itemize
quotaon -avug //viene attivato quota, può essere spento con 
\begin_inset Quotes eld
\end_inset

quotaoff -avug
\begin_inset Quotes erd
\end_inset

 dove in entrambi i casi i flag hanno significato:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
a: effettua l'operazione su tutti i filesystem in /etc/fstab
\end_layout

\begin_layout Itemize
v: attiva la modalità verbose
\end_layout

\begin_layout Itemize
u: effettua l'operazione per gli utenti
\end_layout

\begin_layout Itemize
g: effettua l'operazione per i gruppi
\end_layout

\end_deeper
\begin_layout Standard
N.B.: Solo se il quota è stato attivato attraverso un 
\begin_inset Quotes eld
\end_inset

quotaon
\begin_inset Quotes erd
\end_inset

 allora viene impedito agli utenti di superare i limiti imposti, quindi
 è bene tenere a mente di attivare quota dopo la configurazione per l'utilizzo.
 
\end_layout

\begin_layout Subsubsection
Configurazione di Quota
\end_layout

\begin_layout Standard
Abbiamo bisogno di un paio di applicazioni per configurare quota.
 Per controllare le configurazioni di quota per un particolare utente eseguiamo:
\end_layout

\begin_layout Itemize
quota nomeUtente //mostra la configurazione quota per l'utente nomeUtente
\end_layout

\begin_layout Itemize
quota -g nomeGruppo //mostra la configurazione quota per il gruppo nomeGruppo
\end_layout

\begin_layout Standard
La configurazione quota è suddivisa su sette colonne:
\end_layout

\begin_layout Itemize
la prima, indica il filesystem relativo alla configurazione
\end_layout

\begin_layout Itemize
la seconda, 
\begin_inset Quotes eld
\end_inset

blocks
\begin_inset Quotes erd
\end_inset

 (o blocchi), e rappresenta lo spazio occupato attualmente dall'utente in
 blocchi, dove per blocco si intende uno spazio da 1kB
\end_layout

\begin_layout Itemize
la terza, 
\begin_inset Quotes eld
\end_inset

blocks soft limit
\begin_inset Quotes erd
\end_inset

 (o limite soft per i blocchi), e rappresenta un limite per i blocchi che
 può usare l'utente, essendo un limite 
\begin_inset Quotes eld
\end_inset

soft
\begin_inset Quotes erd
\end_inset

, questo vuol dire che l'utente può temporaneamente superare questo limite
 secondo il 
\begin_inset Quotes eld
\end_inset

grace time
\begin_inset Quotes erd
\end_inset

 (o tempo di grazie) di default impostato a sette giorni
\end_layout

\begin_layout Itemize
la quarta, 
\begin_inset Quotes eld
\end_inset

blocks hard limit
\begin_inset Quotes erd
\end_inset

 (o limite hard per i blocchi), e rappresenta un limite per i blocchi che
 l'utente non può assolutamente superare
\end_layout

\begin_layout Itemize
la quinta, 
\begin_inset Quotes eld
\end_inset

inodes
\begin_inset Quotes erd
\end_inset

, rappresenta il numero di file attualmente in possesso dall'utente
\end_layout

\begin_layout Itemize
la sesta, 
\begin_inset Quotes eld
\end_inset

inodes soft limit
\begin_inset Quotes erd
\end_inset

 (o limite soft per gli inodes), e rappresenta un limite per i file che
 può possedere l'utente, essendo un limite 
\begin_inset Quotes eld
\end_inset

soft
\begin_inset Quotes erd
\end_inset

, questo vuol dire che l'utente può temporaneamente superare questo limite
 secondo il 
\begin_inset Quotes eld
\end_inset

grace time
\begin_inset Quotes erd
\end_inset

 (o tempo di grazie) di default impostato a sette giorni
\end_layout

\begin_layout Itemize
la settima, 
\begin_inset Quotes eld
\end_inset

inodes hard limit
\begin_inset Quotes erd
\end_inset

 (o limite hard per gli inodes), e rappresenta un limite per i file che
 l'utente non può assolutamente superare
\end_layout

\begin_layout Standard
Per avere un quadro generale della configurazione quota su un filesystem
 facciamo:
\end_layout

\begin_layout Itemize
repquota / //mostra la configurazione quota sul filesystem
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
in questo caso, le ultime due colonne rappresentano i limiti sui file e
 le prime due i limiti sui blocchi
\end_layout

\end_deeper
\begin_layout Itemize
repquota -s / //mostra la configurazione quota sul filesystem, evidenziando
 le misure in kB
\end_layout

\begin_layout Standard
Per impostare o modificare la configurazione quota su un utente, eseguiamo:
\end_layout

\begin_layout Itemize
edquota nomeUtente //mostra la configurazione quota per l'utente nomeUtente,
 aprendo il file relativo all'utente, andremo a modificare qui le opzioni
 desiderate
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
edquota aprirà il file di testo attraverso l'editor specificato nella variabile
 d'ambiente 
\begin_inset Quotes eld
\end_inset

EDITOR
\begin_inset Quotes erd
\end_inset

, per cambiare l'editor, dobbiamo impostare la variabile d'ambiente editor
 con un comando o andando a modificare il file 
\begin_inset Quotes eld
\end_inset

~/.bash_profile
\begin_inset Quotes erd
\end_inset

 inserendo il percorso completo all'editor
\end_layout

\end_deeper
\begin_layout Itemize
edquota -g nomeGruppo //mostra la configurazione quota per l'utente nomeUtente,
 aprendo il file relativo all'utente, andremo a modificare qui le opzioni
 desiderate
\end_layout

\begin_layout Standard
ad esempio, impostando 100 nel campo 
\begin_inset Quotes eld
\end_inset

blocks hard limit
\begin_inset Quotes erd
\end_inset

 (cioè la quarta colonna) imponiamo un limite di 100kB all'utente nomeUtente.
 Oppure in alternativa possiamo lanciare:
\end_layout

\begin_layout Itemize
setquota -u nomeUtente 100 200 10 15 / //in questo caso viene impostato
 per l'utente nomeUtente un soft limit per i blocchi di 100, un hard limit
 di 200, un soft limit per i file di 10 e un hard limit per i file di 15
 sul filesystem 
\begin_inset Quotes eld
\end_inset

/
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Lanciando ora:
\end_layout

\begin_layout Itemize
repquota -s / //mostra la configurazione quota sul filesystem, evidenziando
 le misure in kB
\end_layout

\begin_layout Standard
I 
\begin_inset Quotes eld
\end_inset

grace time
\begin_inset Quotes erd
\end_inset

 (o tempo di grazia) possono essere modificati per un determinato utente
 con:
\end_layout

\begin_layout Itemize
edquota -T nomeUtente //permette di modificare la configurazione dei grace
 time per l'utente nomeUtente
\end_layout

\begin_layout Standard
Siccome periodicamente dobbiamo aggiornare il database di quota, è utile
 inserire l'aggiornamento del database in un crontab andando a creare un
 file chiamato 
\begin_inset Quotes eld
\end_inset

quotacheck
\begin_inset Quotes erd
\end_inset

 nella directory 
\begin_inset Quotes eld
\end_inset

/etc/cron.daily/
\begin_inset Quotes erd
\end_inset

, all'interno del file, inseriamo il comando
\end_layout

\begin_layout Itemize
quotacheck -avumg //aggiorna il database utilizzato da quota
\end_layout

\begin_layout Standard
N.B.: Per una descrizione più approfondita di quota, è consigliato visualizzare
 la documentazione presente al link 
\begin_inset CommandInset href
LatexCommand href
name "Documentazione Quota"
target "http://www.ibm.com/developerworks/library/l-lpic1-v3-104-4/index.html"

\end_inset

.
\end_layout

\begin_layout Subsection
Manutenzione dei dispositivi di memoria di tipo 
\begin_inset Quotes eld
\end_inset

ext
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
In questa sezione vedremo alcuni strumenti che cipermetteranno di effettuare
 una manutenzione più semplice di quella che avverrebbe col programma 
\begin_inset Quotes eld
\end_inset

debugfs
\begin_inset Quotes erd
\end_inset

, attraverso i programmi:
\end_layout

\begin_layout Itemize
dumpe2fs: ci permette di visualizzare informazioni sui filesystem, simile
 a debugfs, ma non interattivo
\end_layout

\begin_layout Itemize
tune2fs: ci permette di impostare parametri avanzati su filesystem ext
\end_layout

\begin_layout Standard
Vediamo alcuni esempi:
\end_layout

\begin_layout Itemize
dumpe2fs /dev/myDevice //visualizza informazioni sul device, numero di blocchi,
 numero di inode, blocchi liberi, nomero di mount effettuate, e numero massimo
 di mount prima del filesystem check, o il check interval temporale, e tanti
 altri dettagli sulla partizione
\end_layout

\begin_layout Itemize
dumpe2fs -h /dev/myDevice //visualizza un resoconto delle informazioni sul
 device
\end_layout

\begin_layout Itemize
tune2fs -c /dev/myDevice //imposta il numero massimo di mount da effettuare
 prima di eseguire un check sul disco forzato
\end_layout

\begin_layout Itemize
tune2fs -C /dev/myDevice //cambia il numero di mount effettuati
\end_layout

\begin_layout Itemize
tune2fs -i ???(non lo so) /dev/myDevice //cambia l'intervallo temporale
 massimo permesso senza effettuare un check, dopo questo intervallo viene
 forzato un check
\end_layout

\begin_layout Itemize
tune2fs -L newLabel /dev/myDevice //cambia la label di un dispositivo
\end_layout

\begin_layout Subsection
Manutenzione dei dispositivi di memoria di tipo 
\begin_inset Quotes eld
\end_inset

xfs
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Per gestire filesystem di tipo 
\begin_inset Quotes eld
\end_inset

xfs
\begin_inset Quotes erd
\end_inset

 abbiamo bisogno di due pacchetti chiamati 
\begin_inset Quotes eld
\end_inset

xfsprogs
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

xfsdump
\begin_inset Quotes erd
\end_inset

, quindi su una distribuzione basata su debian faremo:
\end_layout

\begin_layout Itemize
sudo apt-get install xfsprogs xfsdump //installa i pacchetti xfsprogs e
 xfsdump
\end_layout

\begin_layout Standard
una volta installati questi pacchetti avremo una serie di utility nella
 directory 
\begin_inset Quotes eld
\end_inset

/usr/sbin2, ovviamente li troviamo in questa directory in quanto in 
\begin_inset Quotes eld
\end_inset

/sbin
\begin_inset Quotes erd
\end_inset

 sono situati solo i pacchetti standard installati nella mia distro, facendo
 ora un:
\end_layout

\begin_layout Itemize
ls -al /usr/sbin/xfs* //visualizza tutte le utility per gestire filesystem
 xfs
\end_layout

\begin_layout Standard
Ora vedremo alcuni esempi applicativi delle utility più rilevanti:
\end_layout

\begin_layout Itemize
xfs_check /dev/myDevice //esegue un check simile a fsck ma su un filesystem
 xfs, anche in questo caso il dilesystem non deve essere montato
\end_layout

\begin_layout Itemize
xfsdump -J -f nomeBackup /mnt/myMountedDevice //effettua un backup anche
 del journal 
\begin_inset Quotes eld
\end_inset

-J
\begin_inset Quotes erd
\end_inset

 del device montato in /mnt/myMountedDevice e lo salva in un file chiamato
 
\begin_inset Quotes eld
\end_inset

nomeBackup
\begin_inset Quotes erd
\end_inset

, il flag 
\begin_inset Quotes eld
\end_inset

-f
\begin_inset Quotes erd
\end_inset

 ci permette di copiare tutti i file e tutte le directory nel backup ricorsivame
nte, successivamente ci verrà richiesta una label per il backup che verrà
 creato
\end_layout

\begin_layout Itemize
xfsrestore -J -f nomeBackup /mnt/myMountedDevice //ripristina il backup
 nella directory myMountedDevice, effettua cioè l'operazione opposta a quella
 effettuata nel comando precedente
\end_layout

\begin_layout Itemize
xfs_admin -L myDataXFS /dev/sdb1 //rinominiamo la label della partizione
 sdb1 col nome 
\begin_inset Quotes eld
\end_inset

myDataXFS
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
xfs_admin -l /dev/sdb1 //visualizza la label della partizione sdb1
\end_layout

\begin_layout Standard
Queste sono solo alcune delle utility presenti, tra l'altro sono state presentat
e con un numero limitatissimo di esempi, è consigliato guardare il manuali
 attraverso il comando 
\begin_inset Quotes eld
\end_inset

man
\begin_inset Quotes erd
\end_inset

 sulle utility presenti al percorso 
\begin_inset Quotes eld
\end_inset

/usr/sbin/xfs*
\begin_inset Quotes erd
\end_inset

 per effettuare operazioni più complicate.
\end_layout

\begin_layout Subsection
RAID
\end_layout

\begin_layout Standard
Il RAID (originally redundant array of inexpensive disks; ora più comunemente
 redundant array of independent disks) è una tecnica di raggruppamento di
 diversi dischi rigidi collegati ad un computer che li rende utilizzabili,
 dalle applicazioni e dall'utente, come se fosse un unico volume di memorizzazio
ne.
 Tale aggregazione sfrutta, con modalità differenti a seconda del tipo di
 implementazione, i principi di ridondanza dei dati e di parallelismo nel
 loro accesso per garantire, rispetto ad un disco singolo, incrementi di
 prestazioni, aumenti nella capacità di memorizzazione disponibile, migliorament
i nella tolleranza ai guasti.
 Esistono diverse configurazioni RAID utilizzate per diversi scopi, si parla
 dei cosiddetti livelli di RAID:
\end_layout

\begin_layout Itemize
RAID Lineare: Le partizioni (o i dischi) non sono delle stesse dimensioni,
 ma costituireanno un volume unico con una dimensione data dalla somma delle
 dimensioni dei singoli
\end_layout

\begin_layout Itemize
RAID 0: Le partizioni (o i dischi) sono delle stesse dimensioni e costituireanno
 un volume unico con una dimensione data dalla somma delle dimensioni dei
 singoli
\end_layout

\begin_layout Itemize
RAID 1: Mirrora i dati tra dischi/partizioni di dimensioni uguali (alto
 livello di ridondanza ma spreco di capacità)
\end_layout

\begin_layout Itemize
RAID 4/5/6: I dati vengono copiati su tre o più dischi sfruttando controlli
 come blocchi di parità
\end_layout

\begin_layout Standard
Il filesystem ID (quello che viene usato da fdisk) da utilizzare su dischi
 su cui vogliamo utilizzare il RAID è 
\begin_inset Quotes eld
\end_inset

0xDA
\begin_inset Quotes erd
\end_inset

 detto anche 
\begin_inset Quotes eld
\end_inset

Non FS
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Vediamo come impostare il raid, supponiamo di avere 4 device chiamati 
\begin_inset Quotes eld
\end_inset

sdb
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

sdc
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

sdd
\begin_inset Quotes erd
\end_inset

 ed 
\begin_inset Quotes eld
\end_inset

sde
\begin_inset Quotes erd
\end_inset

, innanzitutto lanciamo:
\end_layout

\begin_layout Itemize
fdisk /dev/sdb //lanciamo fdisk e selezioniamo una partizione di tipo 
\begin_inset Quotes eld
\end_inset

da
\begin_inset Quotes erd
\end_inset

 cioè 
\begin_inset Quotes eld
\end_inset

Non FS
\begin_inset Quotes erd
\end_inset

 che occupa l'intero disco
\end_layout

\begin_layout Itemize
sfdisk -d /dev/sdb | sfdisk –force /dev/sdc //copiamo la tabella di partizioni
 appena creata su sdb in sdc
\end_layout

\begin_layout Itemize
lsblk //visualizziamo l'albero delle partizioni per verificare di avere
 effettivamente sia sdb che sdc con una sola partizione
\end_layout

\begin_layout Standard
Per creare un RAID 1 ora eseguiamo:
\end_layout

\begin_layout Itemize
mdadm –create –verbose /dev/md0 –level=mirror –raid-devices=2 /dev/sdb1
 /dev/sdc1 //crea un device chiamato 
\begin_inset Quotes eld
\end_inset

md0
\begin_inset Quotes erd
\end_inset

 atto a rappresentare il disco RAID
\end_layout

\begin_layout Standard
Possiamo verificare la corretta creazione del device di RAID attraverso:
\end_layout

\begin_layout Itemize
cat /proc/mdstat //visualizza il file 
\begin_inset Quotes eld
\end_inset

mdstat
\begin_inset Quotes erd
\end_inset

 che dovrebbe contenere qualche dato dopo aver generato il device di RAID
\end_layout

\begin_layout Itemize
lsmod | grep raid //verifica se il modulo relativo al RAID è caricato dal
 kernel
\end_layout

\begin_layout Standard
Dobbiamo rendere ora persistente il RAID andando a mettere mano al file
 
\begin_inset Quotes eld
\end_inset

/etc/mdadm.conf
\begin_inset Quotes erd
\end_inset

 o 
\begin_inset Quotes eld
\end_inset

/etc/mdadm/mdadm.conf
\begin_inset Quotes erd
\end_inset

 (che è il file di configurazione del RAID) a differenza della distribuzione,
 per fortuna, possiamo anche non andare a scrivere cosa manualmente nei
 file ma possiamo fare uso del programma mdadm, attraverso:
\end_layout

\begin_layout Itemize
mdadm –detail –scan >> /etc/mdadm.conf //configura il RAID in modo persistente
\end_layout

\begin_layout Standard
per fermare un RAID possiamo effettuare:
\end_layout

\begin_layout Itemize
mdadm –stop /dev/md0
\end_layout

\begin_layout Standard
oppure per avviarlo (o riavviarlo) possiamo eseguire:
\end_layout

\begin_layout Itemize
mdadm –assemble –scan
\end_layout

\begin_layout Standard
Ora possiamo formattare md0 col filesystem che più preferiamo e il gioco
 è fatto; possiamo effettuare:
\end_layout

\begin_layout Itemize
mkfs.ext4 /dev/md0 //formatta tutto il sistema RAID con filesystem ext4
\end_layout

\begin_layout Subsubsection
RAID ocn Btrfs
\end_layout

\begin_layout Standard
Avere un filesystem che supporta nativamente il RAID è di grande vantaggio,
 in quanto semplifica significativamente la creazione di un sistema RAID;
 il filesystem Btrfs supporta RAID, infatti per creare la stessa configurazione
 precedente, è possibile farlo con un comando:
\end_layout

\begin_layout Itemize
mkfs.btrfs -m raid1 -d raid1 /dev/sdd /dev/sde //crea un RAID 1 con le partizioni
 
\begin_inset Quotes eld
\end_inset

sdd
\begin_inset Quotes erd
\end_inset

 ed 
\begin_inset Quotes eld
\end_inset

sde
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Btrfs ha diversi vantaggi rispetto ad ext4 ed altri filesystem, il vantaggio
 principale è quello di supportare nativamente gli snapshot, quindi fare
 snapshot del sistema e calcolare la differenza tra due snapshot sono operazioni
 molto leggere su questo filesystem.
\end_layout

\begin_layout Subsection
Tuning delle prestazioni e configurazione delle impostazioni di dispositivi
 di memoria
\end_layout

\begin_layout Standard
Per effettuare un tuning delle prestazioni o accedere alle configurazioni
 dei dispositivi di memoria, possiamo utilizzare una coppia di programmi:
\end_layout

\begin_layout Itemize
hdparm (per dispositvi con controller ATA e derivati): in pratica la quasi
 totalità dei sistemi PC moderni
\end_layout

\begin_layout Itemize
sdparm (per dispositivi con controller SCSI): usati in contesto workstation/serv
er
\end_layout

\begin_layout Standard
Se usiamo un hard disk ATA (o derivato) ma che viene emulato con il driver
 SCSI, possiamo usare entrambi i comandi.
 Vediamo alcuni esempi di comandi:
\end_layout

\begin_layout Itemize
hdparm -I /dev/sda //mostra informazioni sull'hard drive
\end_layout

\begin_layout Itemize
hdparm -tT /dev/sda2 //effettua uno speed test sulla partizione sda2
\end_layout

\begin_layout Itemize
sdparm /dev/sda //mostra informazioni riguardo il controllore ATA/SCSI,
 ecc del device sda
\end_layout

\begin_layout Itemize
sdparm –get=WCE /dev/sda //controlla se la politica di write caching è abilitata
 sul device sda
\end_layout

\begin_layout Subsection
Criptare Partizioni
\end_layout

\begin_layout Standard
E' possibile criptare partizioni (o interi dispositvi di memoria) per aumentare
 la sicurezza attraverso LUKS (Linux Unified Key Setup) e cioè una specifica
 per la criptazione di dispositivi di memoria.
 E' doveroso criptare partizioni nel momento in cui vogliamo proteggere
 dei dati, dobbiamo considerare l'eventualità che la nostra macchina possa
 cadere nelle mani sbagliate o scenari simili.
 Per poter criptare una partizione, dobbiamo innanzitutto installare il
 pacchetto 
\begin_inset Quotes eld
\end_inset

cryptsetup
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Itemize
apt-get install cryptsetup //installa crypt-setup
\end_layout

\begin_layout Standard
Poi per criptare una determinata partizione, prendiamo come esempio /dev/sde1,
 eseguiamo:
\end_layout

\begin_layout Itemize
cryptsetup -v -y luksFormat /dev/sde1 //in questo caso indichiamo di voler
 criptare la partizione indicata, 
\begin_inset Quotes eld
\end_inset

-v
\begin_inset Quotes erd
\end_inset

 indica la modalità verbose, mentre 
\begin_inset Quotes eld
\end_inset

-y
\begin_inset Quotes erd
\end_inset

 serve a verificare la passphrase inserita
\end_layout

\begin_layout Standard
Una volta creata questa partizione criptata, dobbiamo assegnarle un file
 in /dev/mapper/ che rappresenti il dispositivo criptato, possiamo eseguire:
\end_layout

\begin_layout Itemize
cryptsetup luksOpen /dev/sde1 secure //dove indichiamo: l'intenzione di
 creare un device per la partizione con 
\begin_inset Quotes eld
\end_inset

luksOpen
\begin_inset Quotes erd
\end_inset

, la partizione criuptata con 
\begin_inset Quotes eld
\end_inset

/dev/sde1
\begin_inset Quotes erd
\end_inset

 e il nome da dare al device che potremo vedere successivamente in /dev/mapper
\begin_inset Quotes erd
\end_inset

 che in questo caso è 
\begin_inset Quotes eld
\end_inset

secure
\begin_inset Quotes erd
\end_inset

 ma può avere qualsiasi nome desiderato
\end_layout

\begin_layout Standard
possiamo verificare il corretto caricamento della partizione criptata attraverso
:
\end_layout

\begin_layout Itemize
ls -l /dev/mapper/secure //visualizza informazioni sulla partizione criptata,
 se è stata caricata in modo corretto
\end_layout

\begin_layout Standard
Per renderla leggibile, dobbiamo utilizzare un filesystem a nostra scelta,
 eseguiremo ad esempio:
\end_layout

\begin_layout Itemize
mkfs.ext4 /dev/mapper/secure //impone il filesystem ext4 sulla partizione
 criptata
\end_layout

\begin_layout Standard
ora possiamo montarla con:
\end_layout

\begin_layout Itemize
mount /dev/mapper/secure /secure //monta la partizione criptata nella directory
 /secure
\end_layout

\begin_layout Standard
Un file di configurazione molto utile è 
\begin_inset Quotes eld
\end_inset

/etc/crypttab
\begin_inset Quotes erd
\end_inset

, dove sono contenute istruzioni per il comando 
\begin_inset Quotes eld
\end_inset

cryptsetup
\begin_inset Quotes erd
\end_inset

.
 Un'altra soluzione è Ecryptfs, questo ci permette di creare una directory
 sola criptata anzichè dover formattare per criptare l'intero disco.
\end_layout

\begin_layout Subsection
Gestire dischi criptati con Bitlocker
\end_layout

\begin_layout Standard
Dato un disco criptato con Bitlocker (tipico software utilizzato su Windows),
 possiamo accedere utilizzando questi comandi:
\end_layout

\begin_layout Itemize
mkdir /mnt/tmp /mnt/disk //creo due directory per tenere il dislocker file
 e il disco montato
\end_layout

\begin_layout Itemize
dislocker -v -V /dev/sdb1 -uMiaPassword -- /mnt/tmp //monto il dislocker
 file, la partizione sdb da menzionare qui è quella che vogliamo attualmente
 montare, quindi potrebbe anche essere sdb2
\end_layout

\begin_layout Itemize
mount -o loop /mnt/tmp/dislocker-file /mnt/disk //monto il disco criptato,
 ora il disco è montato nella directory 
\begin_inset Quotes eld
\end_inset

/mnt/disk
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
una volta effettuate le operazioni potremo eseguire le seguenti operazioni
 per smontare il disco:
\end_layout

\begin_layout Itemize
cd //per non rimanere nella directory del disco montato
\end_layout

\begin_layout Itemize
umount /mnt/disk
\end_layout

\begin_layout Itemize
umount /mnt/tmp
\end_layout

\begin_layout Subsection
LVM
\end_layout

\begin_layout Standard
LVM sta per Logical Volume Management e costituisce un sistema molto flessibile
 per la gestione delle partizioni.
 Possiamo identificare tre elementi nella gestione organizzata secondo LVM:
\end_layout

\begin_layout Enumerate
Physical Volumes: I dispositivi fisici
\end_layout

\begin_layout Enumerate
Volume Groups: Raggruppamenti di volumi fisici
\end_layout

\begin_layout Enumerate
Logical Volumes: I dispositivi virtuali che vengono visti dal sistema
\end_layout

\begin_layout Standard
Quando creiamo una partizione LVM, il tipo da associare (via fdisk ad esempio)
 è 
\begin_inset Quotes eld
\end_inset

8e
\begin_inset Quotes erd
\end_inset

, una volta preparata la partizione, supponiamo in questo caso che la partizione
 creata sia 
\begin_inset Quotes eld
\end_inset

sdb1
\begin_inset Quotes erd
\end_inset

, allora dobbiamo eseguire:
\end_layout

\begin_layout Itemize
pvcreate /dev/sdb1 //segna un dispositivo come 
\begin_inset Quotes eld
\end_inset

volume fisico
\begin_inset Quotes erd
\end_inset

, infatti pvcreate penso stia per Physical Volume Create, nel senso che
 dobbiamo indicare ad LVM quali sono le partizioni fisiche che vogliamo
 utilizzare
\end_layout

\begin_layout Itemize
pvscan //esegue uno scan dei physical volume sul sistema
\end_layout

\begin_layout Itemize
vgcreate vg1 /dev/sdb1 //crea un Volume Group chiamato vg1 e composto dalla
 partizione sdb1
\end_layout

\begin_layout Standard
ora possiamo eseguire:
\end_layout

\begin_layout Itemize
vgscan //visualizza il nome dei volume group presenti sul sistema
\end_layout

\begin_layout Itemize
vgs //mostra un resoconto dei volume group con dimensioni e diverse proprietà
 relative
\end_layout

\begin_layout Itemize
lvs //mostra informazioni sui volumi logici
\end_layout

\begin_layout Standard
Ora possiamo creare una nuova partizione logica attraverso:
\end_layout

\begin_layout Itemize
lvcreate -n data_lv -L 750m vg1 //crea una partizione che chiamiamo attraverso
 il flag 
\begin_inset Quotes eld
\end_inset

-n
\begin_inset Quotes erd
\end_inset

 
\begin_inset Quotes eld
\end_inset

data_lv
\begin_inset Quotes erd
\end_inset

, la dimensione viene specificata attraverso il flag 
\begin_inset Quotes eld
\end_inset

-L
\begin_inset Quotes erd
\end_inset

 ed è di 750MB, inoltre viene indicato il volume group in cui creare la
 partizione
\end_layout

\begin_layout Standard
Ora possiamo formattare la nostra partizione, tenendo a mente che i volumi
 logici di LVM sono identificati da device file contenuti in /dev/volumeGroupNam
e/ dove 
\begin_inset Quotes eld
\end_inset

volumeGroupName
\begin_inset Quotes erd
\end_inset

 rappresenta proprio il nome del volume group di appartenenza, per formattare
 allora eseguiremo:
\end_layout

\begin_layout Itemize
mkfs.ext4 /dev/vg1/data_lv //formatta la partizione logica con filesystem
 ext4
\end_layout

\begin_layout Standard
e la montiamo con:
\end_layout

\begin_layout Itemize
mount /dev/vg1/data_lv /data //monta la partizione logica
\end_layout

\begin_layout Subsubsection
Estendere una partizione logica
\end_layout

\begin_layout Standard
Ora immaginiamo di avere quasi riempito il dispositivo /dev/sdb1 citato
 in precedenza che aveva partizione logica /dev/vg1/data_lv ed era all'interno
 del volume group chiamato 
\begin_inset Quotes eld
\end_inset

vg1
\begin_inset Quotes erd
\end_inset

, possiamo estenderlo, immaginiamo di aggiungere una partizione mappata
 in /dev/sdc1, allora ci basterà identificarla come utilizzabile da LVM
 come volume fisico, aggiungerlo allo stesso volume group di data_lv e aggiunger
e spazio a data_lv che verrà in automatico preso dalle partizioni all'interno
 del volume group, quindi faremo:
\end_layout

\begin_layout Itemize
pvcreate /dev/sdc1 //segna la partizione sdc1 come volume fisico
\end_layout

\begin_layout Itemize
vgextend vg1 /dev/sdc1 //aggiunge al volume group 
\begin_inset Quotes eld
\end_inset

vg1
\begin_inset Quotes erd
\end_inset

 il volume fisico 
\begin_inset Quotes eld
\end_inset

/dev/sdc1
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
lvextend -L +1000m /dev/vg1/data_lv //aggiunge 1000MB disponibili al volume
 logico chiamato 
\begin_inset Quotes eld
\end_inset

data_lv
\begin_inset Quotes erd
\end_inset

 all'interno del volume group 
\begin_inset Quotes eld
\end_inset

vg1
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
possiamo ora ridimensionare la partizione 
\begin_inset Quotes eld
\end_inset

data_lv
\begin_inset Quotes erd
\end_inset

 attraverso il comando 
\begin_inset Quotes eld
\end_inset

resize2fs
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Itemize
resize2fs /dev/vg1/data_lv //ridimensiona la partizione data_lv per occupare
 tutto lo spazio disponibile
\end_layout

\begin_layout Subsubsection
Backup con LVM
\end_layout

\begin_layout Standard
Il backup è una procedura molto flessibile utilizzando il sistema LVM, infatti
 è possibile creare dei veri e propri 
\begin_inset Quotes eld
\end_inset

snapshot
\begin_inset Quotes erd
\end_inset

 cioè stati del volume logico in un determinato istante di tempo.
 Lo snapshot deve costituire un vero e proprio logical volume all'interno
 dello stesso volume group della logical volume di cui vogliamo effettuare
 il backup, ma questo avverrà in automatico in quanto ci basta solo indicare
 la logical volume di cui vogliamo effettuare il backup.
 Possiamo eseguire:
\end_layout

\begin_layout Itemize
lvcreate -L 200m -s -n backup /dev/vg1/data_lv //dove viene creato un logical
 volume di dimensione 
\begin_inset Quotes eld
\end_inset

-L
\begin_inset Quotes erd
\end_inset

 200MB, con nome 
\begin_inset Quotes eld
\end_inset

-n
\begin_inset Quotes erd
\end_inset

 
\begin_inset Quotes eld
\end_inset

backup
\begin_inset Quotes erd
\end_inset

, e indichiamo che uno snapshot attraverso il flag 
\begin_inset Quotes eld
\end_inset

-s
\begin_inset Quotes erd
\end_inset

, in questo modo ci basterà indicare solo la partizione che nel nostro caso
 è 
\begin_inset Quotes eld
\end_inset

/dev/vg1/data_lv, i 200MB vengono sottratti al logical volume di cui vogliamo
 effettuare il backup
\end_layout

\begin_layout Itemize
mkdir /mnt/backup
\end_layout

\begin_layout Itemize
mount /dev/vg1/backup /mnt/backup
\end_layout

\begin_layout Itemize
tar -cf /tmp/backup.tar /mnt/backup
\end_layout

\begin_layout Itemize
umount /mnt/backup
\end_layout

\begin_layout Itemize
lvremove /dev/vg1/backup //rimuove il logical volume utilizzato momentaneamente
 per il backup
\end_layout

\begin_layout Subsubsection
Altre utility di LVM
\end_layout

\begin_layout Standard
Vediamo ora altre utility di LVM:
\end_layout

\begin_layout Itemize
vgchange –help //mostra molte opzioni che ci permettono di cambiare impostazioni
/proprietà dei volume group
\end_layout

\begin_layout Itemize
vgchange -a y vg1 //rende disponibile 
\begin_inset Quotes eld
\end_inset

-a y
\begin_inset Quotes erd
\end_inset

 (a sta per available) il volume group chiamato vg1 (questo avviene di default
 alla creazione)
\end_layout

\begin_layout Itemize
vgchange -a n vg1 //rende non disponibile 
\begin_inset Quotes eld
\end_inset

-a n
\begin_inset Quotes erd
\end_inset

 (a sta per available) il volume group chiamato vg1
\end_layout

\begin_layout Itemize
lvscan //esegue uno scan e visualizza in output i logical volume presenti
 sul sistema
\end_layout

\begin_layout Itemize
vgscan //esegue uno scan e visualizza in output i volume group presenti
 sul sistema
\end_layout

\begin_layout Itemize
pvscan //esegue uno scan e visualizza in output i physical volume presenti
 sul sistema
\end_layout

\begin_layout Section
Gestione del server grafico X
\end_layout

\begin_layout Standard
Many Linux and Unixoid users (Unix and Unix-like systems) have heard of
 window managers, window decorators, desktop environments, and such.
 But what exactly are these and how do they relate to each other? I hope
 to clarify some of these topics and explain how it all works.
\end_layout

\begin_layout Paragraph
First of all, a Graphical User Interface (GUI) 
\end_layout

\begin_layout Standard
is an interface that allows users to interact with the system in a visual
 manner.
 GUIs typically have icons, windows, or graphics of some kind.
 An alternative to GUIs are command-lines which may also be called CLIs
 (Command-Line Interfaces) or CUIs (Console USer Interfaces).
 An example of this is DOS, FreeDOS, Bash, many server distros, etc.
 Basically, with a CLI, users interact with the machine through text.
 Users type a command and the machine performs the action and provides text
 as the output.
 A TUI (Text User Interface) is a step up from CLIs.
 TUIs are still text-based, but the screen is more ornamented and organized.
 The Ncurses interface is an example of a TUI.
 Most BIOS systems use a TUI interface (gray background and other coloring
 with menus).
 More advanced TUIs may have a cursor.
 The "dialog" command used to make interfaces for scripts is an example
 of an advanced TUI.
\end_layout

\begin_layout Standard
The core of most GUIs is a windowing system (sometimes called a display
 server).
 Most windowing systems use the WIMP structure (Windows, Icons, Menus, Pointer).
 X11 is a protocol used by the common windowing system called Xorg used
 on Linux systems.
 Xorg, like other windowing systems, allows the movement of windows and
 input interactions (such as the mouse and keyboard).
 Windowing systems provide the basic framework for other parts of the GUI.
 Windowing systems do not control the appearance of the GUI.
 Rather, the windowing system offers the core functionality.
\end_layout

\begin_layout Paragraph
Xlib 
\end_layout

\begin_layout Standard
is a C-programming library for interacting with display servers using the
 X11 protocol (X Window System Version 11).
 Not all graphical components above the display server are compatible with
 the display server itself.
\end_layout

\begin_layout Standard
The part of the GUI that controls the way windows appear is called the window
 manager.
 Window managers manage the size and placement of windows.
 Window managers also draw and own the close, maximize, minimize, etc.
 buttons and the scroll bars and menus (like the "File" menu) commonly seen
 on many windows.
 In other words, window managers control the frames that surround applications
 and the placement of these frames.
 The term "window decoration" refers to the usable part of the window frame
 like the close, minimize, etc.
 buttons, scroll bars, etc.
 However, sometimes the window manager will allow the application to control
 the appearance of the window.
 To understand this, think about the "complete themes” in Firefox that change
 the appearance of the windows and scroll bars.
 Not all window managers are compatible with the different display-managers/wind
owing-systems.
 Examples of window managers include Mutter, Metacity, KWin, twm, and IceWM.
\end_layout

\begin_layout Paragraph
A widget-toolkit
\end_layout

\begin_layout Standard
is a set of software or a library that works with the window manager to
 design the window's appearance.
 For example, the GTK toolkit defines how a window should appear.
 Then, a window manager draws and manages the window.
 When users customize the theme of their desktop, they are choosing which
 GTK design to use.
 To help clarify, toolkits (like Qt and GTK) are programming frameworks
 that specify the appearance of a theme.
 Different themes are basically different sets of code written in GTK, Qt,
 or some other widget toolkit.
 When a programmer designs a program, they may add some code that interfaces
 with a widget library (like GTK or Qt) to hard-code how a window appears.
 Think about your desktop and notice how you may have a few programs that
 look like an entirely different theme compared to your other applications.
 Such "odd" applications may have their appearance hard-coded.
 Examples of widget toolkits include SDL, Qt, GTK, AWT, and Motif.
\end_layout

\begin_layout Standard
Notice that some of the windows have an appearance that differs from the
 others (Clementine is more gray and box-like wile the calculator has rounded
 buttons and a lighter color).
\end_layout

\begin_layout Paragraph
A display manager 
\end_layout

\begin_layout Standard
is the "login screen".
 LightDM, KDM (KDE display manager), GDM (GNOME Display Manager), etc.
 are pieces of software that manage the appearance of the login screen.
\end_layout

\begin_layout Paragraph
A desktop 
\end_layout

\begin_layout Standard
is the "invisible window" that allows users to set a wallpaper/background
 and place "desktop icons".
 A virtual desktop refers to a desktop that is on the outside of the screen.
 Think about "workspaces" or "workspace switchers".
 You see your desktop, but there is more of it than what you see on the
 physical screen.
\end_layout

\begin_layout Paragraph
A dock, launcher, launch bar, or taskbar
\end_layout

\begin_layout Standard
is a graphical element that may be its own entity or a component of another
 graphical software.
 In Ubuntu, the launcher on the side and the bar at the top are components
 of Unity.
 Cairo-Dock is an example of a dock that is its own entity.
 Their purpose is to give users access to file and applications.
\end_layout

\begin_layout Paragraph
Screensavers 
\end_layout

\begin_layout Standard
are special programs that protect the screen from phosphor burn-in on CRT
 (tube-based monitors) and plasma monitors.
 However, they are also used for entertainment and security purposes.
 Screensavers can be set to activate when the workstation has not seen any
 activity from the user.
 Screensavers would then require a password to allows users to see the desktop
 and interact with the machine.
 Screensavers may be simple like a solid color or they can be graphics intensive
 like a video game.
\end_layout

\begin_layout Paragraph
A Desktop Environment 
\end_layout

\begin_layout Standard
is a collection of software that provides a standard look and feel.
 For example, the KDE Plasma Desktop uses the X11 windowing system, the
 KWin window manager, the Qt widget, the KDE display manager, and the KDE
 Software Compilation (the many KDE applications such as Kate, Konsole,
 Phonon, and the many K* applications).
\end_layout

\begin_layout Standard
In summary, a desktop environment is the collection or a bundled package
 of various GUI components.
 Each component performs some function in producing a graphical way of interacti
ng with your machine.
 The windowing system (think about Xorg) is the lowest level portion of
 the GUI that controls the input interaction (mouse and keyboard).
 The window manager puts applications in designated portions of the screen
 called "windows".
 Window managers provide a way to change the window size.
 Users may also use the window manager to close an application.
 The widget toolkits provide a set (predefined) appearance that the window
 manager should draw.
 Such toolkits tell the window manager where to place the close, maximize,
 etc.
 buttons and how they should appear.
 Menus are also drawn by window managers after a toolkit declares how the
 menu should appear.
 Display managers a graphical login interfaces that allows users to login
 and choose the environment to load (if the user has more than one environment
 installed).
 Docks and launchers allow users to access certain application and files.
 The desktop is an "invisible" background window that appears to be behind
 (or at the bottom - below) all of your other windows and docks.
\end_layout

\begin_layout Standard
All these pieces of software work together to create the applications we
 see on the screen.
\end_layout

\begin_layout Paragraph
A display server or window system
\end_layout

\begin_layout Standard
The display server controls and manages the low-level features to help integrate
 the parts of the GUI.
 For instance, display servers manage the mouse and help match the mouse
 movements with the cursor and GUI events caused by the cursor.
 The display server also provides various protocols and communicates with
 the kernel directly.
 There are different sets of display server protocols and different display
 servers that implement a specific protocol.
\end_layout

\begin_layout Standard
NOTE: Display servers do not draw anything.
 They just manage the interface.
 Libraries, toolkits, and other software perform the drawing.
\end_layout

\begin_layout Standard
L'X Window System (noto in gergo come X Window, X11 o semplicemente come
 X), in informatica, è un gestore grafico molto diffuso, standard de facto
 per molti sistemi Unix-like (Linux e FreeBSD compresi).
 L'implementazione ufficiale open source di X è X.Org (o più semplicemente
 XOrg), ed il suo sviluppo è curato dalla fondazione X.Org Foundation.
\end_layout

\begin_layout Standard
In passato era necessaria la configurazione di un file di configurazione
 Xorg, questo file conteneva diverse sezioni per la configurazione del monitor,
 refresh rate, opzioni video eccetera, oggi questo file di configurazione
 non è più richiesto, in quanto i driver che installiamo della scheda video
 si occupano di configurare il tutto per noi.
 Nel caso volessimo visualizzare il file di configurazione che viene generato
 nel momento dell'installazione e della configurazione di xorg, possiamo
 farlo con:
\end_layout

\begin_layout Itemize
cat /etc/X11/xorg.conf.failsafe //visualizza il file di configurazione di
 Xorg che viene generato durante l'installazione e la configurazione di
 xorg, ma non è presente su tutte le distribuzioni
\end_layout

\begin_layout Standard
Un comando utile fin da subito per uccidere tutti i processi del server
 grafico e quindi terminarlo è:
\end_layout

\begin_layout Itemize
pkill X //uccide tutti i processi relativi ad X
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
un'alternativa potrebbe essere uccidere il display manager, in quanto il
 display manager è il processo padre del processo relativo al Desktop Environmen
t o al Window Manager
\end_layout

\end_deeper
\begin_layout Standard
possiamo generare un file di configurazione di xorg, assicurandoci prima
 che Xorg non sia in esecuzione, (o uccidendo tutti i processi relativi
 a Xorg attraverso il comando precedentemente citato) attraverso:
\end_layout

\begin_layout Itemize
cd /etc/X11 && Xorg -configure //genera un file di configurazione per Xorg
\end_layout

\begin_layout Standard
per testare il nuovo file di configurazione possiamo effettuare un:
\end_layout

\begin_layout Itemize
X -config -retro /directory/nuovoFileConfig //imposta come file di configurazion
e per X il file 
\begin_inset Quotes eld
\end_inset

nuovoFileConfig
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
startx //per avviare il server grafico col nuovo file di configurazione
\end_layout

\begin_layout Itemize
startx /path/to/WM/or/DE //posso usare questo per lanciare un window manager
 o desktop environment per una sessione temporanea (comodo per provare ambienti
 o configurazioni temporanee)
\end_layout

\begin_layout Standard
Se volessi runnare altri desktop environment allora possiamo eseguire all'intern
o di un altro tty il comando:
\end_layout

\begin_layout Itemize
startx – :2 //questo inizia una sessione di Xorg sul display 2, il display
 2 solitamente è mappato al tasto f9 ma non sempre, possiamo cioè accederci
 con 
\begin_inset Quotes eld
\end_inset

Ctrl+alt+f9
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
startx /usr/bin/gdm – :2 //avvia gdm sul display 2
\end_layout

\begin_layout Standard
Ricorda che:
\end_layout

\begin_layout Itemize
For a Linux computer with 6 allowed shell sessions, the virtual displays
 are numbered 0 to 5 
\end_layout

\begin_layout Itemize
Shell sessions are mapped to function keys F1 through F6 
\end_layout

\begin_layout Itemize
Virtual displays are mapped to function keys F7 through F12
\end_layout

\begin_layout Standard
I file di log, possono essere visionati al percorso 
\begin_inset Quotes eld
\end_inset

/var/log/Xorg.?.log
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Paragraph
Problemi Incontrati
\end_layout

\begin_layout Standard
Nel caso un utente non dovesse essere abilitato ad avviare startx, con messaggi
 tipo 
\begin_inset Quotes eld
\end_inset

User is not authorized to run X
\begin_inset Quotes erd
\end_inset

, dobbiamo andare a scrivere nel file 
\begin_inset Quotes eld
\end_inset

/etc/X11/Xwrapper.config
\begin_inset Quotes erd
\end_inset

 ed inserire nella voce 
\begin_inset Quotes eld
\end_inset

allowed_users
\begin_inset Quotes erd
\end_inset

 la stringa 
\begin_inset Quotes eld
\end_inset

anybody
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Paragraph
Troubleshooting con X
\end_layout

\begin_layout Standard
In genere per fare troubleshooting sugli errori generati da X, possiamo
 ispezionare i seguenti file: ~/.xsession-errors, /var/log/Xorg.*/var/log/messages.
\end_layout

\begin_layout Subsection
Copy & Paste (ossia copia e incolla)
\end_layout

\begin_layout Standard
Xorg ha tre clipboard, in cui vengono memorizzati i copia incolla, una utility
 molte efficace è 
\begin_inset Quotes eld
\end_inset

xclip
\begin_inset Quotes erd
\end_inset

, questa ci permette di copiare o incollare dati da terminale, ad esempio:
\end_layout

\begin_layout Itemize
dmesg | xclip -selection clipboard //copia nella clipboard di X l'output
 di dmesg, ora possiamo incollarlo in qualsiasi altro programma grafico
 con 
\begin_inset Quotes eld
\end_inset

ctrl+v
\begin_inset Quotes erd
\end_inset

 o tasto destro del mouse e 
\begin_inset Quotes eld
\end_inset

incolla
\begin_inset Quotes erd
\end_inset

, potrebbe essere utile creare un alias per fare in modo che automaticamente
 quando si esegue xclip si intende 
\begin_inset Quotes eld
\end_inset

xclip -selection clipboard
\begin_inset Quotes erd
\end_inset

, in quanto a mio parere è l'opzione più utilizzata quando si utilizzata
 xclip
\end_layout

\begin_layout Itemize
xclip -selection clipboard nomeFile.log //copia nella clipboard di X il contenuto
 del file menzionato
\end_layout

\begin_layout Standard
Xclip permette anche l'utilizzo di display diversi.
\end_layout

\begin_layout Standard
The ICCCM (Inter-Client Communication Conventions Manual) standard defines
 three "selections": PRIMARY, SECONDARY, and CLIPBOARD.
 Despite the naming, all three are basically "clipboards".
 Rather than the old "cut buffers" system where arbitrary applications could
 modify data stored in the cut buffers, only one application may control
 or "own" a selection at one time.
 This prevents inconsistencies in the operation of the selections.
 However, in some cases, this can produce strange outcomes, such as a bidirectio
nal shared clipboard with Windows (which uses a single-clipboard system)
 in a virtual machine.
\end_layout

\begin_layout Standard
Of the three selections, users should only be concerned with PRIMARY and
 CLIPBOARD.
 SECONDARY is only used inconsistently and was intended as an alternate
 to PRIMARY.
 Different applications may treat PRIMARY and CLIPBOARD differently; however,
 there is a degree of consensus that CLIPBOARD should be used for Windows-style
 clipboard operations, while PRIMARY should exist as a "quick" option, where
 text can be selected using the mouse or keyboard, then pasted using the
 middle mouse button (or some emulation of it).
 This can cause confusion and, in some cases, inconsistent or undesirable
 results from rogue applications.
 
\end_layout

\begin_layout Standard
In pratica il buffer primario è associato ai copia incolla che eseguiamo
 con la rotellina del mouse, mentre il buffer clipboard, quelli che generalmente
 eseguiamo con 
\begin_inset Quotes eld
\end_inset

ctrl+c
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

ctrl+v
\begin_inset Quotes erd
\end_inset

, o comunque quando non incolliamo con la rotellina del mouse.
\end_layout

\begin_layout Standard
Di default 
\begin_inset Quotes eld
\end_inset

xclip
\begin_inset Quotes erd
\end_inset

 copia attraverso il buffer primario, quindi per incollare dobbiamo premere
 la rotellina del mouse.
\end_layout

\begin_layout Subsection
Xhost
\end_layout

\begin_layout Standard
Il programma xhost è molto utile per poter avviare programmi da remoto,
 può lavorare in due modalità:
\end_layout

\begin_layout Itemize
access control enabled '-' //solo gli utenti contenuti all'interno di una
 lista, possono usarlo, l'accesso a xhost non è garantito a tutti
\end_layout

\begin_layout Itemize
access control disabled '+' //tutti gli utenti possono usarlo, l'accesso
 a xhost è garantito a tutti
\end_layout

\begin_layout Itemize
xhost + 192.168.1.101 //serve a garantire l'accesso a xhost solo ad uno specifico
 indirizzo
\end_layout

\begin_layout Standard
Lanciando solo:
\end_layout

\begin_layout Itemize
xhost //mostra la configurazione attuale per l'accesso a xhost
\end_layout

\begin_layout Standard
Un'altra informazione utile è visualizzare la variabile d'ambiente $DISPLAY
 con:
\end_layout

\begin_layout Itemize
set | grep DISPLAY //visualizza il valore della variabile display
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
l'output di questo comando sarà nella forma DISPLAY=:numeroDisplay.numeroSchermo
\end_layout

\end_deeper
\begin_layout Standard
il nome del display può anche essere visionato con:
\end_layout

\begin_layout Itemize
xdpyinfo | grep display
\end_layout

\begin_layout Standard
Quindi avendo due sistemi A e B, se su A impostiamo come variabile d'ambiente
 DISPLAY con l'indirizzo IP di B e un display esistente su B, possiamo rediriger
e l'output di X di A su B, quindi su A effettueremo:
\end_layout

\begin_layout Itemize
export DISPLAY=192.168.1.87:0.0 //imposta la variabile d'ambiente DISPLAY in
 modo che l'output grafico di X venga rediretto su B al display 0 dello
 schermo 0.
\end_layout

\begin_layout Standard
dopo aver impostato la variabile d'ambiente DISPLAY possiamo effettuare
 un test, lanciando un'applicazione grafica come:
\end_layout

\begin_layout Itemize
xterm //avvia l'applicazione xterm
\end_layout

\begin_layout Standard
Xhost risulta molto utile nel momento in cui vogliamo che un server si occupi
 del carico grafico, mentre su una macchina remota vengano visualizzati
 solo i risultati all'interno del server grafico.
\end_layout

\begin_layout Subsection
Xnest
\end_layout

\begin_layout Standard
E' possibile avviare desktop environment o window manager annidati attraverso
 Xnest.
 Oppure con un wrapper che semplifica queste operazioni e cioè Xephyr.
\end_layout

\begin_layout Subsection
Xwininfo
\end_layout

\begin_layout Standard
Il programma xwininfo è molto utile per reperire informazioni sulle finestre
 attive su Xorg.
 Vediamo subito alcuni esempi applicativi:
\end_layout

\begin_layout Itemize
xwininfo //ci mostra informazioni sulla finestra su cui clickiamo dopo aver
 lanciato il comando
\end_layout

\begin_layout Itemize
xwininfo idFinestra //ci mostra informazioni sulla finestra con l'id specificato
\end_layout

\begin_layout Itemize
xwininfo titoloFinestra //ci mostra informazioni sulla finestra col titolo
 specificato
\end_layout

\begin_layout Itemize
xwininfo -root //mostra informazioni sulla finestra 
\begin_inset Quotes eld
\end_inset

root
\begin_inset Quotes erd
\end_inset

 cioè quella da cui derivano tutte le altre finestra, quindi mostreremo
 a schermo informazioni come risoluzione e geometrie dell'intero desktop
\end_layout

\begin_layout Itemize
xwininfo -events //mostra gli eventi di cui è in ascolta la finestra su
 cui clickeremo
\end_layout

\begin_layout Itemize
xwininfo -wm //mostra informazioni relative al process ID dell'applicazione
 che ha lanciato quella finestra, il display su cui è attiva la finestra
 eccetera
\end_layout

\begin_layout Itemize
xwininfo -root -children //mostra le informazioni di tutti i componenti
 X attivi con padre e figli, ma è poco leggibile
\end_layout

\begin_layout Itemize
xwininfo -root -tree //mostra le stesse informazioni del comando precedente
 ma in forma più leggibile
\end_layout

\begin_layout Itemize
xwininfo -root -children -all //mostra tutte le informazioni possibili su
 tutti i componenti di X
\end_layout

\begin_layout Standard
N.B.: Gli ultimi comandi sono utili nel caso di programmazione di Desktop
 ENvironment, nel momento in cui facciamo riferimento a elementi di X.
\end_layout

\begin_layout Standard
Altro comando utile per reperire informazioni su oggetti, font, finestre
 o display è:
\end_layout

\begin_layout Itemize
xprop //dopo averlo avviato dovremo selezionare la finestra d'interesse
\end_layout

\begin_layout Itemize
xprop | grep -i pid //mi fornisce il PID della finestra, utile se abbiamo
 ad esempio più istanze di un programma avviato e vogliamo chiuderne uno
 nello specifico senza influire sugli altri
\end_layout

\begin_layout Standard
un'altro comando utilissimo per vedere i nomi dei comandi delle applicazioni
 che abbiamo in running in X è:
\end_layout

\begin_layout Itemize
xlsclients //visualizza il nome dei comandi delle applicazioni grafiche
 in running su X
\end_layout

\begin_layout Itemize
xlsclients -l //è più dettagliato
\end_layout

\begin_layout Standard
un'altro utile tool per ottenere informazioni sulle finestre è 
\begin_inset Quotes eld
\end_inset

wmctrl
\begin_inset Quotes erd
\end_inset

, guardare il man per utili esempi di utilizzo.
\end_layout

\begin_layout Standard
Possiamo dare focus a una finestra che non vediamo più con:
\end_layout

\begin_layout Itemize
xdotool windowfocus 0x1a00ad2 //dove l'id è preso da xlsclients
\end_layout

\begin_layout Subsection
Xrefresh
\end_layout

\begin_layout Standard
E' un comodo comando per fare il refresh del server X, nel caso in cui una
 o più parti devono essere ridisegnate
\end_layout

\begin_layout Subsection
Xdpyinfo
\end_layout

\begin_layout Standard
Il programma xdpyinfo fornisce informazioni sul display manager; vediamo
 subito alcuni esempi:
\end_layout

\begin_layout Itemize
xdpyinfo | grep display //fornisce informazioni sul display
\end_layout

\begin_layout Itemize
xdpyinfo //fornisce molte informazioni sul display 
\end_layout

\begin_layout Itemize
xdpyinfo | grep extensions //fornisce il numero di estensioni installate
 per il display
\end_layout

\begin_layout Itemize
xdpyinfo -queryExtensions //fornisce informazioni tecniche sulle estensioni
 caricate, utili per i programmatori
\end_layout

\begin_layout Subsection
Xinput
\end_layout

\begin_layout Standard
Questo comando è utile per capire le periferiche di input a disposizione,
 come ad esempio mouse eccetera, le loro features, e le eventuali configurazioni
, possiamo eseguire:
\end_layout

\begin_layout Itemize
xinput //mostra la lista delle periferiche di input per il server X
\end_layout

\begin_layout Itemize
xinput –disable 10 //disabilita la periferica con ID=10
\end_layout

\begin_layout Itemize
xinput –enable 9 //abilita la periferica con ID=9
\end_layout

\begin_layout Itemize
xinput --list --short //mostra con una lista concisa tutte le periferiche
 di input
\end_layout

\begin_layout Itemize
xinput --list-props "Logitech USB-PS/2 Optical Mouse" //mostra le proprietà
 di una delle periferiche (indicata tra doppi apici) mostrata dal comando
 
\begin_inset Quotes eld
\end_inset

xinput --list --short
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
xinput --set-prop "SynPS/2 Synaptics TouchPad" "Device Accel Constant Decelerati
on" 1.5 //imposta il parametro 
\begin_inset Quotes eld
\end_inset

Device Accel Constant Deceleration
\begin_inset Quotes erd
\end_inset

 del device "SynPS/2 Synaptics TouchPad" al valore di 
\begin_inset Quotes eld
\end_inset

1.5
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
xinput --set-prop "Logitech USB-PS/2 Optical Mouse" "libinput Accel Speed"
 -0.6 //imposta il parametro 
\begin_inset Quotes eld
\end_inset

libinput Accel Speed
\begin_inset Quotes erd
\end_inset

 del device "Logitech USB-PS/2 Optical Mouse" al valore di 
\begin_inset Quotes eld
\end_inset

-0.6
\begin_inset Quotes erd
\end_inset

, in questo caso un valore negativo riduce l'accelerazione e velocità del
 mouse.
\end_layout

\begin_layout Subsection
xwd
\end_layout

\begin_layout Standard
Il programma xwd (X Window Dump) è un utile tool per effettuare screenshot
 dello schermo, possiamo avviarlo con:
\end_layout

\begin_layout Itemize
xwd //attenzione in questo caso il comando è inutile, in quanto una volta
 selezionata la finestra, verrà stampata l'immagine sull stdout, con caratteri
 incomprensibili
\end_layout

\begin_layout Standard
invece modi utili per utilizzare questa utility sono:
\end_layout

\begin_layout Itemize
xwd > myshot.xwd //stampa l'immagine in un file chiamato myshot.xwd
\end_layout

\begin_layout Itemize
xwd -out myshot.xwd //stampa l'immagine in un file chiamato myshot.xwd
\end_layout

\begin_layout Itemize
xwd -frame -out myshot.xwd //stampa l'immagine, mostrando anche il frame
 della finestra
\end_layout

\begin_layout Itemize
xwd -root -out myshot.xwd //esegue uno screenshot dell'intero desktop
\end_layout

\begin_layout Standard
per visualizzare le immagini possiamo utilizzare 
\begin_inset Quotes eld
\end_inset

xwud
\begin_inset Quotes erd
\end_inset

, quindi eseguiamo:
\end_layout

\begin_layout Itemize
xwud -in screenshot.xwd //visualizza l'immagine .xwd
\end_layout

\begin_layout Standard
se abbiamo installato imagemagick, possiamo anche convertirla in un altro
 formato ad esempio con:
\end_layout

\begin_layout Itemize
convert shot.xwd shot.jpg //converte l'immagine .xwd in .jpg
\end_layout

\begin_layout Subsection
Xrandr
\end_layout

\begin_layout Standard
RandR ("resize and rotate") is a communications protocol written as an extension
 to the X11[2] and Wayland[3] protocols for display servers.
 Both XRandR and WRandR provide the ability to resize, rotate and reflect
 the root window of a screen.
 RandR is also responsible for setting the screen refresh rate.
 The program xrandr is a primitive command line interface to RandR extension
 used to manage monitor configurations, let's see some examples:
\end_layout

\begin_layout Itemize
xrandr //shows the actual configuration
\end_layout

\begin_layout Itemize
xrandr –output VGA1 –off //turns off the VGA1 interface, keep in mind that
 the available displays are shown when 
\begin_inset Quotes eld
\end_inset

xrandr
\begin_inset Quotes erd
\end_inset

 alone is executed
\end_layout

\begin_layout Itemize
xrandr –output VGA1 –auto –left-of eDP1 //in this case VGA1 is set with
 the maximum resolution automatically detected 
\begin_inset Quotes eld
\end_inset

–auto
\begin_inset Quotes erd
\end_inset

, and on the left of the interface eDP1, notice that we can specify multiple
 configurations of various monitor interface, we just have to keep in mind
 the structure of the xrandr command
\end_layout

\begin_layout Itemize
xrandr –output DFP1 –mode 1024x768 //imposta la risoluzione indicata per
 il monitor indicato
\end_layout

\begin_layout Standard
the structure of the xrandr command is usually 
\begin_inset Quotes eld
\end_inset

xrandr –output <monitorInterface> –option1 <value> –option2 <value> ...
 ...
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Let's see other examples:
\end_layout

\begin_layout Itemize
xrandr –output LVDS –auto –rotate normal –pos 0x0 –output VGA –auto –rotate
 left –right-of LVDS //Sets an output called LVDS to its preferred mode,
 and on its right put an output called VGA to preferred mode of a screen
 which has been physically rotated clockwise
\end_layout

\begin_layout Itemize
xrandr –output HDMI1 –off –output LVDS1 –primary –mode 1366x768 –pos 0x0
 –rotate normal –output VIRTUAL1 –off –output DP1 –off –output VGA1 –mode
 1280x1024 –pos 1366x0 –rotate normal //this is a complete setup of all
 the interfaces, notice the 
\begin_inset Quotes eld
\end_inset

–primary
\begin_inset Quotes erd
\end_inset

 option is used to set the LVDS1 interface as primary
\end_layout

\begin_layout Itemize
xrandr –output LVDS –mode 1280x800 –rate 75 //imposta l'output di LVDS alla
 risoluzione e alla frequenza selezionata
\end_layout

\begin_layout Standard
queste impostazioni non saranno permanenti ma possono essere rese permanenti
 attraverso uno script che parte all'avvio.
\end_layout

\begin_layout Standard
Inoltre xrandr può gestire le schede video esterne, ad esempio in alcuni
 portatili potremo non vedere interfacce HDMI, o VGA, questo è perchè in
 alcune configurazioni Hardware, alcune interfacce tipo VGA sono collegate
 ad una scheda video, mentre altre tipo HDMI, all'altra scheda video.
 Vediamo un esempio, nel caso d'esempio supponiamo che la porta hdmi sia
 collegata ad una scheda video mentre la porta vga ad un'altra scheda video,
 allora possiamo eseguire:
\end_layout

\begin_layout Itemize
xrandr –listproviders //mi mostra su quanti e su quali dispositivi video
 xrandr può agire, il primo a comparire sarà quello in utilizzo attualmente,
 potremo ad esempio visionare una lista tipo 
\begin_inset Quotes eld
\end_inset

0: Intel 1:nouveau
\begin_inset Quotes erd
\end_inset

, questo è anche l'ordine di priorità che viene dato ai dispositivi di uscita
\end_layout

\begin_layout Standard
ora possiamo cambiare l'ordine eseguendo:
\end_layout

\begin_layout Standard
prima deve essere attiva la scheda video nouveau:
\end_layout

\begin_layout Itemize
optirun ls //ls è un esempio, qualsiasi comando va bene, serve solo ad accendere
 la scheda video
\end_layout

\begin_layout Itemize
xrandr –setprovideroutputsource nouveau Intel //impone un nuovo ordine ai
 moduli video, ora nouveau è impostato per gestire gli output video come
 modulo primario
\end_layout

\begin_layout Standard
NOTA BENE: Un caso pratico e molto comune in cui questo può essere necessario
 è su laptop, in cui infatti solitamente esistono due schede video, una
 integrata ed un'altra esterna, in questo caso, dobbiamo assicurarci di
 aver installato bumblebee o che comunque entrambe le schede video funzionino
 correttamente e che i driver vengano caricati senza errori.
\end_layout

\begin_layout Subsection
DPMS
\end_layout

\begin_layout Standard
DPMS (Display Power Management Signaling) is a technology that allows power
 saving behaviour of monitors when the computer is not in use.
 This will allow you to have your monitors automatically go into standby
 after a predefined period of time.
 
\end_layout

\begin_layout Subsection
Xorg e bash
\end_layout

\begin_layout Standard
Possiamo interagire con Xorg ad esempio mandando notifiche al Desktop Environmen
t o al Window Manager, una volta installato 
\begin_inset Quotes eld
\end_inset

libnotify
\begin_inset Quotes erd
\end_inset

 con:
\end_layout

\begin_layout Itemize
notify-send "rsnapshot done :)"
\end_layout

\begin_layout Subsection
X e startx
\end_layout

\begin_layout Paragraph
Premessa su Desktop Environment e Display Manager
\end_layout

\begin_layout Standard
E' importante capire la distinzione tra Desktop Environment o Window Manger
 (ambiente più leggero, ma di concetto simile) e Display Manager, il display
 manager (come ad esempio LightDM, KDM, GDM, Qingy, ecc...) è un programma
 utile per sostituire la procedura di login testuale e permettere all'utente
 la scelta del Desktop Environment o Window Manager; mentre il Desktop Environme
nt o il Window Manager è costituito dai programmi atti a gestire le finestre,
 i workspace e gli stili dell'ambiente grafico.
\end_layout

\begin_layout Paragraph
X, startx e xinit e come avviare applicazioni all'avvio del sistema se si
 usa 
\begin_inset Quotes eld
\end_inset

startx
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Il programma startx è uno script utilizzato per lanciare il server grafico
 X utilizzando determinati driver e un determinato window manager o desktop
 environment, startx fa uso del programma 
\begin_inset Quotes eld
\end_inset

xinit
\begin_inset Quotes erd
\end_inset

 per lanciare la GUI (Graphical User Interface), possiamo ad esempio automatizza
re utente per utente l'avvio di determinate applicazioni andando ad inserire
 il nome dell'applicazione da lanciare nel file di configurazione adibito,
 che può essere a differenza della distribuzione:
\end_layout

\begin_layout Itemize
~/.xinitrc
\end_layout

\begin_layout Itemize
~/.xsession
\end_layout

\begin_layout Standard
Mentre è comunque possibile automatizzare l'avvio di applicazioni a livello
 globale (utile ad esempio per applicazioni enterprise) attraverso i file
 di configurazione in 
\begin_inset Quotes eld
\end_inset

/etc
\begin_inset Quotes erd
\end_inset

 che anche in questo caso possono variare da distribuzione a distribuzione
 ma comunque dovrebbero avere un nome simile a uno di quelli precedenti
 sopracitati; per trovare i nomi dei file che vengono usati precisamente
 possiamo fare:
\end_layout

\begin_layout Itemize
whereis startx //mostra dove sono collocati gli eseguibili di startx
\end_layout

\begin_layout Itemize
cat /percorso/startx | more //mostra lo script 
\begin_inset Quotes eld
\end_inset

startx
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Una volta visualizzato lo script basterà cercare i nomi dei file collocati
 alle voci:
\end_layout

\begin_layout Itemize
userclientrc //indica le directory in cui sono situtati i file di configurazione
 locale (utente per utente) di X
\end_layout

\begin_layout Itemize
sysclientrc //indica la directory in cui è situato il file di configurazione
 globale (valido per tutti gli utenti) di X
\end_layout

\begin_layout Standard
Basterà creare questi file se non esistono e al loro interno potremo scrivere
 i comandi da avviare all'avvio di X.
 Recapitolando, startx è uno script che richiama:
\end_layout

\begin_layout Itemize
xinit //inizializzatore di X, che legge anche file di configurazione a livello
 utente e a livello sistema
\end_layout

\begin_layout Itemize
file di configurazione sia a livello utente che a livello globale di sistema
\end_layout

\begin_layout Itemize
X //server per window system
\end_layout

\begin_layout Standard
per poter lanciare un desktop environment.
 Attenzione i file di configurazione discussi in questa sezione, sono validi
 solo nel momento in cui iniziamo la nostra sessione con 
\begin_inset Quotes eld
\end_inset

startx
\begin_inset Quotes erd
\end_inset

, in altri casi (ad esempio gestione attraverso login manager) la configurazione
 potrebbe essere diversa, e questi file potrebbero del tutto essere ignorati;
 fare quindi sempre riferimento alla configurazione del proprio login manager.
 Quando non si usa un login manager, e quindi si fa uso dello script 
\begin_inset Quotes eld
\end_inset

startx
\begin_inset Quotes erd
\end_inset

, dobbiamo inserire all'interno del file di autorun di X discusso a inizio
 sezione (.xinitrc o .xsession, ci basta leggere le prime righe dello script
 startx per capirlo) l'istruzione:
\end_layout

\begin_layout Itemize
exec percorsoDEoWM //dove al posto di percorsoDEoWM possiamo ad esempio
 inserire 
\begin_inset Quotes eld
\end_inset

/usr/bin/startkde
\begin_inset Quotes erd
\end_inset

 o 
\begin_inset Quotes eld
\end_inset

/usr/bin/gnome-session
\begin_inset Quotes erd
\end_inset

 o ancora 
\begin_inset Quotes eld
\end_inset

/usr/bin/startxfce4
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Un altro modo per avviare script o cose da terminale è quello di usare il
 file /etc/rc.local per i sistemi sysVinit.
\end_layout

\begin_layout Subsection
Inittab e Xwindows
\end_layout

\begin_layout Standard
Il file inittab, è un file atto a specificare il default runlevel del nostro
 sistema, anche se nella maggior parte delle distro recenti, in pratica
 da quando il gestore di demoni 
\begin_inset Quotes eld
\end_inset

systemd
\begin_inset Quotes erd
\end_inset

 ha sostituito 
\begin_inset Quotes eld
\end_inset

sysVinit
\begin_inset Quotes erd
\end_inset

 la mansione di questo file è stata delegata ad altri insiemi di file in
 determinate directory; vediamo innanzitutto alcuni comandi utili per gestire
 i runlevel:
\end_layout

\begin_layout Itemize
runlevel //mostra il runlevel attuale e il precedente
\end_layout

\begin_layout Itemize
telinit runlevelNumber //setta il runlevel al numero 
\begin_inset Quotes eld
\end_inset

runlevel Number
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
init runlevelNumber //analogo al comando precedente
\end_layout

\begin_layout Standard
Storicamente la posizione del file 
\begin_inset Quotes eld
\end_inset

inittab
\begin_inset Quotes erd
\end_inset

 era 
\begin_inset Quotes eld
\end_inset

/etc/inittab
\begin_inset Quotes erd
\end_inset

, per avere un'idea più precisa di come gestire i demoni, si rimanda alla
 sezione sui processi e su systemd.
\end_layout

\begin_layout Subsection
Font
\end_layout

\begin_layout Standard
Che palle, questa la fai tu Jack, non ne vedo l'utilità.
 E' la lezione 16 della seconda parte del corso.
\end_layout

\begin_layout Subsection
Xorg Oggi e come avviare applicazioni all'avvio del sistema se non si usa
 
\begin_inset Quotes eld
\end_inset

startx
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Xorg, attualmente autoconfigura le impostazioni per l'ambiente grafico,
 esistono diverse directory dove sono collocati i file di configurazione,
 ad esempio, alcuni file di configurazione sono in:
\end_layout

\begin_layout Itemize
/etc/X11 //qui vengono gestite anche le applicazioni che vengono autolanciate
 all'avvio di Xorg, nel file 
\begin_inset Quotes eld
\end_inset

Xsession
\begin_inset Quotes erd
\end_inset

 che è uno script che richiama gli script nella directory /etc/X11/Xsession.d/*,
 ed è qui che metteremo il programma che ci interessa avviare automaticamente
 genericamente, in realtà i programmi che vogliamo caricare automaticamente
 dopo il login, dipendono dal login manager, quindi dovremo andare a vedere
 nel file di configurazione del nostro login manager, ad esempio per gdm3
 il file di interesse è in 
\begin_inset Quotes eld
\end_inset

/etc/gdm3/Xsession
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
/etc/X11/xorg.conf.d //qui vengono messe i pezzi di configurazione dell'utente,
 questi vanno a sovrascrivere la configurazione di default.
 in quanto nella nuoava veesione di Xorg, non esiste il classico xorg.conf
 dove esisteva la configrazione globale, ma esistono pezzi di configurazione
 che possono essere creati dall'utente
\end_layout

\begin_layout Standard
altri in:
\end_layout

\begin_layout Itemize
/usr/share/X11/xorg.conf.d/ //qui solutamente vengono messi file di applicazioni
 che sovrascrivono le impostazioni attuali di xorg, infatti le configurazioni
 non vengono scritte tutte in un file come una volta, questi file sono impostazi
oni di default, normalmente invece se l'utente vuole impostare una sua configura
zione, deve copiare il file interessato nella directory 
\begin_inset Quotes eld
\end_inset

/etc/X11/xorg.conf.d/nomeFile.conf
\begin_inset Quotes erd
\end_inset

, se la directory 
\begin_inset Quotes eld
\end_inset

xorg.conf.d
\begin_inset Quotes erd
\end_inset

 in 
\begin_inset Quotes eld
\end_inset

/etc/X11
\begin_inset Quotes erd
\end_inset

 non esiste, dobbiamo crearla, normalmente infatti questa non esiste almenochè
 non abbiamo già modificato alcune cose attraverso questa procedura
\end_layout

\begin_layout Standard
La modalità standard per decidere che applicazioni avviare all'avvio di
 una sessione grafica di uno specifico utente, dobbiamo inserire il file
 
\begin_inset Quotes eld
\end_inset

.desktop
\begin_inset Quotes erd
\end_inset

 della relativa applicazione all'interno della directory ~/.config/autostart/,
 dove il file desktop si può creare o si può trovare in 
\begin_inset Quotes eld
\end_inset

/usr/share/applications
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Per informazioni aggiuntive, possiamo eseguire:
\end_layout

\begin_layout Itemize
man xorg.conf //visualizza le pagine di manuale su xorg
\end_layout

\begin_layout Subsubsection
Alcuni file importanti di Xorg
\end_layout

\begin_layout Standard
Elenchiamo alcuni file degni di nota:
\end_layout

\begin_layout Itemize
.Xdefaults (versioni più vecchie o sistemi Unix puri, tipo BSD) o .Xresources
 (più recente): contiene alcune impostazioni di default di Xorg, oppure
 configurazioni per applicazioni di Xorg low level, ad esempio qui possiamo
 trovare le impostazioni di xterm o uxterm, di xclock, xpdf, rxvt-unicode
 e così via
\end_layout

\begin_layout Standard
per caricare un file di impostazioni come .Xdefaults o .Xresources usiamo
 xrdb e possiamo eseguire:
\end_layout

\begin_layout Itemize
xrdb ~/.Xresources //carica le impostazioni con xrdb
\end_layout

\begin_layout Itemize
xrdb -q //mostra le impostazioni attuali
\end_layout

\begin_layout Subsubsection
Login Manager
\end_layout

\begin_layout Standard
Il login manager di default è specificato nel file:
\end_layout

\begin_layout Itemize
/etc/X11/default-login-manager //file dove è specificato il percorso al
 login manager di default
\end_layout

\begin_layout Standard
possiamo cambiare il login manager modificando questo file, attenzione,
 in questo file deve essere presente solo un percorso, non sono ammessi
 commenti, nel caso il percorso fosse scorretto, o ci fossero altri caratteri
 oltre al percorso del login manager, allora il login manager al riavvio
 non partirà.
 E' dalla configurazione del login manager che possiamo impostare le applicazion
i che devono avviarsi al suo avvio.
\end_layout

\begin_layout Subsection
Remap dei Tasti
\end_layout

\begin_layout Subsubsection
Gestione e Remap in ambiente Xorg
\end_layout

\begin_layout Standard
In un ambiente grafico con X possiamo usare xmodmap, dopo averlo installato
 creiamo il file 
\begin_inset Quotes eld
\end_inset

~/.Xmodmap
\begin_inset Quotes erd
\end_inset

 (se non esiste) e scriviamo al suo interno le seguenti stringhe ad esempio
 per eseguire un classico remap, cioè l'assegnazione del tast esc al tab:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

remove Lock = Caps_Lock 
\end_layout

\begin_layout Plain Layout

keysym Caps_Lock = Escape 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
questo funziona in un ambiente X con GUI e per poter visualizzare quale
 tasto a quale codice corrisponde possiamo utilizzare 
\begin_inset Quotes eld
\end_inset

xev
\begin_inset Quotes erd
\end_inset

 e andare a vedere la stringa corrispondente al nome del tasto che premiamo.
 Una volta effettuate le modifiche ci basterà eseguire:
\end_layout

\begin_layout Itemize
xmodmap ~/.Xmodmap //ricarica la configurazione prendendo in input il file
 specificato
\end_layout

\begin_layout Standard
Per altri esempi, e spiegazione della relativa grammatica, possiamo consultare
 l'efficace pagina di man di xmodmap.
 Con xev guardo tutti i codici per le impostare in genere tutti i tasti
 della tastiera (ad esempio per configurare i tasti Fn), un buon inizio
 è guardare il codice del tasto interessato con xev e poi andare nelle configura
zioni del Desktop Environment o del Window Manager e associare quel codice
 ad un determinato script/comando.
\end_layout

\begin_layout Subsubsection
Remap in ambiente senza Xorg
\end_layout

\begin_layout Standard
In un ambiente text only, dovremo invece andare a scrivere in append nel
 file 
\begin_inset Quotes eld
\end_inset

~/.keymap
\begin_inset Quotes erd
\end_inset

 le seguenti stringhe:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

keycode 1 = Caps_Lock 
\end_layout

\begin_layout Plain Layout

keycode 58 = Escape
\end_layout

\end_inset


\end_layout

\begin_layout Standard
e poi eseguiamo:
\end_layout

\begin_layout Itemize
loakeys ~/.keymap
\end_layout

\begin_layout Standard
per vedere i codici corrispettivi ai tasti in un ambiente solo testo senza
 X, possiamo eseguire:
\end_layout

\begin_layout Itemize
sudo showkey -k //mostra i keycode dei tasti che premiamo, per uscire dobbiamo
 aspettare 10 secondi o premere Ctrl+C che funziona solo se viene eseguito
 in un ambiente con X
\end_layout

\begin_layout Subsection
Touchpad e configurazione
\end_layout

\begin_layout Standard
In questa sezione vedremo alcuni strumenti generali per la gestione dei
 driver Synaptics input driver per i touchpad Synaptics (e ALPS) che si
 trovano sulla maggior parte dei notebook.
 Uno strumento molto utile, incluso all'interno del pacchetto 
\begin_inset Quotes eld
\end_inset

xserver-xorg-input-synaptics
\begin_inset Quotes erd
\end_inset

, è molto semplice l'utilizzo, possiamo effettuare:
\end_layout

\begin_layout Itemize
synclient //visualizza la configurazione attuale
\end_layout

\begin_layout Itemize
synclient TapButton1=1 //imposta la variabile TapButton uguale a 1, in questo
 caso stiamo abilitando il click col tocco (tapping) del touchpad
\end_layout

\begin_layout Standard
Nel caso volessimo rendere standard questa configurazione, allora dobbiamo
 copiare il file relativo a synaptics, solitamente situato in 
\begin_inset Quotes eld
\end_inset

/usr/share/X11/xorg.conf.d/
\begin_inset Quotes erd
\end_inset

 nella directory 
\begin_inset Quotes eld
\end_inset

/etc/X11/xorg.conf.d
\begin_inset Quotes erd
\end_inset

 (se non esiste la dobbiamo creare), il file copiato può avere anche un
 nome diverso.
 Ora al suo interno possiamo inserire l'opzione in append al file, nella
 sezione specifica (qui basta leggere un attimo con attenzione il file):
\end_layout

\begin_layout Standard
——————————————————————–
\end_layout

\begin_layout Standard
Option 
\begin_inset Quotes eld
\end_inset

TabButton1
\begin_inset Quotes erd
\end_inset

 
\begin_inset Quotes eld
\end_inset

1
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
———————————————————————
\end_layout

\begin_layout Standard
Al riavvio di X, l'opzione prenderà effetto.
\end_layout

\begin_layout Subsection
Utility in ambiente senza X
\end_layout

\begin_layout Subsubsection
setterm
\end_layout

\begin_layout Standard
The setterm command can set various terminal attributes:
\end_layout

\begin_layout Itemize
setterm -blank 15 -powersave powerdown -powerdown 60 //In this example,
 force screen to turn black in 15 minutes.
 Monitor standby will occur at 60 minutes
\end_layout

\begin_layout Itemize
setterm -underline on; echo "Add Your Important Message Here" setterm -underline
 off //In this example show underlined text for xterm window
\end_layout

\begin_layout Itemize
setterm -cursor off //Another useful option is to turn on or off cursor
\end_layout

\begin_layout Itemize
setterm -cursor on //Turn the cursor on
\end_layout

\begin_layout Section
Networking
\end_layout

\begin_layout Standard
E' importante parlare di interfacce quando si parla di networking, un'interfacci
a è tutto quello che ci permette di avere un'indirizzo ip e una connessione,
 esempi di interfaccia possono essere:
\end_layout

\begin_layout Itemize
lo: loopback interface //presente su tuti i sistemi e utilizzata da un sistema
 per riferirsi a se stesso, solitamente è assegnato l'indirizzo 
\begin_inset Quotes eld
\end_inset

127.0.0.1
\begin_inset Quotes erd
\end_inset

 ma può assumere tutti gli indirizzi nel range 127.0.0.0/8 address block.
 That is, 127.0.0.1 through 127.255.255.254 all represent your computer.
\end_layout

\begin_layout Itemize
vpn: interfaccia per rete vpn
\end_layout

\begin_layout Itemize
ppp: interfaccia per connessione point to point
\end_layout

\begin_layout Itemize
eth: interfaccia ethernet
\end_layout

\begin_layout Itemize
wlan: interfaccia wlan
\end_layout

\begin_layout Itemize
ecc...
\end_layout

\begin_layout Subsection
Nota sui socket
\end_layout

\begin_layout Standard
A network socket is an endpoint of an inter-process communication across
 a computer network.
 Today, most communication between computers is based on the Internet Protocol;
 therefore most network sockets are Internet sockets.
\end_layout

\begin_layout Standard
A socket API is an application programming interface (API), usually provided
 by the operating system, that allows application programs to control and
 use network sockets.
 Internet socket APIs are usually based on the Berkeley sockets standard.
\end_layout

\begin_layout Standard
A socket address is the combination of an IP address and a port number,
 much like one end of a telephone connection is the combination of a phone
 number and a particular extension.
 Based on this address, internet sockets deliver incoming data packets to
 the appropriate application process or thread.
\end_layout

\begin_layout Standard
Un socket, in informatica, nei sistemi operativi moderni, indica un'astrazione
 software progettata per poter utilizzare delle API standard e condivise
 per la trasmissione e la ricezione di dati attraverso una rete oppure come
 meccanismo di IPC (interprocess communication, cioè comunicazione tra processi).
 È il punto in cui il codice applicativo di un processo accede al canale
 di comunicazione per mezzo di una porta, ottenendo una comunicazione tra
 processi che lavorano su due macchine fisicamente separate.
 Dal punto di vista di un programmatore un socket è un particolare oggetto
 sul quale leggere e scrivere i dati da trasmettere o ricevere.
 Ci sono due tipi fondamentali di socket:
\end_layout

\begin_layout Itemize
i socket tradizionali su protocollo IP, usati in molti sistemi operativi
 per le comunicazioni attraverso un protocollo di trasporto (quali TCP o
 UDP); 
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
A sua volta esistono due tipi di socket su IP:
\end_layout

\begin_layout Itemize
LISTEN, che rappresentano la possibilità di ricevere nuove connessioni.
 Un socket di questo tipo è identificato dalla terna protocollo di trasporto,
 indirizzo IP del computer, numero di porta; 
\end_layout

\begin_layout Itemize
ESTABLISHED, che rappresentano una particolare connessione attiva.
 Un socket di questo tipo è identificato dalla 5-tupla protocollo di trasporto,
 indirizzo IP sorgente, indirizzo IP destinazione, numero di porta sorgente,
 numero di porta destinazione.
\end_layout

\end_deeper
\begin_layout Itemize
gli Unix domain socket (detti anche socket locali o socket in dominio Unix),
 usati nei sistemi operativi POSIX per le comunicazioni tra processi residenti
 sullo stesso computer.
\end_layout

\begin_layout Standard
In base alla modalità di connessione, inoltre, si distinguono:
\end_layout

\begin_layout Itemize
Stream socket: connection-oriented, basati su TCP; 
\end_layout

\begin_layout Itemize
Datagram socket: connectionless, basati su UDP; 
\end_layout

\begin_layout Itemize
Raw socket: utilizzati per lo sviluppo di protocolli.
\end_layout

\begin_layout Standard
I socket sono stati introdotti nel 1983 in BSD e poi sono stati ripresi
 da praticamente tutti gli altri sistemi operativi.
 Per questo motivo solitamente le funzioni di programmazione dei socket
 vengono chiamate Berkeley socket API.
 Si consiglia di dare un'occhiata alla pagina inglese di wikipedia, per
 informazioni dettagliate sull'argomento.
\end_layout

\begin_layout Subsubsection
Nota sugli Indirizzi IP Privati
\end_layout

\begin_layout Standard
Una piccola tabella rappresentante gli indirizzi IP privati, questa scelta
 è stata fatta per la scarsità degli indirizzi pubblici con IPv4.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="5">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Nome
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Indirizzo Iniziale
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Indirizzo Finale
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Classi
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Blocco CIDR più grande
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
24-bit block
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10.0.0.0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10.255.255.255
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Singola Classe A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10.0.0.0/8 (255.0.0.0)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20-bit block
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
172.16.0.0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
172.31.255.255
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16 Classi B Contigue
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
172.16.0.0/12 (255.240.0.0)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16-bit block
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
192.168.0.0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
192.168.255.255
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
256 Classi C Contigue
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
192.168.0.0/16 (255.255.0.0)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Indirizzi IP Privati
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Ricorda che l'IPv6 non ha questa distinzione tra indirizzi privati e pubblici.
\end_layout

\begin_layout Subsection
Ifconfig
\end_layout

\begin_layout Standard
Se abbiamo installato il pacchetto net-tools in cui risiede il comando ifconfig
 possiamo effettuare un:
\end_layout

\begin_layout Itemize
ifconfig //visualizza la lista delle interfacce di rete con le relative
 informazioni
\end_layout

\begin_layout Standard
In assenza di ifconfig possiamo effettuare un:
\end_layout

\begin_layout Itemize
ip a //visualizza la lista delle interfacce di rete con le relative informazioni
, è analogo al precedente
\end_layout

\begin_layout Standard
Vediamo alcuni esempi di comandi di rete:
\end_layout

\begin_layout Itemize
ifconfig eth0 down //in questo caso spegniamo l'interfaccia eth0
\end_layout

\begin_layout Itemize
ifconfig eth0 up //in questo caso accendiamo l'interfaccia eth0 
\end_layout

\begin_layout Itemize
ifconfig eth0 promisc //in questo caso accendiamo l'interfaccia eth0 in
 modalità 
\begin_inset Quotes eld
\end_inset

promiscua
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
ifdown –all //spegne tutte le interfacce
\end_layout

\begin_layout Standard
Per le reti wifi, una volta veniva utilizzato 
\begin_inset Quotes eld
\end_inset

iwconfig
\begin_inset Quotes erd
\end_inset

, ma ora è deprecato e viene utilizzato invece al suo posto il programma
 
\begin_inset Quotes eld
\end_inset

iw
\begin_inset Quotes erd
\end_inset

, mentre ifconfig è deprecato in favore di 
\begin_inset Quotes eld
\end_inset

ip
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Per conoscere il nostro IP esterno invece dobbiamo fare il retrieving da
 un sito esterno, il modo più semplice al momento è:
\end_layout

\begin_layout Itemize
curl ifconfig.me //scarica attraverso curl, l'informazione fornita dal sito
 ifconfig.me che fornisce il mio IP esterno
\end_layout

\begin_layout Standard
un altro comando con curl utile da terminale per ricavare informazioni su
 un IP è:
\end_layout

\begin_layout Itemize
curl ipinfo.io/74.207.244.221 //mi da informazioni sull'ip fornito, in questo
 caso è stato utilizzato un IP d'esempio
\end_layout

\begin_layout Standard
nel caso usassimo un proxy socks, possiamo controllare in modo veloce il
 nostro ip esterno attraverso:
\end_layout

\begin_layout Itemize
curl –socks5 127.0.0.1:9050 http://checkip.amazonaws.com/ 
\end_layout

\begin_layout Subsection
Ip
\end_layout

\begin_layout Standard
In pratica al posto di ifconfig e del relativo pacchetto di appartenenza
 
\begin_inset Quotes eld
\end_inset

net-tools
\begin_inset Quotes erd
\end_inset

, che è ritenuto ormai deprecato, oggigiorno dovrebbe essere utilizzato
 ip e il relativo pacchetto 
\begin_inset Quotes eld
\end_inset

iproute2
\begin_inset Quotes erd
\end_inset

, vediamo alcuni comandi d'esempio:
\end_layout

\begin_layout Itemize
ip addr show //mostra gli indirizzi ip, simile ad ifconfig -a
\end_layout

\begin_layout Itemize
ip neigh //mostra la tabella arp, simile ad un 
\begin_inset Quotes eld
\end_inset

arp -na
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
ip addr add 192.168.1.103/24 dev wlan0 //assegna all'interfaccia wlan0 l'indirizzo
 ip indicato, se siamo già connessi dovremo sconnetterci e riconnetterci
 per vedere i cambiamenti
\end_layout

\begin_layout Itemize
ip a add 192.168.1.200/255.255.255.0 dev eth0 //imponiamo sia indirizzo ip che
 subnet mask adll'interfaccia eth0
\end_layout

\begin_layout Itemize
ip addr del 192.168.50.5/24 dev eth1 //in questo caso eliminiamo un indirizzo
 ip
\end_layout

\begin_layout Itemize
ip addr show //mostra gli indirizzi ip, mostra più informazioni di 
\begin_inset Quotes eld
\end_inset

ip link list
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
ip link set eth0 up //accendo l'interfaccia eth0
\end_layout

\begin_layout Itemize
ip link set eth0 down //spengo l'interfaccia eth0
\end_layout

\begin_layout Itemize
ip route help //mostra l'help per l'opzione route di ip
\end_layout

\begin_layout Itemize
ip route show //mostra la tabella di routing
\end_layout

\begin_layout Itemize
ip route get 8.8.8.8 //mostra a quale indirizzo si appoggia per arrivare all'indiri
zzo ip menzionato, utile per troubleshooting, o per capire con quale interfaccia
 mi sto connettendo ad internet od ad una determinata rete
\end_layout

\begin_layout Itemize
ip route add 10.10.20.0/24 via 192.168.50.100 dev eth0 //aggiunge una voce alla
 tabella di routing
\end_layout

\begin_layout Itemize
ip route del 10.10.20.0/24 //rimuove una voce dalla tabella di routing
\end_layout

\begin_layout Itemize
ip route add default via 192.168.50.100 //setto il default gateway, cioè in
 pratica l'interfaccia con cui cui mi collego ad internet, ricordiamo che
 non possiamo eliminare tutte le voci di default in tutti i casi, quando
 abbiamo degli errori, anzichè eliminare l'interfaccia di default aggiungiamone
 una
\end_layout

\begin_layout Itemize
ip route del default via 192.168.50.100 //elimino il default gateway associato
 all'indirizzo menzionato
\end_layout

\begin_layout Itemize
ip -s link //mostra le statistiche di rete
\end_layout

\begin_layout Itemize
ip -s -s link //mostra ancora più statistiche di rete
\end_layout

\begin_layout Itemize
ip monitor all
\end_layout

\begin_layout Subsection
Iw
\end_layout

\begin_layout Standard
La suite di comandi 
\begin_inset Quotes eld
\end_inset

iw
\begin_inset Quotes erd
\end_inset

 gestisce le interfaccie wireless.
 To connect to an AP you can use iw connect if the connection requires:
\end_layout

\begin_layout Standard
No encryption Uses WEP for encryption 
\end_layout

\begin_layout Standard
If you need to connect to an AP with WPA or WPA2 encryption requirements
 then you must use wpa_supplicant.
 
\end_layout

\begin_layout Itemize
iw help //mostra l'help
\end_layout

\begin_layout Itemize
iw list //mostra informazioni dettagliate sull'hardware, questo è utile
 per capire anche le modalità di lavoro supportate da una scheda di rete,
 ad esempio possiamo verificare se la nostra scheda di rete può funzionare
 da Access Point, questo è verificato se esiste la stringa 
\begin_inset Quotes eld
\end_inset

AP
\begin_inset Quotes erd
\end_inset

 nelle voci 
\begin_inset Quotes eld
\end_inset

Supported interface modes:
\begin_inset Quotes erd
\end_inset

 allora sicuramente può fare da Access Point
\end_layout

\begin_layout Itemize
iw dev //mostra tutte le interfaccie wireless, questo mi mostrerà alcune
 informazioni come:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Designated name: phy#1 
\end_layout

\begin_layout Itemize
Device names: wlan0 
\end_layout

\begin_layout Itemize
Interface Index: 4.
 Usually as per connected ports (which can be an USB port).
 
\end_layout

\begin_layout Itemize
Type: Managed.
 Type specifies the operational mode of the wireless devices.
 managed means the device is a WiFi station or client that connects to an
 access point.
\end_layout

\end_deeper
\begin_layout Itemize
iw dev wlan scan //esegue una scansione delle reti disponibili
\end_layout

\begin_layout Itemize
iw event //si mette in ascolto di eventi
\end_layout

\begin_layout Itemize
iw event -f //si mette in ascolto di eventi in tempo reale, utile per il
 debugging
\end_layout

\begin_layout Itemize
iw event -t //si mette in ascolto di eventi in tempo reale, con informazioni
 anche sul tempo, utile per il debugging
\end_layout

\begin_layout Itemize
iw wlan0 connect apName //si collega all'access point chiamato 
\begin_inset Quotes eld
\end_inset

apName
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
iw wlan0 connect apName 2432 //si collega all'access point chiamato 
\begin_inset Quotes eld
\end_inset

apName
\begin_inset Quotes erd
\end_inset

, nel caso ci fossero più Access point con questo nome, in questo caso specifich
iamo la frequenza dell'AP desiderato
\end_layout

\begin_layout Itemize
iw wlan0 connect apName keys 0:abcde d:1:0011223344 //si connette all'access
 point chiamato 
\begin_inset Quotes eld
\end_inset

apName
\begin_inset Quotes erd
\end_inset

 con encryption WEP attraverso la chiave menzionata
\end_layout

\begin_layout Itemize
iw dev wlan1 station dump //mi da informazioni statistiche sulla connessione
 all'access point
\end_layout

\begin_layout Itemize
sudo iw dev wlan0 set power_save on //imposta il power save
\end_layout

\begin_layout Itemize
iw dev wlan0 get power_save //mi dice se sull'interfaccia specificata è
 impostato il power save
\end_layout

\begin_layout Itemize
iw dev moni0 del //rimuove l'interfaccia moni0
\end_layout

\begin_layout Itemize
ip link show wlan0 //mostra info sull'interfaccia wlan0, se vedo la parola
 
\begin_inset Quotes eld
\end_inset

DOWN
\begin_inset Quotes erd
\end_inset

, significa che l'interfaccia è spenta, mentre se vedo 
\begin_inset Quotes eld
\end_inset

UP
\begin_inset Quotes erd
\end_inset

, significa che l'interfaccia è attiva
\end_layout

\begin_layout Itemize
ip link set wlan0 up //attiva l'interfaccia wlan0
\end_layout

\begin_layout Itemize
iw wlan0 link //mostra se l'interfaccia è collegata a qualcosa o meno
\end_layout

\begin_layout Itemize
iw wlan0 scan //esegue una scansione delle reti disponibili
\end_layout

\begin_layout Itemize
iw reg set US //sets the power level of the wifi card on US level
\end_layout

\begin_layout Itemize
iwconfig wlan0 txpower 27 //changes the power level to 27dBm, only if for
 the current selected country is allowed this power level, if not, we can
 still change the country
\end_layout

\begin_layout Itemize
iw reg set BO //sets the power level of the wifi card on Bolivia
\end_layout

\begin_layout Itemize
iwconfig wlan0 txpower 28 //changes the power level to 27dBm, only if for
 the current selected country is allowed this power level, if not, we can
 still change the country
\end_layout

\begin_layout Itemize
ifconfig wlan1 down; iwconfig wlan0 mode monitor //imposta la scheda di
 rete in modalità monitor (per sniffare il traffico)
\end_layout

\begin_layout Itemize
ifconfig wlan1 down; iwconfig wlan0 mode managed //imposta la scheda di
 rete in modalità managed (modalità classica che utilizziamo per connetterci
 ad un access point)
\end_layout

\begin_layout Standard
Per connetterci ad una rete WPA/WPA2, una volta che l'interfaccia di rete
 wireless è attiva eseguiamo:
\end_layout

\begin_layout Itemize
wpa_passphrase ApName myExampleApPassword >> /etc/wpa_supplicant.conf //salva
 un file di configurazione che può essere utilizzato da wpa_supplicant per
 connettersi alla rete wifi wpa/wpa2
\end_layout

\begin_layout Itemize
wpa_supplicant -B -D nl80211,wext -i wlan0 -c /etc/wpa_supplicant.conf //dove:
\end_layout

\begin_deeper
\begin_layout Itemize
-B means run wpa_supplicant in the background 
\end_layout

\begin_layout Itemize
-D specifies the wireless driver, wext is the generic driver
\end_layout

\begin_layout Itemize
-c specifies the path for the configuration file.
\end_layout

\end_deeper
\begin_layout Standard
se questo non dovesse essere abbastanza allora eseguiamo:
\end_layout

\begin_layout Itemize
dhclient wlan0 //eseguiamo una richiesta DHCP all'interfaccia wlan0
\end_layout

\begin_layout Standard
Ricordiamo che alcuni device wifi usano un vecchio driver chiamato 
\begin_inset Quotes eld
\end_inset

wext
\begin_inset Quotes erd
\end_inset

 (wireless extension) e non i più recenti nl80211, per verificare se il
 nostro kernel ha abilitato il supporto wext possiamo eseguire:
\end_layout

\begin_layout Itemize
zgrep WEXT /proc/config.gz //dove il percorso menzionato deve essere il file
 di configurazione del kernel
\end_layout

\begin_layout Standard
Per scrivere gli script o ottenere informazioni sulla rete wifi, possiamo
 usare 
\begin_inset Quotes eld
\end_inset

wgetid
\begin_inset Quotes erd
\end_inset

, è un tool che ci fornisce informazioni in modo molto chiaro e veloce,
 molto utile per ottenere informazioni, ad esempio con 
\begin_inset Quotes eld
\end_inset

iwgetid -r
\begin_inset Quotes erd
\end_inset

 per ottenere il nome dell'access point a cui sono connesso.
\end_layout

\begin_layout Subsection
Arp
\end_layout

\begin_layout Standard
Possiamo visualizzare la tabella di associazione indirizzo IP, mac address
 locale interrogando il sistema con:
\end_layout

\begin_layout Itemize
sudo arp //visualizza la tabella locale del sistema
\end_layout

\begin_layout Standard
oppure effettuare interrogazione in funzione di un indirizzo IP con:
\end_layout

\begin_layout Itemize
sudo arp 192.168.0.1 //visualizza il mac address dell'indirizzo IP menzionato
\end_layout

\begin_layout Subsection
Modalità wireless 802.11
\end_layout

\begin_layout Standard
Questo protocollo prevede 4 modalità operative:
\end_layout

\begin_layout Itemize
Master mode (also called AP or infrastructure mode) is used to create a
 service that looks like a traditional access point.
 The wireless card creates a network with a specified name (called the SSID)
 and channel, and offers network services on it.
 While in master mode, wireless cards manage all communications related
 to the network (authenticating wireless clients, handling channel contention,
 repeating packets, etc.) Wireless cards in master mode can only communicate
 with cards that are associated with it in managed mode.
\end_layout

\begin_layout Itemize
Managed mode is sometimes also referred to as client mode.
 Wireless cards in managed mode will join a network created by a master,
 and will automatically change their channel to match it.
 They then present any necessary credentials to the master, and if those
 credentials are accepted, they are said to be associated with the master.
 Managed mode cards do not communicate with each other directly, and will
 only communicate with an associated master.
 
\end_layout

\begin_layout Itemize
Ad-hoc mode creates a multipoint-to-multipoint network where there is no
 single master node or AP.
 In ad-hoc mode, each wireless card communicates directly with its neighbors.
 Nodes must be in range of each other to communicate, and must agree on
 a network name and channel.
 
\end_layout

\begin_layout Itemize
Monitor mode is used by some tools (such as Kismet, chapter six) to passively
 listen to all radio traffic on a given channel.
 When in monitor mode, wireless cards transmit no data.
 This is useful for analyzing problems on a wireless link or observing spectrum
 usage in the local area.
 Monitor mode is not used for normal communications.
 
\end_layout

\begin_layout Subsection
Network Manager
\end_layout

\begin_layout Standard
Un comune software per la gestione delle connessioni è network manager,
 questo può essere usato in tre modalità:
\end_layout

\begin_layout Itemize
nm-applet //modalità grafica
\end_layout

\begin_layout Itemize
nmtui //interfaccia tui, molto intuitiva e comoda
\end_layout

\begin_layout Itemize
nmcli //programma utilizzato sia da terminale che negli script
\end_layout

\begin_layout Standard
siccome i primi due sono molto intuitivi e non hanno bisogno di ulteriore
 documentazione per le operazioni di base ci focalizzeremo sul terzo.
\end_layout

\begin_layout Subsubsection
nmcli
\end_layout

\begin_layout Standard
Vediamo alcuni comandi di base di nmcli:
\end_layout

\begin_layout Itemize
nmcli device wifi list //mostra la lista degli access point wifi
\end_layout

\begin_layout Itemize
nmcli device wifi rescan //rieffettua lo scan degli access point disponibili
\end_layout

\begin_layout Itemize
nmcli device wifi connect <SSID|BSSID> //ci connettiamo ad una rete wifi
 aperta
\end_layout

\begin_layout Itemize
nmcli device wifi connect <SSID|BSSID> password <password> //ci connettiamo
 ad una rete protetta sia wpa1 che wpa2
\end_layout

\begin_layout Itemize
nmcli device status //mostra lo stato delle varie connessioni e lo stato
 dei device di rete, ad esempio se sono connesso e a quale rete sono connesso
 con quale device
\end_layout

\begin_layout Itemize
nmcli connection show //visualizza la lista delle connessioni
\end_layout

\begin_layout Itemize
nmcli connection edit con-name <name of new connection> // crea una nuova
 connessione chiamata con un nome deciso da noi
\end_layout

\begin_layout Itemize
nmcli connection edit <connection name> //modifica la connessione identificata
 col nome menzionato
\end_layout

\begin_layout Itemize
nmcli connection up id <connection name> //mi collego alla connessione menzionat
a
\end_layout

\begin_layout Itemize
nmcli connection down id <connection name> //mi scollego dalla connessione
 menzionata
\end_layout

\begin_layout Standard
il comando più utile è comunque:
\end_layout

\begin_layout Itemize
man nmcli-examples //pagina di man con diversi esempi di applicazione
\end_layout

\begin_layout Subsubsection
Gestione della rete con Network Manager oppure no?
\end_layout

\begin_layout Standard
I file di configurazione di network manager sono situati nella directory:
\end_layout

\begin_layout Itemize
/etc/NetworkManager
\end_layout

\begin_layout Standard
un file importante è 
\begin_inset Quotes eld
\end_inset

/etc/NetworkManager/system-connections
\begin_inset Quotes erd
\end_inset

 questo contiene tutte le password dei wifi a cui ci siamo collegati.
\end_layout

\begin_layout Standard
Per fare in modo di disabilitare network manager dobbiamo disabilitareil
 corrispettivo demone, con ad esempio:
\end_layout

\begin_layout Itemize
sudo systemctl disable NetworkManager.service
\end_layout

\begin_layout Standard
attenzione in quanto il file /etc/network/interfaces ci potrà sembrare strano
 quando gestiamo la rete con NetworkManager in quanto conterrà solo l'interfacci
a di loopback, in realtà questo è normale, in quanto NetworkManager gestisce
 le interfacce a modo suo, comunque c'è un modo all'interno del file di
 configurazione per indicargli di leggere i file di configurazione di sistema.
 Si consiglia comunque di leggere il file qui sotto riportato per la gestione
 della configurazione di NetworkManager:
\end_layout

\begin_layout Itemize
less /usr/share/doc/network-manager/README //visualizza la documentazione
 di network manager
\end_layout

\begin_layout Subsection
Bridge
\end_layout

\begin_layout Standard
Possiamo configurare un bridge, con due schede di rete ethernet (non wifi)
 attraverso il programma 
\begin_inset Quotes eld
\end_inset

brctl
\begin_inset Quotes erd
\end_inset

, per vedere le opzioni disponibili eseguiamo:
\end_layout

\begin_layout Itemize
brctl //visualizza tutte le opzioni disponibili
\end_layout

\begin_layout Standard
vediamo altri esempi di applicazione del comando:
\end_layout

\begin_layout Itemize
brctl addbr br0 //crea il bridge chiamato br0
\end_layout

\begin_layout Itemize
brctl delbr br0 //elimina il bridge chiamato br0
\end_layout

\begin_layout Itemize
brctl addif br0 eth0 //aggiunge il device eth0 al bridge
\end_layout

\begin_layout Itemize
brctl addif br0 eth1 //aggiunge il device eth1 al bridge
\end_layout

\begin_layout Itemize
brctl show //mostra i vari bridge configurati
\end_layout

\begin_layout Itemize
brctl showmacs br0 //mostra i mac address del bridge indicato
\end_layout

\begin_layout Itemize
ifconfig br0 up //attiva l'interfaccia bridge
\end_layout

\begin_layout Subsubsection
Esempio di configurazione
\end_layout

\begin_layout Standard
Uno scenario d'esempio per configurare una macchina come bridge puro è:
\end_layout

\begin_layout Itemize
ifconfig eth0 0.0.0.0
\end_layout

\begin_layout Itemize
ifconfig eth1 0.0.0.0
\end_layout

\begin_layout Itemize
brctl addbr mybridge
\end_layout

\begin_layout Itemize
brctl addif mybridge eth0
\end_layout

\begin_layout Itemize
brctl addif mybridge eth1
\end_layout

\begin_layout Itemize
ifconfig mybridge up
\end_layout

\begin_layout Standard
in questo caso il bridge non avrà un proprio indirizzo IP, quindi non potremo
 farci accesso via TCP/IP, nel caso volessimo invece assegnargli un indirizzo
 IP, allora sostituiamo l'ultima istruzione con:
\end_layout

\begin_layout Itemize
ifconfig mybridge 192.168.100.5 netmask 255.255.255.0
\end_layout

\begin_layout Standard
oppure nel caso in cui volessimo assegnargli un indirizzo IP con il DHCP
 eseguiamo:
\end_layout

\begin_layout Itemize
dhclient mybridge
\end_layout

\begin_layout Subsection
Connessione Point to Point (PPP) tra due Host
\end_layout

\begin_layout Standard
Possiamo connettere due computer tramite cavo ethernet cross oppure tramite
 classico cavo 
\begin_inset Quotes eld
\end_inset

straight
\begin_inset Quotes erd
\end_inset

 se le schede di rete (almeno una delle due (da verificare)) lo permettono,
 la configurazione è semplicissima, basta effettuare sulla macchina A:
\end_layout

\begin_layout Itemize
sudo ifconfig eth0 192.168.0.5 //imposto un IP per la macchina A
\end_layout

\begin_layout Standard
mentre sulla macchina B
\end_layout

\begin_layout Itemize
sudo ifconfig eth0 192.168.0.6 //imposto un IP per la macchina B
\end_layout

\begin_layout Standard
la scelta dell'IP è arbitraria, ma è meglio ad esempio scegliere una rete
 diversa rispetto ad esempio ad un'altra interfaccia, cioè se ad esempio
 abbiamo su un'altra interfaccia wlan0 wireless l'indirizzo ip 192.168.1.4
 non andrò ad impostare un indirizzo .1.x sulla mia interfaccia eth0, in modo
 da rendere più lineare possibile la comunicazione e non avere conflitti.
\end_layout

\begin_layout Subsection
Configurazione di rete su distro Debian based 
\end_layout

\begin_layout Standard
Nelle distro Debian-based le interfacce sono configurate attraverso il file
 
\begin_inset Quotes eld
\end_inset

/etc/network/interfaces
\begin_inset Quotes erd
\end_inset

, e la directory 
\begin_inset Quotes eld
\end_inset

/etc/network/
\begin_inset Quotes erd
\end_inset

 è dove sono collocati gli script di rete, vediamo un esempio di configurazione
 classico del file interfaces:
\end_layout

\begin_layout Standard
—————————————————————–
\end_layout

\begin_layout Standard
auto lo
\end_layout

\begin_layout Standard
iface lo inet loopback
\end_layout

\begin_layout Standard
#
\end_layout

\begin_layout Standard
auto eth0 
\end_layout

\begin_layout Standard
iface eth0 inet static #utilizza un ip statico
\end_layout

\begin_layout Standard
address 192.168.1.17
\end_layout

\begin_layout Standard
netmask 255.255.255.0
\end_layout

\begin_layout Standard
gateway 192.168.1.1
\end_layout

\begin_layout Standard
network 192.168.1.0
\end_layout

\begin_layout Standard
broadcast 192.168.1.255
\end_layout

\begin_layout Standard
dns-nameservers 192.168.1.195
\end_layout

\begin_layout Standard
up ip route add -net 192.168.1.128 netmask 255.255.255.128 gw 192.168.1.2 #così imposto
 staticamente una voce della tabella di routing
\end_layout

\begin_layout Standard
up ip route add default gw 192.168.1.200
\end_layout

\begin_layout Standard
down ip route del default gw 192.168.1.200
\end_layout

\begin_layout Standard
down ip route del -net 192.168.1.128 netmask 255.255.255.128 gw 192.168.1.2
\end_layout

\begin_layout Standard
—————————————————————–
\end_layout

\begin_layout Standard
una volta modificato il file, ci basterà riavviare il servizio di rete attravers
o:
\end_layout

\begin_layout Itemize
service networking restart //o utilizzando il comando systemctl, anche se
 per grossi cambiamenti è più sicuro eseguire un reboot
\end_layout

\begin_layout Standard
Possiamo notare nel file che le linee che iniziano con 
\begin_inset Quotes eld
\end_inset

auto
\begin_inset Quotes erd
\end_inset

 servono ad identificare interfacce fisiche che vengono attivate col comando
 
\begin_inset Quotes eld
\end_inset

ifup -a
\begin_inset Quotes erd
\end_inset

 o ad esempio negli script di sistema.
 Le riche 
\begin_inset Quotes eld
\end_inset

up
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

down
\begin_inset Quotes erd
\end_inset

 possono essere presenti per ogni interfaccia e indicano le operazioni da
 effettuare per 
\begin_inset Quotes eld
\end_inset

up
\begin_inset Quotes erd
\end_inset

 quando l'interfaccia viene accesa e per 
\begin_inset Quotes eld
\end_inset

down
\begin_inset Quotes erd
\end_inset

 quando l'interfaccia viene spenta, sono possibili anche direttive come
 
\begin_inset Quotes eld
\end_inset

pre-up
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

post-down
\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_layout Standard
Vediamo un altro esempio di file di configurazione:
\end_layout

\begin_layout Standard
—————————————————————–
\end_layout

\begin_layout Standard
auto lo
\end_layout

\begin_layout Standard
iface lo inet loopback
\end_layout

\begin_layout Standard
#
\end_layout

\begin_layout Standard
auto eth0 
\end_layout

\begin_layout Standard
iface eth0 inet dhcp #utilizza un indirizzo dhcp
\end_layout

\begin_layout Standard
gateway 192.168.1.1
\end_layout

\begin_layout Standard
—————————————————————–
\end_layout

\begin_layout Standard
In questo caso dopo inet viene specificata la direttiva 
\begin_inset Quotes eld
\end_inset

dhcp
\begin_inset Quotes erd
\end_inset

, quindi viene usato il dhcp al posto di un indirizzo statico come nel caso
 precedente.
 
\end_layout

\begin_layout Standard
Vediamo ora un altro esempio:
\end_layout

\begin_layout Standard
—————————————————————–
\end_layout

\begin_layout Standard
auto lo iface lo inet loopback
\end_layout

\begin_layout Standard
auto wlan0 iface wlan0 inet static address 192.168.1.104 gateway 192.168.1.1 
\end_layout

\begin_layout Standard

\backslash
netmask 255.255.255.0 network 192.168.1.0 broadcast 192.168.1.255
\end_layout

\begin_layout Standard
pre-up sudo wpa_supplicant -B -i wlan0 -c /etc/wpa_supplicant.conf -D wext
 
\end_layout

\begin_layout Standard
post-down sudo killall -q wpa_supplicant 
\end_layout

\begin_layout Standard
—————————————————————–
\end_layout

\begin_layout Standard
In questo caso andiamo a collegarci attraverso wpa_supplicant ad una rete
 wifi.
\end_layout

\begin_layout Standard
N.B.: Ricordiamo di consultare per esempi la pagina di man interfaces(5) con:
\end_layout

\begin_layout Itemize
man 5 interfaces //visualizza la pagina di man del file interfaces per la
 configurazione della rete su distro Debian based
\end_layout

\begin_layout Subsection
Configurazione di rete su distro Red-Hat based
\end_layout

\begin_layout Standard
Nelle distro basate su Red-Hat le configurazioni delle interfacce sono collocate
 in 
\begin_inset Quotes eld
\end_inset

/etc/sysconfig/network-scripts
\begin_inset Quotes erd
\end_inset

, in questa directory abbiamo molti script e file, quelli che interessano
 maggiormente a noi possiamo visualizzarli con:
\end_layout

\begin_layout Itemize
ls -al ifcfg* //per configurazione indirizzo/subnet/gw
\end_layout

\begin_layout Itemize
ls -al route* //per configurazione voci della tabella di routing
\end_layout

\begin_layout Standard
troveremo un file per ogni interfaccia, supponiamo di avere un'interfaccia
 chiamata 
\begin_inset Quotes eld
\end_inset

eth0
\begin_inset Quotes erd
\end_inset

, allora avremo qualcosa del tipo 
\begin_inset Quotes eld
\end_inset

ifcfg-eth0
\begin_inset Quotes erd
\end_inset

, aprendo questo file con un editor di testo, possiamo visualizzare le diverse
 opzioni, vediamo ad esempio un file che imposta un indirizzo ip statico:
\end_layout

\begin_layout Standard
—————————————————————–
\end_layout

\begin_layout Standard
DEVICE=eth0 
\end_layout

\begin_layout Standard
BOOTPROTO=none 
\end_layout

\begin_layout Standard
ONBOOT=yes 
\end_layout

\begin_layout Standard
NETWORK=10.0.1.0 
\end_layout

\begin_layout Standard
NETMASK=255.255.255.0 
\end_layout

\begin_layout Standard
IPADDR=10.0.1.27 
\end_layout

\begin_layout Standard
USERCTL=no
\end_layout

\begin_layout Standard
—————————————————————–
\end_layout

\begin_layout Standard
vediamo ora invece un file che utilizza dhcp per l'indirizzo ip:
\end_layout

\begin_layout Standard
—————————————————————–
\end_layout

\begin_layout Standard
DEVICE=eth0 
\end_layout

\begin_layout Standard
BOOTPROTO=dhcp
\end_layout

\begin_layout Standard
ONBOOT=yes
\end_layout

\begin_layout Standard
—————————————————————–
\end_layout

\begin_layout Standard
per impostare invece una voce nella tabella di routing avremo un file tipo
 
\begin_inset Quotes eld
\end_inset

route-eth0
\begin_inset Quotes erd
\end_inset

 così costruito:
\end_layout

\begin_layout Standard
—————————————————————–
\end_layout

\begin_layout Standard
10.10.20.0/24 via 192.168.50.100 dev eth0
\end_layout

\begin_layout Standard
—————————————————————–
\end_layout

\begin_layout Standard
per riavviare i servizi di rete ad esempio dopo una modifica, eseguiamo:
\end_layout

\begin_layout Itemize
sudo /etc/init.d/network restart //riavvia il servizio di rete, anche se
 per grossi cambiamenti è più sicuro eseguire un reboot
\end_layout

\begin_layout Subsection
Route & IP Route
\end_layout

\begin_layout Standard
Il comando 
\begin_inset Quotes eld
\end_inset

route
\begin_inset Quotes erd
\end_inset

 ci mostrerà il routing attivo sul nostro sistema, il comando mostra di
 default diverse colonne, ma le più importanti sono:
\end_layout

\begin_layout Itemize
Destination: Mostra la destinazione, per 
\begin_inset Quotes eld
\end_inset

default
\begin_inset Quotes erd
\end_inset

 si intende reste del mondo
\end_layout

\begin_layout Itemize
Gateway: Indica l'indirizzo di gateway utilizzato per accedere agli indirizzi
 indicati da 
\begin_inset Quotes eld
\end_inset

Destination
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Genmask: Indica la subnet mask utilizzata
\end_layout

\begin_layout Itemize
Flags: Mostra diversi flag, possiamo leggere una breve descrizione eseguendo
 
\begin_inset Quotes eld
\end_inset

man route
\begin_inset Quotes erd
\end_inset

 e andando a leggere la sezione 
\begin_inset Quotes eld
\end_inset

Flags
\begin_inset Quotes erd
\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
U: Questo flag indica che questa voce di routing è 
\begin_inset Quotes eld
\end_inset

Up
\begin_inset Quotes erd
\end_inset

, cioè attiva
\end_layout

\begin_layout Itemize
G: Questo flag indica che questa voce di routing è relativa al gateway,
 se questa voce non è presenta vuol dire che le due reti menzionate sono
 connesse direttamente
\end_layout

\begin_layout Itemize
H: Questo flag indica che la destinazione è un host, se non è presente,
 allora vuol dire che la destinazione è un intero network
\end_layout

\begin_layout Itemize
D: Questo flag indica che questa voce della tabella di routing è stata creata
 da un redirect
\end_layout

\begin_layout Itemize
M: Questo flag indica che questa voce della tabella di routing è modificata
 da un redirect
\end_layout

\end_deeper
\begin_layout Itemize
Iface: Indica l'interfaccia per cui è valida la regola di routing
\end_layout

\begin_layout Standard
Per gli altri campi, basterà leggere il manuale del comando 
\begin_inset Quotes eld
\end_inset

route
\begin_inset Quotes erd
\end_inset

.
 Per vedere la tabella di routing, eseguiamo:
\end_layout

\begin_layout Itemize
route -n //mostra la tabella di routing, ma ho bisogno dei permessi di root
\end_layout

\begin_layout Standard
Un'alternativa a route, se non si hanno i diritti di root e si vuole comunque
 visualizzare la tabella di routing è:
\end_layout

\begin_layout Itemize
netstat -rn //mostra informazioni di routing, senza i permessi di root
\end_layout

\begin_layout Standard
Vediamo alcune applicazioni dei comandi di routing:
\end_layout

\begin_layout Itemize
route add default gw 192.168.1.1 //aggiunge 
\begin_inset Quotes eld
\end_inset

add
\begin_inset Quotes erd
\end_inset

 una voce alla tabella di routing imposta come destinazione 
\begin_inset Quotes eld
\end_inset

default
\begin_inset Quotes erd
\end_inset

 e come gateway 
\begin_inset Quotes eld
\end_inset

192.168.1.1
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
route add -host 192.168.1.3 reject //aggiunge una voce alla tabella di routing,
 atta a rendere non raggiungibile l'host 192.168.1.3, nei flag vedremo 
\begin_inset Quotes eld
\end_inset

!H
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
route add -net 192.168.1.0 netmask 255.255.255.0 reject //aggiunge una voce alla
 tabella di routing, atta a rendere non raggiungibile l'intero network 192.168.1.0,
 nei flag vedremo 
\begin_inset Quotes eld
\end_inset

!H
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
route del default gw 192.168.1.1 //rimuove una voce dalla tabella di routing,
 quella avente come destinazione 
\begin_inset Quotes eld
\end_inset

default
\begin_inset Quotes erd
\end_inset

 e gateway 
\begin_inset Quotes eld
\end_inset

192.168.1.1
\begin_inset Quotes erd
\end_inset

, per rimuovere una voce in pratica aggiungo gli stessi campi come se la
 stessi reinserendo, solo che al posto della voce 
\begin_inset Quotes eld
\end_inset

add
\begin_inset Quotes erd
\end_inset

 metto 
\begin_inset Quotes eld
\end_inset

del
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
route add -net 10.1.5.0 netmask 255.255.255.0 gw 192.168.1.5 //rende raggiungibile
 la rete 10.1.5.0 attraverso il default gateway 192.168.1.5
\end_layout

\begin_layout Itemize
route del -net 10.1.5.0 netmask 255.255.255.0 gw 192.168.1.5 //rimuove la voce inserita
 nell'esempio precedente
\end_layout

\begin_layout Standard
In realtà oggigiorno, 
\begin_inset Quotes eld
\end_inset

route
\begin_inset Quotes erd
\end_inset

 è deprecato, ed è consigliato l'utilizzo di 
\begin_inset Quotes eld
\end_inset

ip route
\begin_inset Quotes erd
\end_inset

, che ha comunque sintassi simile al comando precedente, basta solo aggiungere
 davanti 
\begin_inset Quotes eld
\end_inset

ip
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
You can use the route command's 
\begin_inset Quotes eld
\end_inset

-ifscope
\begin_inset Quotes erd
\end_inset

 option to bind a route to a specific interface.
 This lets you create multiple routes that point to the same destination,
 differentiated only by which interface is in play.
 Routes so bound show up in netstat output with the I flag.
\end_layout

\begin_layout Subsection
Ping
\end_layout

\begin_layout Standard
Ping è un programma utilizzato a diversi scopi, possiamo testare reti per
 connettività, per misurare la congestione all'interno di una rete, scoprire
 indirizzi ip di hostname e in genere misurare la qualità di una rete.
 Vediamo alcuni esempi di ping:
\end_layout

\begin_layout Itemize
ping www.nomesito.com //esegue un ping al sito indicato
\end_layout

\begin_layout Itemize
ping -a www.nomesite.com //esegue un ping audibile, cioè emette un beep, quando
 il target diventa disponibile, utile per troubleshooting all'interno di
 una rete, in cui stiamo facendo manutenzione, in modo che non dobbiamo
 rieseguire il comando per verificare se il target è raggiungibile o no
\end_layout

\begin_layout Itemize
ping -A www.nomesito.com //esegue un ping adattativo, cioè le richieste si
 adattano al Round Trip Time, dobbiamo stare attenti in quanto potrebbe
 appesantire un server con richieste molto frequenti
\end_layout

\begin_layout Itemize
ping -c 10 www.nomesito.com //esegue 10 ping
\end_layout

\begin_layout Itemize
ping -c 5 -q 127.0.0.1 //l'opzione 
\begin_inset Quotes eld
\end_inset

-q
\begin_inset Quotes erd
\end_inset

 permette di stampare a schermo solo il sommario del traffico generato
\end_layout

\begin_layout Itemize
ping -w 10 www.nomesito.com //l'opzione 
\begin_inset Quotes eld
\end_inset

-w
\begin_inset Quotes erd
\end_inset

 specifica una deadline in termini di tempo (in secondi), quindi in questo
 caso manderemo pacchetti per 10 secondi
\end_layout

\begin_layout Itemize
ping -i 2 www.google.it //con l'opzione 
\begin_inset Quotes eld
\end_inset

-i
\begin_inset Quotes erd
\end_inset

 specifico l'intervallo alla quale mandare pacchetti in secondi, in questo
 caso mando un ping ogni 2 secondi
\end_layout

\begin_layout Itemize
ping -f www.nomesito.com //esegue ping in modalità 
\begin_inset Quotes eld
\end_inset

flood
\begin_inset Quotes erd
\end_inset

, manda pacchetti il più velocemente flessibile, bisogna avere i permessi
 di root per poter lanciare questo comando, e dobbiamo stare attenti in
 quanto potrebbe appesantire un server con richieste molto frequenti
\end_layout

\begin_layout Itemize
ping -f -i 2 www.nomesito.com //esegue ping in modalità 
\begin_inset Quotes eld
\end_inset

flood
\begin_inset Quotes erd
\end_inset

, ma manda un pacchetto ogni intervallo di 2 secondi
\end_layout

\begin_layout Itemize
ping -n www.nomesito.com //esegue ping ma non effettua 
\begin_inset Quotes eld
\end_inset

name resolution
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
ping -q www.nomesito.com //esegue ping senza visualizzare output su schermo,
 e visualizzerà in questo caso il risultato del ping solo quando il processò
 verrà terminato
\end_layout

\begin_layout Itemize
ping -s 100 www.nomesite.com //con il flag 
\begin_inset Quotes eld
\end_inset

-s
\begin_inset Quotes erd
\end_inset

 (size) cambio la dimensione del payload ICMP dei pacchetti mandati, la
 dimensione di default in questione è 56 byte, in questo caso questa dimensione
 viene cambiata a 100 byte, dobbiamo ricordare che l'header dell'ICMP ha
 una dimensione di 8 byte, inoltre quando viene considerato il pacchetto
 nella sua dimensione totale dobbiamo aggiungere l'header del pacchetto
 IP che è 20 byte, quindi di default abbiamo 56+8+20 (byte), mentre nel
 caso in questione la dimensione totale sarà 100+8+20 (byte)
\end_layout

\begin_layout Itemize
ping -f -i .5 -c 100 www.nomesito.com > results.txt //esegue un ping in modalità
 flood con intervallo ogni mezzo secondo eseguendo in totale 100 richieste
 di ping al sito indicato e stampa i risultati nel file 
\begin_inset Quotes eld
\end_inset

results.txt
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
ping -t 1 www.nomesite.com //esegue un ping impostando il ttl a 
\begin_inset Quotes eld
\end_inset

1
\begin_inset Quotes erd
\end_inset

, questo è molto utile ad esempio come 
\begin_inset Quotes eld
\end_inset

hack
\begin_inset Quotes erd
\end_inset

 quando non possiamo eseguire un traceroute con ICMP, allora possiamo sfruttare
 il ping per effettuare un traceroute andando mano a mano a modificare il
 valore di TTL da 1 fino a 
\begin_inset Quotes eld
\end_inset

n
\begin_inset Quotes erd
\end_inset

 dove per 
\begin_inset Quotes eld
\end_inset

n
\begin_inset Quotes erd
\end_inset

 si intende un nodo per cui anche incrementando il TTL rimane invariato
\end_layout

\begin_layout Itemize
ping hop1 hop2 hop3 ..
 hopN destination //in questo modo sto scegliendo il percorso attraverso
 il quale eseguire il ping, molto utile per eseguire troubleshooting
\end_layout

\begin_layout Itemize
ping -R www.nomesito.com //mostra tutti gli host che vengono attraversati,
 utile per capire gli spostamenti del pacchetto
\end_layout

\begin_layout Standard
Un comando utile durante il ping è 
\begin_inset Quotes eld
\end_inset

Ctrl+|
\begin_inset Quotes erd
\end_inset

, questo manda un segnale di SIGQUIT al processo e mostra una statistica
 breve al momento dell'invio del segnale, il processo intanto continua con
 la sua normale procedura.
\end_layout

\begin_layout Subsection
Informazioni sul DNS e Traceroute
\end_layout

\begin_layout Subsubsection
Traceroute
\end_layout

\begin_layout Standard
Per poter visualizzare i vari host attraversati per arrivare ad un certo
 percorso di rete, possiamo utilizzare traceroute:
\end_layout

\begin_layout Itemize
traceroute www.example.com //esegue un traceroute sull'indirizzo indicato
\end_layout

\begin_layout Standard
che è analogo a:
\end_layout

\begin_layout Itemize
traceroute www.example.com -U //esegue un traceroute utilizzando il protocollo
 UDP, questa opzione su sistemi GNU/Linux può essere omessa, in quanto di
 default è quello che avviene
\end_layout

\begin_layout Standard
talvolta il traceroute potrebbe mostrare degli asterischi su alcuni host,
 questo è perchè non si riceve risposta da quelle macchine, questo può essere
 dovuto a diverse ragioni:
\end_layout

\begin_layout Itemize
il nodo filtra i pacchetti UDP o ICMP
\end_layout

\begin_layout Itemize
tempo di timeout troppo breve
\end_layout

\begin_layout Itemize
il nodo non risponde a pacchetti che hanno TTL=0 con il pacchetto 
\begin_inset Quotes eld
\end_inset

TTL exceeded
\begin_inset Quotes erd
\end_inset

 e quindi non si riceve risposta
\end_layout

\begin_layout Standard
esistono alcune possibili soluzioni, una possibile soluzione al primo problema
 è cambiare il protocollo utilizzato dal traceroute, infatti su GNU/Linux
 di default viene utilizzato il protocollo UDP, ma può essere cambiato con:
\end_layout

\begin_layout Itemize
traceroute www.example.com -T //esegue un traceroute con il protocollo TCP
\end_layout

\begin_layout Itemize
traceroute www.example.com -I //esegue un traceroute utilizzando il protocollo
 ICMP
\end_layout

\begin_layout Itemize
traceroute www.example.com -U //esegue un traceroute utilizzando il protocollo
 UDP, è l'opzione di default quindi può anche essere omessa
\end_layout

\begin_layout Standard
una possibile soluzione invece per il tempo di timeout, potrebbe essere
 cambiarlo, questo può essere fatto con:
\end_layout

\begin_layout Itemize
traceroute www.example.com -w 10 -T //imposto il tempo di timeout a 10 secondi
 e utilizzo il protocollo TCP
\end_layout

\begin_layout Paragraph
Spigazione dell'output di traceroute
\end_layout

\begin_layout Standard
Nell'output vedremo righe come questa:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

fra07s31-in-f23.1e100.net (173.194.112.151)  27.287 ms  26.825 ms  28.280 ms
\end_layout

\end_inset


\end_layout

\begin_layout Standard
in cui nella prima colonna c'è il nome dell'host, o l'indirizzo IP se l'host
 non ha un nome specifico, nella seconda colonna, l'indirizzo IP, nelle
 tre colonne successive i vari tempi di RTT, il traceroute procede finchè
 i tre pacchetti mandati non sono persi per più di due volte e quindi il
 percorso non può essere valutato.
 Vediamo un altro esempio di possibile riga risultante da traceroute:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

 10.254.0.105 (10.254.0.105)  50.172 ms  50.353 ms 10.254.0.109 (10.254.0.109)  51.629
 ms
\end_layout

\end_inset


\end_layout

\begin_layout Standard
in questo caso, possiamo vedere che al primo e al secondo RTT veniamo collegati
 all'indirizzo IP 10.254.0.105, ma al terzo RTT passiamo per un altro indirizzo
 IP, questo può essere dovuto alla configurazione della rete, un esempio
 potrebbe essere uno scenario in cui viene effettuato un load balancing,
 è doveroso ricordare che generalmente richieste diverse possono essere
 reindirizzate a macchine diverse, bisogna anche considerare che i router
 effettuano calcoli di percorsi ottimali e scelgono il percorso più veloce
 in funzione dell'algoritmo utilizzato, quindi la scelta del percorso può
 dipendere da vari fattori, solitamente i router ad esempio scelgono come
 prossima macchina quella meno congestionata, o quella con la banda più
 larga che porta il pacchetto un hop più vicino alla destinazione.
\end_layout

\begin_layout Standard
N.B.: Ricorda che quando si esegue un traceroute ad un sito ad esempio www.fsf.org,
 il primo indirizzo molto probabilmente è il gateway locale, subito dopo
 abbiamo l'indirizzo del nodo di accesso del nostro provider e poi una sfilza
 di indirizzi privati appartenenti alla rete locale del nostro provider,
 fino a quando non si esce, e si passa su altri server esterni per arrivare
 poi infine alla destinazione finale.
\end_layout

\begin_layout Standard
A volte il primo indirizzo trovato in un traceroute non corrisponde a quello
 del gateway, una delle probabili cause è il protocollo (VRRP) Virtual Router
 Redundancy Protocol, in pratica secondo questo protocollo permette una
 struttura di rete più robusta, questo è reso possibile dalla creazione
 di router virtuali, che sono una rappresentazione astratta di un insieme
 di router, es.
 master e backup router, che opera come un gruppo.
 Il default router assegnato ad un host è il router virtuale, non il router
 fisico.
 Se il router fisico che sta attualmente instradando si rompesse, un altro
 router fisico verrebbe selezionato per rimpiazzarlo.
 Il router fisico che sta inoltranto i pacchetti in un dato istante è detto
 master router.
 
\end_layout

\begin_layout Standard
Un altro protocollo simile a VRRP è Hot Standby Router Protocol (HSRP) ma
 è proprietario e di Cisco.
\end_layout

\begin_layout Standard
Or still another option is the Common Address Redundancy Protocol or 
\begin_inset Quotes eld
\end_inset

CARP
\begin_inset Quotes erd
\end_inset

 is a computer networking protocol which allows multiple hosts on the same
 local area network to share a set of IP addresses.
 Its primary purpose is to provide failover redundancy, especially when
 used with firewalls and routers.
 In some configurations, CARP can also provide load balancing functionality.
 CARP provides functionality similar to VRRP and to Cisco Systems' HSRP.
 It is implemented in several BSD-based operating systems and has been ported
 to Linux.
\end_layout

\begin_layout Standard
Un'alternativa a traceroute più completa è costituita da programmi come
 
\begin_inset Quotes eld
\end_inset

mtr
\begin_inset Quotes erd
\end_inset

 che forniscono anche statistiche, per capire qual'è il collo di bottiglia
 su una rete.
\end_layout

\begin_layout Subsubsection*
Asterischi in traceroute indipendentemente dal protocollo
\end_layout

\begin_layout Standard
This is because some machines don't send ICMP "TTL exceeded" errors, that's
 all to not respond to ICMP or that 
\end_layout

\begin_layout Standard
<srandon111> ok but what about TCP ? and UDP ? 
\end_layout

\begin_layout Standard
<grawity> it has nothing to do with what protocol the original packets use
 
\end_layout

\begin_layout Standard
<grawity> no matter what you send, traceroute works by receiving *error
 messages* back 
\end_layout

\begin_layout Standard
<grawity> and those are always ICMP
\end_layout

\begin_layout Standard
<grawity> maybe some routers don't generate those error packets, or maybe
 they have a firewall preventing them from being sent <UncleDrax> or it's
 being throttled (since responding to ICMP takes CPU a very busy router
 has other things to do with)
\end_layout

\begin_layout Paragraph
Traceroute senza root, ovvero tracepath
\end_layout

\begin_layout Standard
Nel caso non avessimo i permessi di root, possiamo eseguire:
\end_layout

\begin_layout Itemize
tracepath www.example.com //esegue un traceroute più semplice senza permessi
 di root
\end_layout

\begin_layout Subsubsection
DNS
\end_layout

\begin_layout Standard
Per avere informazioni sul DNS eseguiamo:
\end_layout

\begin_layout Itemize
host www.example.com
\end_layout

\begin_layout Standard
o per un esame più avanzato sul DNS eseguiamo:
\end_layout

\begin_layout Itemize
dig www.example.com
\end_layout

\begin_layout Standard
possiamo anche eseguire dei reverse lookups con:
\end_layout

\begin_layout Itemize
host 66.11.33.112
\end_layout

\begin_layout Itemize
dig -x 66.11.33.112 //esegue un reverse lookup
\end_layout

\begin_layout Itemize
dig www.ciao.it //esegue una query di tipo A per l'hostname menzionato
\end_layout

\begin_layout Itemize
dig -t A www.ciao.it //analogo al precedente, ma specifichiamo il tipo di
 query
\end_layout

\begin_layout Itemize
dig -t MX www.ciao.it //esegue una query di tipo MX
\end_layout

\begin_layout Itemize
dig -t A www.ciao.it +nocomments +noauthority //rimuove dall'output i commenti
 e la sezione authority, in genere la possibilità sono:
\end_layout

\begin_deeper
\begin_layout Itemize
+nocomments – Turn off the comment lines 
\end_layout

\begin_layout Itemize
+noauthority – Turn off the authority section 
\end_layout

\begin_layout Itemize
+noadditional – Turn off the additional section 
\end_layout

\begin_layout Itemize
+nostats – Turn off the stats section 
\end_layout

\begin_layout Itemize
+noanswer – Turn off the answer section (Of course, you wouldn’t want to
 turn off the answer section)
\end_layout

\begin_layout Itemize
+noall - Turn off everything, this is in general used to be coupled with
 +answer so to only display the answer section
\end_layout

\end_deeper
\begin_layout Itemize
dig @8.8.8.8 www.google.com A //eseguo una query di tipo A utilizzando come resolver
 il server all'indirizzo 8.8.8.8
\end_layout

\begin_layout Itemize
dig PTR 33.164.60.185.in-addr.arpa //esegue una query di tipo PTR all'indirizzo
 IP 33.164.60.185
\end_layout

\begin_layout Itemize
dig MX google.com //esegue una query di tipo MX
\end_layout

\begin_layout Itemize
dig www.ciao.it +trace +additional //vediamo tutte le risposte anche quelle
 
\begin_inset Quotes eld
\end_inset

additional
\begin_inset Quotes erd
\end_inset

 in modo da vedere anche le risposte parziali
\end_layout

\begin_layout Itemize
dig www.ciao.it +short //To view just the ip-address of a web site (i.e the
 A record), use the short form option as shown below.
\end_layout

\begin_layout Itemize
dig axfr @10.10.10.13 esempio.it //implementa uno zone-transfer, in pratica
 se sappiamo che la macchina all'indirizzo IP 10.10.10.13 hosta come sito esempio.it
 e ha la porta 53 DNS in tcp aperta, è possibile a in certi casi effettuare
 uno zone transfer, in questo caso avremo in output la lista di tutte le
 entri relative al server dns, cioè una lista di host disponibili
\end_layout

\begin_layout Itemize
host -t axfr zonetransfer.me nsztm1.digi.ninja.
 //implementa uno zone-transfer utilizzando host
\end_layout

\begin_layout Standard
un comando alternativo a 
\begin_inset Quotes eld
\end_inset

dig
\begin_inset Quotes erd
\end_inset

 comune agli utenti Microsoft Windows ma disponibile anche per GNU/Linux
 è nslookup, possiamo in basilare eseguirlo con:
\end_layout

\begin_layout Itemize
nslookup www.google.it //risolve www.google.it
\end_layout

\begin_layout Standard
E' da notare che dig ed nslookup potrebbero fornire due output diversi,
 questo è dovuto al fatto che dig utilizza lo stub resolver del Sistema
 Operativo mentre nslookup ne implementa uno tutto suo.
\end_layout

\begin_layout Standard
Per ottenere informazioni dns su un dominio che non conosciamo possiamo
 usare 
\begin_inset Quotes eld
\end_inset

dnsdumpster.com
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Subsection
Netcat
\end_layout

\begin_layout Standard
Netcat è il coltellino svizzero dell'amministratore di rete, ci permette
 di gestire connessioni in senso lato, possiamo utilizzarlo per aprire dei
 stream in rete, effettuare chat primitive, o addirittura scambiare file,
 costruire server, effettuare particolari richieste, eccetera.
\end_layout

\begin_layout Paragraph
Semplice comunicazione su una porta (Chat Primitiva)
\end_layout

\begin_layout Standard
Se per esempio volessimo comunicare sulla porta 
\begin_inset Quotes eld
\end_inset

3333
\begin_inset Quotes erd
\end_inset

 allora sul server eseguiamo:
\end_layout

\begin_layout Itemize
netcat -l 192.168.1.122 3333 //l'opzione 
\begin_inset Quotes eld
\end_inset

-l
\begin_inset Quotes erd
\end_inset

 sta per listen ed è quella che ci permette di implementare server
\end_layout

\begin_layout Standard
mentre sul client eseguiamo:
\end_layout

\begin_layout Itemize
netcat 192.168.1.122 3333
\end_layout

\begin_layout Standard
a questo punto tutto quello che scriviamo da una parte lo vediamo dall'altra.
\end_layout

\begin_layout Paragraph
Semplice Server Web
\end_layout

\begin_layout Standard
Possiamo ad esempio creare un semplice file chiamato myFile.html così strutturato
:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

HTTP/1.0 200 OK
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<html>
\end_layout

\begin_layout Plain Layout

<body>
\end_layout

\begin_layout Plain Layout

<h1>Prova...</h1>
\end_layout

\begin_layout Plain Layout

</body>
\end_layout

\begin_layout Plain Layout

</html>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
ora una volta creato questo file possiamo eseguire:
\end_layout

\begin_layout Itemize
netcat -l ourIPAddress portOnWhichToListen < myFile.html // questo si metterà
 in ascolto sull'interfaccia alla quale è collegato l'indirizzo IP, e alla
 porta specificata un server web con la pagine myFile.html, attenzione dopo
 che un'utente carica il sito, il server va giu
\end_layout

\begin_layout Paragraph
Trasferimento File
\end_layout

\begin_layout Standard
Se da un server avente indirizzo 192.168.1.122 volessimo trasferire un file
 dalla porta 3333, eseguiamo:
\end_layout

\begin_layout Itemize
cat backup.iso | netcat -l 192.168.1.122 3333
\end_layout

\begin_layout Standard
mentre sul client eseguiamo:
\end_layout

\begin_layout Itemize
netcat 192.168.1.122 3333 > backup.iso
\end_layout

\begin_layout Standard
Purtroppo netcat non mostra nessuna barra di progresso, per questo possiamo
 utilizzare un programmino esterno chiamato 
\begin_inset Quotes eld
\end_inset

pv
\begin_inset Quotes erd
\end_inset

 (da installare) e questa volta da server effettuare:
\end_layout

\begin_layout Itemize
cat backup.iso | pv -b | nc -l 192.168.1.122 3333
\end_layout

\begin_layout Standard
mentre da client eseguire:
\end_layout

\begin_layout Itemize
nc 192.168.1.122 3333 | pv -b > backup.iso
\end_layout

\begin_layout Paragraph
Netcat come Port Scanner
\end_layout

\begin_layout Standard
Anche se non è lo strumento più indicato per agire da port scanner, può
 essere utilizzato in assenza di altro, ad esempio:
\end_layout

\begin_layout Itemize
nc -z 192.168.0.1 80-90 //esegue un port scan sull'ip indicato dalla porta
 80 alla porta 90
\end_layout

\begin_layout Subsection
Telnet
\end_layout

\begin_layout Standard
Vediamo un comando che funge quasi da alternativa a netcat, questo è telnet,
 per connetterci ad un host eseguiamo:
\end_layout

\begin_layout Itemize
telnet pel.unipv.it 80 //si connette all'host richiesto con la porta specificata
\end_layout

\begin_layout Subsection
Wget
\end_layout

\begin_layout Standard
Wget è un programma molto utile per scaricare qualsiasi cosa dal web, ad
 esempio:
\end_layout

\begin_layout Itemize
wget http://www.openss7.org/repos/tarballs/strx25-0.9.2.1.tar.bz2 //scarica il
 file specificato
\end_layout

\begin_layout Itemize
wget -O taglist.zip http://www.vim.org/scripts/download_script.php?src_id=7701
 //scarica il file specificato e lo salva col nome menzionato col flag 
\begin_inset Quotes eld
\end_inset

-O
\begin_inset Quotes erd
\end_inset

, che sta per 
\begin_inset Quotes eld
\end_inset

output
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
wget –limit-rate=200k http://www.openss7.org/repos/tarballs/strx25-0.9.2.1.tar.bz2
 //imposta un limite di velocità in download
\end_layout

\begin_layout Itemize
wget -c http://www.openss7.org/repos/tarballs/strx25-0.9.2.1.tar.bz2 //scarica
 il file, se è già stato parzialmente scaricato, continua dall'ultimo punto
 di interruzione
\end_layout

\begin_layout Itemize
wget -b http://www.openss7.org/repos/tarballs/strx25-0.9.2.1.tar.bz2 //scarica
 in background, e crea un file chiamato wget-log, possiamo osservarlo con
 
\begin_inset Quotes eld
\end_inset

tail -f wget-log
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
wget –user-agent="Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9.0.3) Gecko/20080924
16 Firefox/3.0.3" URL-TO-DOWNLOAD //scaricare un file, fingendo di essere
 un browser, in quanto alcuni server non permettono il download se non si
 è in un browser
\end_layout

\begin_layout Itemize
wget –tries=75 DOWNLOAD-URL //imposta un numero di tentativi per il download,
 dovrebbe essere interessante se combinato con 
\begin_inset Quotes eld
\end_inset

-c
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
wget -i download-file-list.txt //scatica tutti gli url contenuti nel file
 menzionati, 
\begin_inset Quotes eld
\end_inset

-i
\begin_inset Quotes erd
\end_inset

 sta per 
\begin_inset Quotes eld
\end_inset

input
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
wget –mirror -p –convert-links -P ./LOCAL-DIR WEBSITE-URL //scarica un sito
 web nella sua interezza
\end_layout

\begin_layout Itemize
wget –reject=gif WEBSITE-TO-BE-DOWNLOADED //scarica un sito senza determinati
 tipi di file
\end_layout

\begin_layout Itemize
wget -r -A.pdf http://url-to-webpage-with-pdfs/ //scarica ricorsivamente
 
\begin_inset Quotes eld
\end_inset

-r
\begin_inset Quotes erd
\end_inset

 tutti i file con estensione 
\begin_inset Quotes eld
\end_inset

.pdf
\begin_inset Quotes erd
\end_inset

 nella pagina specificata
\end_layout

\begin_layout Itemize
wget -r www.sitoweb.com/paginaACaso/ //scarica ricorsivamente tutti i file
 presenti in questa pagina
\end_layout

\begin_layout Itemize
wget ftp-url //scarica un url ftp
\end_layout

\begin_layout Itemize
wget –ftp-user=USERNAME –ftp-password=PASSWORD DOWNLOAD-URL //scarica un
 url ftp, con accesso credenziali
\end_layout

\begin_layout Itemize
wget –user=vivek –password='myPassword' http://theos.in/protected/area/foo.pdf
 //Scarica un file che ha bisogno di credenziali su un server per essere
 scaricato
\end_layout

\begin_layout Itemize
wget -r -l 2 www.website.com //scarica il sito web, con un livello di profondità
 uguale a 2, mentre utilizzando –mirror, il livello di profondità è infinito
\end_layout

\begin_layout Subsection
Curl
\end_layout

\begin_layout Standard
curl is a tool to transfer data from or to a server, using one of the supported
 protocols (DICT, FILE, FTP, FTPS, GOPHER, HTTP, HTTPS, IMAP, IMAPS, LDAP,
 LDAPS, POP3, POP3S, RTMP, RTSP, SCP, SFTP, SMB, SMBS, SMTP, SMTPS, TELNET
 and TFTP).
 The com‐ mand is designed to work without user interaction.
 Curl is very important we can think about curl as the netcat for web applicatio
ns.
\end_layout

\begin_layout Standard
curl offers a busload of useful tricks like proxy support, user authentication,
 FTP upload, HTTP post, SSL connections, cook‐ ies, file transfer resume,
 Metalink, and more.
 Curl is a linux utility that is used to make HTTP requests to a given url.
 It outputs HTTP response to standard output and is actually very easy to
 use.
 Here are some examples to show its usage:
\end_layout

\begin_layout Itemize
curl www.website.com //visualizza la pagina HTML del sito, di default esegue
 il comando HTTP GET
\end_layout

\begin_layout Itemize
curl --request GET 'http://ciao.it' // questo fa la stessa cosa del precedente,
 cioè esegue una richiesta GET alla locazione indicata
\end_layout

\begin_layout Standard
vediamo altri esempi:
\end_layout

\begin_layout Itemize
curl --request POST 'http://www.somedomain.com/' //l'opzione --request può
 essere sostituito dal flag -X 
\end_layout

\begin_layout Itemize
curl -XDELETE 'http://www.somedomain.com/' 
\end_layout

\begin_layout Itemize
curl -XPUT 'http://www.somedomain.com/' 
\end_layout

\begin_layout Standard
possiamo mandare dei dati in 
\begin_inset Quotes eld
\end_inset

POST
\begin_inset Quotes erd
\end_inset

 attraverso il flag 
\begin_inset Quotes eld
\end_inset

-d
\begin_inset Quotes erd
\end_inset

, ad esempio:
\end_layout

\begin_layout Itemize
curl -XGET 'http://localhost:9200/_count?pretty' -d ' { "query": { "match_all":
 {} } } ' //in questo caso mandiamo JSON in POST, ma qualsiasi dato volessimo
 mandare in POST possiamo farlo attraverso il flag 
\begin_inset Quotes eld
\end_inset

-d
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
dovremmo poterci autenticare con HTTP attraverso un'autenticazione basic
 o digest attraverso:
\end_layout

\begin_layout Itemize
curl -u username:password http://awebsite.com //basic authentication
\end_layout

\begin_layout Itemize
curl --digest -u username:password http://awebsite.com //digest authentication
\end_layout

\begin_layout Standard
Altri esempi:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

http methods                    curl -XTRACE  <url> 
\end_layout

\begin_layout Plain Layout

x-forwarded-for                 curl -H "X-Forwarded-For: 10.0.0.1" <url> 
 
\end_layout

\begin_layout Plain Layout

basic authentication            curl -u <user>:<password> <url> 
\end_layout

\begin_layout Plain Layout

post form                       curl -XPOST --form "b=4_1" <url>       
   
\end_layout

\begin_layout Plain Layout

cookie                          curl --cookie "PHPSESSID=5ved46gn34dopkjhstrrfgd
kk1;" <url> 
\end_layout

\begin_layout Plain Layout

cookie files (save & send)      curl -c /tmp/cookie.txt -b /tmp/cookie.txt
 <url> 
\end_layout

\begin_layout Plain Layout

set user-agent                  curl -A "Mozilla" <url> 
\end_layout

\begin_layout Plain Layout

referer                         curl -H "Referer: https://www.cnn.com" <url>
 
\end_layout

\begin_layout Plain Layout

json                         curl -XPOST -H "Content-Type: application/json"
 -d "[[
\backslash
"create
\backslash
",                                 {
\backslash
"type
\backslash
":
\backslash
"trial
\backslash
",
\backslash
"name
\backslash
":
\backslash
"bug
\backslash
"}]] <url> 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

silent                          curl -s <url> 
\end_layout

\begin_layout Plain Layout

verbose                         curl -v <url> 
\end_layout

\begin_layout Plain Layout

ignore certifikate issues      curl -k <url> 
\end_layout

\begin_layout Plain Layout

follow redircts                 curl -L <url> 
\end_layout

\begin_layout Plain Layout

redirect output into file       curl -o <file> <url> 
\end_layout

\begin_layout Plain Layout

curl with proxy                 curl -x <proxy>:<port> <url> 
\end_layout

\begin_layout Plain Layout

curl SSL V3                     curl -k -v --sslv3 <url>  
\end_layout

\begin_layout Plain Layout

curl max time (4 seconds)       curl -m4 <url> 
\end_layout

\begin_layout Plain Layout

file upload                     curl -XPOST -F ul=30000 -F location=/tmp/upload-
form-data.txt                                  -F userfile=@/tmp/upload-file.txt
 <url> 
\end_layout

\begin_layout Plain Layout

shell-shock                     curl -k -L -H 'User-Agent: () { :;}; curl
 -L  <return-server>;'  <url> 
\end_layout

\begin_layout Plain Layout

post data from file             curl -data '@<filename>' <url> 
\end_layout

\begin_layout Plain Layout

curl output response time       curl -o /dev/null -w%{time_connect}:%{time_start
transfer}%{time_total} <url> 
\end_layout

\begin_layout Plain Layout

curl output request size        curl -o /dev/null -w%{size_request} %{size_uploa
d} <url>  
\end_layout

\begin_layout Plain Layout

curl output http status code    curl -o /dev/null -w%%{http_code} <url>
 
\end_layout

\begin_layout Plain Layout

curl resolve ip from other dns  curl --resolve "www.cnn.com:80:8.8.8.8" http://www.cnn.
com 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

curl http://curl.haxx.se 
\end_layout

\begin_layout Plain Layout

curl http://site.{one,two,three}.com   
\end_layout

\begin_layout Plain Layout

curl ftp://ftp.numericals.com/file[1-100].txt   
\end_layout

\begin_layout Plain Layout

curl ftp://ftp.numericals.com/file[001-100].txt   
\end_layout

\begin_layout Plain Layout

curl ftp://ftp.letters.com/file[a-z].txt  
\end_layout

\begin_layout Plain Layout

curl http://any.org/archive[1996-1999]/vol[1-4]/part{a,b,c}.html  
\end_layout

\begin_layout Plain Layout

curl http://www.numericals.com/file[1-100:10].txt   
\end_layout

\begin_layout Plain Layout

curl http://www.letters.com/file[a-z:2].txt  
\end_layout

\begin_layout Plain Layout

curl -o index.html http://curl.haxx.se/   
\end_layout

\begin_layout Plain Layout

curl http://curl.haxx.se/ > index.html  
\end_layout

\begin_layout Plain Layout

curl -# http://curl.haxx.se/ > index.html      
\end_layout

\begin_layout Plain Layout

curl -0 http://curl.haxx.se/   
\end_layout

\begin_layout Plain Layout

curl --http1.1 http://curl.haxx.se/   
\end_layout

\begin_layout Plain Layout

curl --http2 http://curl.haxx.se/  
\end_layout

\begin_layout Plain Layout

curl -1 http://curl.haxx.se/   
\end_layout

\begin_layout Plain Layout

curl --tlsv1 http://curl.haxx.se/
\end_layout

\begin_layout Plain Layout

curl -2 http://curl.haxx.se/   
\end_layout

\begin_layout Plain Layout

curl --sslv2 http://curl.haxx.se/
\end_layout

\begin_layout Plain Layout

curl -3 http://curl.haxx.se/   
\end_layout

\begin_layout Plain Layout

curl --sslv3 http://curl.haxx.se/
\end_layout

\begin_layout Plain Layout

curl -4 http://curl.haxx.se/   
\end_layout

\begin_layout Plain Layout

curl --ipv4 http://curl.haxx.se/
\end_layout

\begin_layout Plain Layout

curl -6 http://curl.haxx.se/   
\end_layout

\begin_layout Plain Layout

curl --ipv6 http://curl.haxx.se/
\end_layout

\begin_layout Plain Layout

curl -A "wget/1.0" http://curl.haxx.se/   
\end_layout

\begin_layout Plain Layout

curl --user-agent "Mozilla/4.0 (compatible; MSIE 5.01; Windows NT 5.0)" [URL]
 
\end_layout

\begin_layout Plain Layout

curl --user-agent "Mozilla/4.73 [en] (X11; U; Linux 2.2.15 i686)" [URL]
\end_layout

\begin_layout Plain Layout

curl -b "phpsession=Testtest" http://demo.com/     
\end_layout

\begin_layout Plain Layout

curl --cookie "name=Daniel" http://curl.haxx.se
\end_layout

\begin_layout Plain Layout

curl -c cookies.txt http://curl.haxx.se/   
\end_layout

\begin_layout Plain Layout

curl --cookie-jar cookies.txt http://curl.haxx.se
\end_layout

\begin_layout Plain Layout

curl -d "username=admin&password=pass" http://curl.haxx.se/   
\end_layout

\begin_layout Plain Layout

curl --data "birthyear=1905&press=%20OK%20"  http://curl.haxx.se/when.cgi 
\end_layout

\begin_layout Plain Layout

curl --data-urlencode "name=I am Daniel" http://curl.haxx.se 
\end_layout

\begin_layout Plain Layout

curl --data "<xml>" --header "Content-Type: text/xml" --request PROPFIND
 url.com
\end_layout

\begin_layout Plain Layout

curl -e "http://referer" http://demo.com/   
\end_layout

\begin_layout Plain Layout

curl --referer http://curl.haxx.see http://curl.haxx.se
\end_layout

\begin_layout Plain Layout

curl --header "Host:" http://curl.haxx.se 
\end_layout

\begin_layout Plain Layout

curl --header "Destination: http://nowhere" http://curl.haxx.se
\end_layout

\begin_layout Plain Layout

curl -D - http://curl.haxx.se/   
\end_layout

\begin_layout Plain Layout

curl --dump-header headers_and_cookies http://curl.haxx.se
\end_layout

\begin_layout Plain Layout

curl -L http://github.com/   
\end_layout

\begin_layout Plain Layout

curl --location http://curl.haxx.se
\end_layout

\begin_layout Plain Layout

curl --dns-servers 8.8.8.8 http://demo.com/  
\end_layout

\begin_layout Plain Layout

curl --trace-ascii debugdump.txt http://curl.haxx.se/ 
\end_layout

\begin_layout Plain Layout

curl --form upload=@localfilename --form press=OK [URL] 
\end_layout

\begin_layout Plain Layout

curl --upload-file uploadfile http://curl.haxx.se/receive.cgi 
\end_layout

\begin_layout Plain Layout

curl --user name:password http://curl.haxx.se 
\end_layout

\begin_layout Plain Layout

curl --proxy-user proxyuser:proxypassword curl.haxx.se
\end_layout

\begin_layout Plain Layout

curl --cert mycert.pem https://secure.example.com
\end_layout

\end_inset


\end_layout

\begin_layout Standard
per mandare un file in post ad esempio contenente XML, possiamo eseguire:
\end_layout

\begin_layout Itemize
curl -d @test.txt http://10.10.10.78/hosts.php
\end_layout

\begin_layout Subsection
File di networking importanti
\end_layout

\begin_layout Standard
Vediamo ora una serie di file molto importanti per la configurazione di
 rete.
\end_layout

\begin_layout Subsubsection
Il file resolv.conf
\end_layout

\begin_layout Standard
Il file resolv.conf è utilizzato per definire i server DNS, cercare domini
 e gestire active directory.
 Esistono tuttavia delle differenze tra le distro basate su Debian e quelle
 basate su Red-Hat.
\end_layout

\begin_layout Paragraph
Distro Debian-Based
\end_layout

\begin_layout Standard
Il file resolv.conf è localizzato in 
\begin_inset Quotes eld
\end_inset

/etc/resolv.conf
\begin_inset Quotes erd
\end_inset

, possiamo aggiungere l'indirizzo del server DNS aggiungendo una voce:
\end_layout

\begin_layout Itemize
nameserver 8.8.8.8 //abbiamo aggiunto il DNS server 8.8.8.8
\end_layout

\begin_layout Standard
le modifiche saranno applicate subito, senza necessità di riavviare i servizi
 di rete, ad ogni modo questa configurazione sarà temporanea, in quanto
 al prossimo reboot il file resolv.conf verrà reimpostato alla sua configurazione
 originale, per modificare in modo assoluto la configurazione, andiamo nella
 directory 
\begin_inset Quotes eld
\end_inset

/etc/resolvconf/resolv.conf.d/
\begin_inset Quotes erd
\end_inset

 e in questa directory abbiamo due file di configurazione:
\end_layout

\begin_layout Itemize
head //in questo file inseriamo le direttive che verranno messe in testa
 al file resolv.conf, quindi quelle con priorità maggiore
\end_layout

\begin_layout Itemize
base //in questo file inseriamo le direttive che verranno messe sotto quelle
 indicate dal file head
\end_layout

\begin_layout Standard
i nostri nameserver possiamo inserirli all'interno di questi file, quindi
 aggiungeremo in uno dei due la direttiva 
\begin_inset Quotes eld
\end_inset

nameserver 8.8.8.8
\begin_inset Quotes erd
\end_inset

, una volta fatto, per andare a cambiare il file resolv.conf attuale eseguiremo:
\end_layout

\begin_layout Itemize
resolvconf -u // disponibile solo su alcune distro Debian-based
\end_layout

\begin_layout Standard
altre direttive che possono essere date al file resolv.conf oltre ai nameserver
 possono essere ad esempio 
\begin_inset Quotes eld
\end_inset

domain mydomain.local
\begin_inset Quotes erd
\end_inset

 se la nostra macchina fa da server DNS per un particolare dominio o è membro
 di un dominio.
 Esistono poi diverse opzioni come 
\begin_inset Quotes eld
\end_inset

options timeout:1
\begin_inset Quotes erd
\end_inset

 che significa, non perdere più di un secondo per una richiesta DNS oppure
 
\begin_inset Quotes eld
\end_inset

search yourdomain.local
\begin_inset Quotes erd
\end_inset

, significa che non siamo membri di un determinato dominio ma vogliamo includerl
o nella ricerca DNS.
 Vediamo un esempio di file resolv.conf:
\end_layout

\begin_layout Standard
—————————————————————–
\end_layout

\begin_layout Standard
nameserver 8.8.8.8
\end_layout

\begin_layout Standard
nameserver 192.168.1.1
\end_layout

\begin_layout Standard
domain mydomain.local
\end_layout

\begin_layout Standard
options timeout:1
\end_layout

\begin_layout Standard
search yourdomain.local
\end_layout

\begin_layout Standard
—————————————————————–
\end_layout

\begin_layout Subsubsection
Il file hosts
\end_layout

\begin_layout Standard
Il file 
\begin_inset Quotes eld
\end_inset

hosts
\begin_inset Quotes erd
\end_inset

 e collocato nella directory 
\begin_inset Quotes eld
\end_inset

/etc/hosts
\begin_inset Quotes erd
\end_inset

, permette di associare ad indirizzi ip dei nomi.
 Nella maggior parte dei casi in questo file di default vedremo:
\end_layout

\begin_layout Standard
—————————————————————–
\end_layout

\begin_layout Standard
127.0.0.1 localhost 
\end_layout

\begin_layout Standard
127.0.1.1 nomeComputer 
\end_layout

\begin_layout Standard
—————————————————————–
\end_layout

\begin_layout Standard
quindi questo vuol dire che tutte le volte che faremo un ping a localhost,
 verrà utilizzato quell'indirizzo.
 Un caso pratico è, vogliamo riferirci nella nostra LAN alle varie macchine
 con nomi significativi, questo può essere fatto semplicemente con:
\end_layout

\begin_layout Standard
—————————————————————–
\end_layout

\begin_layout Standard
localhost 127.0.0.1 
\end_layout

\begin_layout Standard
127.0.1.1 nomeComputer 
\end_layout

\begin_layout Standard
192.168.1.105 jack 
\end_layout

\begin_layout Standard
192.168.1.114 max 
\end_layout

\begin_layout Standard
192.168.1.104 serverAndromeda 
\end_layout

\begin_layout Standard
—————————————————————–
\end_layout

\begin_layout Standard
è possibile anche reindirizzare siti web, ad esempio:
\end_layout

\begin_layout Standard
—————————————————————–
\end_layout

\begin_layout Standard
127.0.0.1 localhost 
\end_layout

\begin_layout Standard
127.0.1.1 nomeComputer 
\end_layout

\begin_layout Standard
192.168.1.16 www.yahoo.com 
\end_layout

\begin_layout Standard
192.168.1.16 yahoo.com
\end_layout

\begin_layout Standard
—————————————————————–
\end_layout

\begin_layout Standard
Ora ogni qualvolta io faccio un ping a www.yahoo.com o a yahoo.com in realtà
 verrà fatto un ping all'indirizzo 192.168.1.16 e anche nel browser se la pagina
 non è in cache, vedremo il webserver all'indirizzo 
\begin_inset Quotes eld
\end_inset

192.168.1.16
\begin_inset Quotes erd
\end_inset

.
 Possiamo utilizzare il file hosts anche come filtro, ad esempio, nel caso
 volessimo bloccare l'accesso a 
\begin_inset Quotes eld
\end_inset

www.playboy.com
\begin_inset Quotes erd
\end_inset

, basterebbe fare 
\begin_inset Quotes eld
\end_inset

127.0.0.1 www.playboy.com
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

127.0.0.1 playboy.com
\begin_inset Quotes erd
\end_inset

, è sempre meglio mettere tuti i riferimenti ad un sito web, in quanto solitamen
te è accessibile almeno con due nomi di dominio.
 E' possibile accorpare più domini sotto un solo ip, ad esempio:
\end_layout

\begin_layout Standard
—————————————————————–
\end_layout

\begin_layout Standard
127.0.0.1 localhost 
\end_layout

\begin_layout Standard
127.0.1.1 nomeComputer 
\end_layout

\begin_layout Standard
192.168.1.16 www.yahoo.com yahoo.com www.playboy.com playboy.com
\end_layout

\begin_layout Standard
—————————————————————–
\end_layout

\begin_layout Standard
Nel caso sopracitato stiamo reindirizzando sia richieste verso il sito di
 yahoo che richieste verso il sito di playboy verso l'indirizzo ip specificato.
\end_layout

\begin_layout Subsubsection
Il file hostname
\end_layout

\begin_layout Standard
Il file hostname contiene informazioni sul nome della nostra macchina, il
 nome con cui possiamo accedere alla nostra macchina dall'interno o dall'esterno
; hostname può essere un file o un comando o entrambi a differenza della
 distro utilizzata.
 Nelle distro Debian based il file è collocato in 
\begin_inset Quotes eld
\end_inset

/etc/hostname
\begin_inset Quotes erd
\end_inset

 mentre nelle Red-Hat based possiamo visualizzare l'hostname attraverso
 la voce 
\begin_inset Quotes eld
\end_inset

HOSTNAME
\begin_inset Quotes erd
\end_inset

 all'interno del file 
\begin_inset Quotes eld
\end_inset

/etc/sysconfig/network
\begin_inset Quotes erd
\end_inset

.
 Esiste anche il comando 
\begin_inset Quotes eld
\end_inset

hostname
\begin_inset Quotes erd
\end_inset

, vediamo alcuni esempi applicativi:
\end_layout

\begin_layout Itemize
hostname //visualizza l'hostname corrente
\end_layout

\begin_layout Itemize
hostname nomeNuovoHostName //imposta un nuovo nome hostname temporaneo alla
 macchina, infatti al riavvio avremo ancora il nostro hostname precedente,
 per effettuare modifiche permanenti dovremo andare a modificare i file
 sopracitati
\end_layout

\begin_layout Subsubsection
Il file nsswitch.conf
\end_layout

\begin_layout Standard
Il 
\begin_inset Quotes eld
\end_inset

Name Service Switch
\begin_inset Quotes erd
\end_inset

 (NSS) è un meccanismo nei sistemi operativi Unix-Like che fornisce una
 varietà di sorgenti per configurazioni comuni di database e risoluzione
 di nomi.
 Il file nsswitch esiste quindi in tutte le distro, localizzato sempre nella
 stessa posizione cioè 
\begin_inset Quotes eld
\end_inset

/etc/nsswitch.conf
\begin_inset Quotes erd
\end_inset

, questo file regola la priorità che hanno le diverse configurazioni di
 diverse cose, ad esempio l'ordine con cui vengono gestiti i dns, o l'ordine
 con cui vengono gestiti altri servizi.
 Generalmente possiamo affermare che configura i name services del sistema
 operativo.
 Un' esempio esplicativo di riga potrebbe essere:
\end_layout

\begin_layout Itemize
hosts: files dns mdns4 //questa riga significa: per risolvere i dns prima
 guarda il file di configurazione di sistema 
\begin_inset Quotes eld
\end_inset

/etc/hosts
\begin_inset Quotes erd
\end_inset

, questo ha la priorità massima, nel caso dovessi avere problemi allora
 affidati al servizio dns (trovato 
\begin_inset Quotes eld
\end_inset

/etc.resolv.conf
\begin_inset Quotes erd
\end_inset

) e stessa cosa per 
\begin_inset Quotes eld
\end_inset

mdns4
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Un esempio di file di configurazione (con commenti esplicativi) potrebbe
 essere:
\end_layout

\begin_layout Standard
—————————————————————–
\end_layout

\begin_layout Standard
# The entry '[NOTFOUND=return]' means that the search for an 
\end_layout

\begin_layout Standard
# entry should stop if the search in the previous entry turned 
\end_layout

\begin_layout Standard
# up nothing.
 Note that if the search failed due to some other reason 
\end_layout

\begin_layout Standard
# (like no NIS server responding) then the search continues with the 
\end_layout

\begin_layout Standard
# next entry.
\end_layout

\begin_layout Standard
# Legal entries are:
\end_layout

\begin_layout Standard
# # nisplus Use NIS+ (NIS version 3) 
\end_layout

\begin_layout Standard
# nis Use NIS (NIS version 2), also called YP 
\end_layout

\begin_layout Standard
# dns Use DNS (Domain Name Service)
\end_layout

\begin_layout Standard
# files Use the local files 
\end_layout

\begin_layout Standard
# db Use the /var/db databases 
\end_layout

\begin_layout Standard
# [NOTFOUND=return] Ferma la ricerca se la entry non è trovata nel servizio
 appena specificato
\end_layout

\begin_layout Standard
passwd: files ldap 
\end_layout

\begin_layout Standard
shadow: files 
\end_layout

\begin_layout Standard
group: files ldap
\end_layout

\begin_layout Standard
hosts: dns nis files
\end_layout

\begin_layout Standard
ethers: files nis 
\end_layout

\begin_layout Standard
netmasks: files nis 
\end_layout

\begin_layout Standard
networks: files nis 
\end_layout

\begin_layout Standard
protocols: files nis 
\end_layout

\begin_layout Standard
rpc: files [NOTFOUND=return] nis 
\end_layout

\begin_layout Standard
services: files [NOTFOUND=return] nis
\end_layout

\begin_layout Standard
automount: files 
\end_layout

\begin_layout Standard
aliases: files
\end_layout

\begin_layout Standard
—————————————————————–
\end_layout

\begin_layout Standard
L'ordine dei servizi elencati determina l'ordina in cui NSS cercherà di
 usare questi servizi per resolvere query che vengono effettuate al sistema.
 Un programma utile nel caso avessimo un sistema di risoluzione DNS lento
 è quello di usare un computer come cache DNS, questo può essere fatto con
 programmi tipo 
\begin_inset Quotes eld
\end_inset

nscd
\begin_inset Quotes erd
\end_inset

 o meglio ancora 
\begin_inset Quotes eld
\end_inset

pdnsd
\begin_inset Quotes erd
\end_inset

 o 
\begin_inset Quotes eld
\end_inset

unbound
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsubsection
Il file /etc/services
\end_layout

\begin_layout Standard
Nel file /etc/services possiamo trovare la lista delle porte più comuni
 con i vari servizi associati, possiamo ad esempio effettuare:
\end_layout

\begin_layout Itemize
grep -iw 21 /etc/services //in questo caso ci viene mostrato a quale servizio
 viene solitamente (per convenzione) associato alla porta 21
\end_layout

\begin_layout Standard
altri esempi di utilizzo possono essere:
\end_layout

\begin_layout Itemize
grep ssh /etc/services //in questo caso ci viene mostrato su quale porta
 per convenzione girerebbe il servizio ssh
\end_layout

\begin_layout Subsection
Alcune informazioni utili su IPv4
\end_layout

\begin_layout Standard
Esistono alcune convenzioni che vengono seguite nell'assegnazioni di indirizzi
 in una rete:
\end_layout

\begin_layout Itemize
192.168.1.1 
\begin_inset Quotes eld
\end_inset

Default gateway
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
192.168.1.2 
\begin_inset Quotes eld
\end_inset

Firewall
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
192.168.1.5 
\begin_inset Quotes eld
\end_inset

DNS/Active Directory/LDAP
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
192.168.1.100 
\begin_inset Quotes eld
\end_inset

SNMP or Monitoring
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
192.168.1.255 
\begin_inset Quotes eld
\end_inset

Network Broadcast
\begin_inset Quotes erd
\end_inset

 (questo a differenza degli altri è uno standard)
\end_layout

\begin_layout Section
Strumenti per la sicurezza
\end_layout

\begin_layout Subsection
Sicurezza locale della macchina
\end_layout

\begin_layout Standard
Potrebbe essere utile di tanto in tanto lanciare alcuni comandi, per poter
 capire quali file per via di una configurazione sbagliata dei permessi
 potrebbero essere a rischio sulla nostra macchina.
 
\end_layout

\begin_layout Standard
Solitamente quello che potrebbe costituire un problema di sicurezza a livello
 di permessi potrebbe essere:
\end_layout

\begin_layout Itemize
impostazione del bit SUID per eseguibili non desiderati
\end_layout

\begin_layout Itemize
impostazione del bit SGID per eseguibili non desiderati
\end_layout

\begin_layout Itemize
file senza proprietario
\end_layout

\begin_layout Itemize
file senza gruppo di appartenenza
\end_layout

\begin_layout Itemize
link a file sconosciuti o sospetti
\end_layout

\begin_layout Standard
Vediamo alcuni esempi di comandi che possiamo lanciare ogni qualvolta volessimo
 verificare la sicurezza della macchina in termini di permessi:
\end_layout

\begin_layout Itemize
sudo find / -user root -perm -4000 -print //visualizza tutti i file, con
 il SUID impostato, questi file possono essere pericolosi in quanti vengono
 eseguiti da qualsiasi utente come se venissero lanciati dall'utente root
\end_layout

\begin_layout Itemize
sudo find / -group root -perm 2000 -print //visualizza tutti i file, con
 il SGID impostato, questi file possono essere pericolosi in quanti vengono
 eseguiti da qualsiasi utente come se venissero lanciati dal gruppo root
\end_layout

\begin_layout Itemize
sudo find / -nouser -print | more //visualizza i file senza proprietario,
 questi file possono costituire problemi per la sicurezza della macchina
\end_layout

\begin_layout Itemize
sudo find / -nogroup -print | more //visualizza i file senza gruppo, questi
 file possono costituire problemi per la sicurezza della macchina
\end_layout

\begin_layout Standard
Nota che anzichè utilizzare SUID ed SGID, un approccio migliore consigliato
 è quello di utilizzare 
\begin_inset Quotes eld
\end_inset

capabilities
\begin_inset Quotes erd
\end_inset

, possiamo saperne di più utilizzando:
\end_layout

\begin_layout Itemize
man capabilities
\end_layout

\begin_layout Standard
scenari di utilizzo sono ad esempio tcpdump/net perl library con la creazione
 di un gruppo, ad esempio se volessimo utilizzare determinate funzionalità
 della scheda di rete come il packet capturing senza però essere root.
\end_layout

\begin_layout Subsection
Antivirus
\end_layout

\begin_layout Paragraph
Premessa sugli antivirus nei sistemi GNU/Linux
\end_layout

\begin_layout Standard
Do you need a virus scanner on Linux/Unix?
\end_layout

\begin_layout Standard
Short answer, it depends on your situation.
\end_layout

\begin_layout Standard
Long answer: You might want to run a virus scanner on a server where files
 are uploaded, or where users login and manipulate files.
 Lets say you host a file upload site, you want to run a scan on the upload
 folder which auto removes infected files.
 It can also be that your mailserver runs Linux, but people sometimes mail
 executables or infected pdf files.
 Then you also want a scanner.
 Or you might run a source control server (gitolite, mercurial) where sometimes
 binary files are checked in.
 (although ClamAV might not find things in bare-git repositories, only in
 working directories.)
\end_layout

\begin_layout Standard
If you however only run a static HTML website, or an rsync backup server,
 or a Rougelike via telnet, where there are no uploads or like, you might
 be wasting resources.
\end_layout

\begin_layout Standard
My advice is to look at your situation and then decide if you need ClamAV,
 and if you only need to scan a few folders, the entire system and if you
 want to auto-remove the virusses or not.
\end_layout

\begin_layout Subsubsection
ClamAV Antivirus
\end_layout

\begin_layout Standard
Uno dei più famosi antivirus per i sistemi GNU/Linux è ClamAV, possiamo
 installarlo attraverso 
\end_layout

\begin_layout Itemize
apt-get install clamav //installa clamav, la base e le librerie e l'aggiornatore
 di virus
\end_layout

\begin_layout Itemize
apt-get install clamav-daemon //installa il demone di clamav
\end_layout

\begin_layout Standard
Un programma importante che viene installato con clamAV è 
\begin_inset Quotes eld
\end_inset

freshclam
\begin_inset Quotes erd
\end_inset

 che si occupa di tenere aggiornato il database dei virus, e automaticamente
 si aggiorna una volta al giorno, almenochè non venga richiesto un aggiornamento
 manualmente.
 Possiamo startare il demone dell'antivirus attraverso:
\end_layout

\begin_layout Itemize
service clamav-daemon start //abilita il demone di clamav, a differenza
 della distro è anche possibile effettuare questa operazione attraverso
 
\begin_inset Quotes eld
\end_inset

systemctl enable clamav-daemon
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
L'antivirus clamAV possiede diversi front-end ma di per se non è un virus
 in tempo reale, questa caratteristica gli permette di non essere invasivo.
 Vediamo alcuni esempi di comandi:
\end_layout

\begin_layout Itemize
clamscan -r /home/andrea //esegue una scansione nella directory 
\begin_inset Quotes eld
\end_inset

/home/andrea
\begin_inset Quotes erd
\end_inset

 attraverso il flag 
\begin_inset Quotes eld
\end_inset

-r
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
clamscan -r –bell -i /home //esegue una scansione nella directory 
\begin_inset Quotes eld
\end_inset

/home
\begin_inset Quotes erd
\end_inset

 attraverso il flag 
\begin_inset Quotes eld
\end_inset

-r
\begin_inset Quotes erd
\end_inset

 e se trova dei virus li elenca con 
\begin_inset Quotes eld
\end_inset

-i
\begin_inset Quotes erd
\end_inset

 e fa sounare una campana 
\begin_inset Quotes eld
\end_inset

–bell
\begin_inset Quotes erd
\end_inset

 nel caso di ritrovamento virus
\end_layout

\begin_layout Itemize
clamscan -r –remove –bell -i /home //è uguale al comando precedente ma grazie
 all'opzione 
\begin_inset Quotes eld
\end_inset

–remove
\begin_inset Quotes erd
\end_inset

 rimuove i virus se ne trova
\end_layout

\begin_layout Itemize
clamscan -r –move=/home/andrea/.infectedFiles –bell -i /home //è uguale al
 comando precedente ma anzichè rimuovere i virus grazie all'opzione 
\begin_inset Quotes eld
\end_inset

–move
\begin_inset Quotes erd
\end_inset

 sposta i file all'interno di una specifica directory
\end_layout

\begin_layout Standard
Per eseguire un aggiornamento manuale del database dei virus si effettua:
\end_layout

\begin_layout Itemize
sudo /etc/init.d/clamav-freshclam restart 
\end_layout

\begin_layout Standard
E' buona norma eseguire periodicamente attraverso il sistema Cron scansioni
 di determinate directory\SpecialChar endofsentence

\end_layout

\begin_layout Subsection
Rootkit
\end_layout

\begin_layout Standard
Un rootkit, termine letteralmente traducibile in lingua italiana con equipaggiam
ento da amministratore (in ambiente Unix per "root" access si intende accesso
 di livello amministrativo), in informatica, è un programma software prodotto
 per avere il controllo sul sistema senza bisogno di autorizzazione da parte
 di un utente o di un amministratore.
 Recentemente alcuni virus informatici si sono avvalsi della possibilità
 di agire come rootkit (processo, file, chiave di registro, porta di rete)
 all'interno del sistema operativo.
\end_layout

\begin_layout Subsubsection
chkrootkit
\end_layout

\begin_layout Standard
Un programma abbastanza comune su sistemi Unix-based è 
\begin_inset Quotes eld
\end_inset

chkrootkit
\begin_inset Quotes erd
\end_inset

 (Check Rootkit) che permette agli amministratori di rivelare la presenza
 di alcuni noti rootkit.
 Vediamo subito alcuni esempi:
\end_layout

\begin_layout Itemize
sudo chkrootkit //esegue una scansione del sistema
\end_layout

\begin_layout Subsection
Linux Security Auditing Tool (LSAT)
\end_layout

\begin_layout Standard
Il Linux Security Auditing Tool (LSAT) è uno strumento per la sicurezza
 molto importante e dovrebbe essere installato sempre, soprattutto quando
 avviene l'installazione e la configurazione di una macchina server.
 LSAT è uno strumento atto ad effettuare una serie di controlli su file
 di configurazione di sistema e sulla rete locale o sul sistema per comuni
 errori di configurazione che possono ledere la sicurezza del sistema o
 per pacchetti che non sono necessari.
 Per installarlo eseguiamo:
\end_layout

\begin_layout Itemize
apt-get install lsat
\end_layout

\begin_layout Standard
Vediamo ora invece alcuni esempi applicativi:
\end_layout

\begin_layout Itemize
lsat //esegue una scansione del sistema per errori nei file di configurazione
 che potrebbero ledere la sicurezza della macchina
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
in automatico dopo la scansione viene creato un file chiamato 
\begin_inset Quotes eld
\end_inset

lsat.out
\begin_inset Quotes erd
\end_inset

, è da notare che il check di un modulo chiamato 
\begin_inset Quotes eld
\end_inset

md5
\begin_inset Quotes erd
\end_inset

 potrebbe richiedere molto molto tempo, possiamo quindi terminarla con 
\begin_inset Quotes eld
\end_inset

Ctrl+C
\begin_inset Quotes erd
\end_inset

, la scansione di questo modulo è consigliata solo la prima volta, poi viene
 rieseguita in genere solo se avvengono significativi cambiamenti sul sistema
\end_layout

\end_deeper
\begin_layout Itemize
lsat -o mioFile.out -m debian -x modules.exclude //in questo esempio, avviene
 una scansione del sistema, ma l'output 
\begin_inset Quotes eld
\end_inset

-o
\begin_inset Quotes erd
\end_inset

 non viene messo in 
\begin_inset Quotes eld
\end_inset

lsat.out
\begin_inset Quotes erd
\end_inset

 ma in 
\begin_inset Quotes eld
\end_inset

mioFile.out
\begin_inset Quotes erd
\end_inset

, inoltre indichiamo che la nostra distro 
\begin_inset Quotes eld
\end_inset

-m
\begin_inset Quotes erd
\end_inset

 è Debian, in questo modo riusciamo ad ottenere un controllo maggiore sul
 comando, poi indichiamo con 
\begin_inset Quotes eld
\end_inset

-x
\begin_inset Quotes erd
\end_inset

 di escludere nel controllo i moduli inclusi nel file 
\begin_inset Quotes eld
\end_inset

modules.exclude
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
lsat -m debian -w output.html //in questo esempio eseguiamo una scansione
 su una distro Debian, specificandolo col flag 
\begin_inset Quotes eld
\end_inset

-m
\begin_inset Quotes erd
\end_inset

 e inoltre l'output viene salvato in un file html chiamato 
\begin_inset Quotes eld
\end_inset

output.html
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Una lista dei moduli utilizzati è possibile consultare 
\begin_inset CommandInset href
LatexCommand href
name "Lista Moduli LSAT"
target "http://www.ubuntugeek.com/linux-security-auditing-tool-lsat-post-install-security-auditing-tool.html"

\end_inset

.
\end_layout

\begin_layout Subsection
Cracking di Password
\end_layout

\begin_layout Standard
Talvolta è buona norma provare ad effettuare crack delle password degli
 utenti sul nostro sistema, in modo da capire se possono esserci vulnerabilità,
 uno strumento molto utilizzato è 
\begin_inset Quotes eld
\end_inset

John the Ripper
\begin_inset Quotes erd
\end_inset

, anche se esistono alternative come 
\begin_inset Quotes eld
\end_inset

hashcat
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsubsection
John the Ripper
\end_layout

\begin_layout Standard
Per installare 
\begin_inset Quotes eld
\end_inset

John the Ripper
\begin_inset Quotes erd
\end_inset

, eseguiamo:
\end_layout

\begin_layout Itemize
sudo apt-get install john john-data
\end_layout

\begin_layout Standard
una volta installato, dovremo trovare un file che contiene parole, i cosiddetti
 file di 
\begin_inset Quotes eld
\end_inset

wordlist
\begin_inset Quotes erd
\end_inset

, in quanto questo strumento di password cracking utilizza la tecnica 
\begin_inset Quotes eld
\end_inset

brute force
\begin_inset Quotes erd
\end_inset

, cioè prova tutte le parole contenute nella wordlist, john the ripper di
 default senza wordlist non è efficiente in quanto prova solo poche combinazioni
 con codici alfanumerici.
 Una wordlist di dimensioni contenute ma comunque abbastanza efficiente
 può ad esempio essere 
\begin_inset CommandInset href
LatexCommand href
name "Wordlist"
target "http://download.openwall.net/pub/wordlists/all.gz"

\end_inset

.
 Una volta scaricata la wordlist, nel nostro caso dovremo eseguire per scompatta
rla:
\end_layout

\begin_layout Itemize
gunzip all.gz //scompatta la wordlist
\end_layout

\begin_layout Standard
Ora, consideriamo un utente chiamato 
\begin_inset Quotes eld
\end_inset

testuser
\begin_inset Quotes erd
\end_inset

 presente sulla macchina con propria password, John the ripper per lavorare
 ha bisogno di un file formattato in una modalità specifica, per poter adempiere
 a questa formattazione allora eseguiamo:
\end_layout

\begin_layout Itemize
sudo unshadow /etc/passwd /etc/shadow > password.list //crea il file password.list
 leggibile da John, ricorda che il programma unshadow viene installato con
 l'installazione di john the ripper
\end_layout

\begin_layout Standard
Ora vediamo alcuni esempi di cracking di password:
\end_layout

\begin_layout Itemize
touch john.ini //prima di eseguire john dobbiamo creare un file di configurazione
, anche se vuoto, quest'ultimo è richiesto necessariamente per l'esecuzione
\end_layout

\begin_layout Itemize
john -users:-testuser -wordlist:all password.list //in questo esempio eseguiamo
 un cracking della password sull'utente chiamato 
\begin_inset Quotes eld
\end_inset

testuser
\begin_inset Quotes erd
\end_inset

, utilizzando la wordlist chiamata 
\begin_inset Quotes eld
\end_inset

all
\begin_inset Quotes erd
\end_inset

 e utilizzando il file chiamato 
\begin_inset Quotes eld
\end_inset

password.list
\begin_inset Quotes erd
\end_inset

 generato precedentemente attraverso 
\begin_inset Quotes eld
\end_inset

unshadow
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
john –show -wordlist:all password.list //in questo caso viene eseguito un
 tentativo di cracking di tutte le password e l'opzione 
\begin_inset Quotes eld
\end_inset

–show
\begin_inset Quotes erd
\end_inset

 serve ad indicare il fatto, di mostrare le password trovate a fine operazione
\end_layout

\begin_layout Standard
Se conosciamo un determinato utente, possiamo aggiungere determinate parole
 al file wordlist, in modo da rendere più probabile la scoperta della password.
 Per altri esempi di utilizzo di 
\begin_inset Quotes eld
\end_inset

John the Ripper
\begin_inset Quotes erd
\end_inset

 è consigliata la visualizzazione della pagina web 
\begin_inset CommandInset href
LatexCommand href
name "John The Ripper: Esempi di Utilizzo"
target "http://www.openwall.com/john/doc/EXAMPLES.shtml"

\end_inset

.
\end_layout

\begin_layout Subsection
Nmap
\end_layout

\begin_layout Standard
Il programma 
\begin_inset Quotes eld
\end_inset

nmap
\begin_inset Quotes erd
\end_inset

 è utilizzato per effettuare scansioni di rete (network scanning), quindi
 avere informazioni sulla rete a cui la nostra macchina è collegata.
 Per installare nmap, eseguiamo:
\end_layout

\begin_layout Itemize
apt-get install nmap sysstat
\end_layout

\begin_layout Standard
Vediamo ora alcuni esempi applicativi, tenendo a mente che dove non viene
 specificato un port-range, nmap esegue una scansione solo sulle 1000 porte
 più utilizzate (che comunque costituiscono solo 1.5% della totalità delle
 possibilità):
\end_layout

\begin_layout Itemize
nmap localhost //esegue uno scan sul localhost, e determina quali porte
 sono aperte, di default, nmap scansiona le 1000 porte più usate, quindi
 la scansione non avviene su tutte le porte
\end_layout

\begin_layout Itemize
nmap -p22 localhost //verifica se la porta 22 è aperta su localhost
\end_layout

\begin_layout Itemize
nmap -p1-80 localhost //verifica quali porte sono aperte, considerando il
 range dalla porta 1 alla porta 80
\end_layout

\begin_layout Itemize
nmap -p22,23,80,443, 389, 3489,4000 192.168.1.173 //verifica se le porte 22(ssh),
 23(telnet), 80(http), 443(https), 389(ldap), 3489, 4000 sono aperte all'indiriz
zo 192.168.1.173
\end_layout

\begin_layout Itemize
nmap 192.168.1.104 //esegue una scansione all'ip 192.168.1.104 sulle porte di
 default
\end_layout

\begin_layout Itemize
nmap -p 1-65535 192.168.1.193 //esegue una scansione su TUTTE le porte all'indirizz
o 192.168.1.193
\end_layout

\begin_layout Itemize
nmap 192.168.1.0/24 //esegue una scansione a tutti gli ip della rete 192.168.1.0
 con subnet mask 255.255.255.0
\end_layout

\begin_layout Itemize
nmap -sP 192.168.1.0/24 > results.txt //esegue una scansione di tipo 
\begin_inset Quotes eld
\end_inset

Ping
\begin_inset Quotes erd
\end_inset

, in modo da visualizzare quali host esistono nella rete con indirizzo 192.168.1.0
 con subnet mask 255.255.255.0, i risultati vengono salvati poi nel file 
\begin_inset Quotes eld
\end_inset

results.txt
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
nmap -p1-340 -sV 192.168.1.250 //esegue una scansione delle porte dalla 1 alla
 340 sull'indirizzo IP 192.168.1.250 e mostra il servizio attivo e la relativa
 versione sulle specifiche porte aperte
\end_layout

\begin_layout Itemize
nmap -O 192.168.1.250 //cerca di capire il sistema operativo utilizzato dalla
 macchina all'indirizzo IP 192.168.1.250
\end_layout

\begin_layout Itemize
nmap -oA scanresults 192.168.1.105 //anzichè mostrare i risultati solo sullo
 standard output, li salva anche all'interno di file di testo che iniziano
 per 
\begin_inset Quotes eld
\end_inset

scanresults
\begin_inset Quotes erd
\end_inset

, salva 3 file di testo
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
il primo, è in formato human-readable
\end_layout

\begin_layout Itemize
il secondo, è in formato facilmente utilizzabile con grep
\end_layout

\begin_layout Itemize
il terzo, è in formato xml
\end_layout

\end_deeper
\begin_layout Itemize
nmap -vv -oA scanresults 192.168.1.250 //esegue la stessa cosa del precedente
 ma include più informazioni attraverso una modalità verbose, è possibile
 ottenere ancora più informazioni inserendo 
\begin_inset Quotes eld
\end_inset

-vvv
\begin_inset Quotes erd
\end_inset

 come flag al posto di 
\begin_inset Quotes eld
\end_inset

-vv
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
E' da ricordare che nmap è più utilizzato per test su macchine remote, mentre
 sono molto più efficienti sulla macchina stessa strumenti come netstat,
 sockstat ed fstat.
\end_layout

\begin_layout Subsection
Wireshark
\end_layout

\begin_layout Standard
Il programma wireshark è un packet-analyzer, e risulta molto utile quando
 vogliamo capire cosa sta succedendo nella rete a cui siamo connessi o per
 capire e risolvere determinati problemi di rete (legati ad esempio alla
 congestione della rete).
 Possiamo installare wireshark attraverso:
\end_layout

\begin_layout Itemize
sudo apt-get install wireshark
\end_layout

\begin_layout Standard
Una volta installato, abbiamo bisogno di impostare l'interfaccia di rete
 utilizzata in modalità 
\begin_inset Quotes eld
\end_inset

promiscua
\begin_inset Quotes erd
\end_inset

, questo ci permetterà di sniffare tutti i pacchetti che girano nell'ethernet
 e non solo quelli diretti a noi.
 Possiamo avviare l'applicazione lanciando:
\end_layout

\begin_layout Itemize
wireshark //lancia wireshark, un'alternativa è 
\begin_inset Quotes eld
\end_inset

wireshark &
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
E' utile utilizzare la risoluzione degli indirizzi IP, attraverso le impostazion
i, abilitando la voce 
\begin_inset Quotes eld
\end_inset

Enable network name resolution
\begin_inset Quotes erd
\end_inset

, altri strumenti utili sono i filtri, possiamo usare filtri per selezionare
 ad esempio i protocolli che vogliamo monitorare o ad esempio solo cookie,
 eccetera.
\end_layout

\begin_layout Standard
Un test di sicurezza per la rete potrebbe essere chiedere al mantenitore
 dell'infrastruttura di rete (e.g., Network Engineer) il traffico ammesso,
 ad esempio ipotizziamo il traffico in uscita ammesso sia verso la porta
 80, 443 (http/https) e sulla porta 389 (LDAP), allora possiamo inserire
 come filtro:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

not (tcp.port==80) and not (tcp.port==443) and not (tcp.port==389)
\end_layout

\end_inset

ovviamente ci sono configurazioni più avanzate, ma per tutto il resto è
 una buona idea impratichirsi con la costruzione di filtri di wireshark.
\end_layout

\begin_layout Standard
Un display filter utile per fare detection di arp poisoning è:
\end_layout

\begin_layout Itemize
arp.duplicate-address-detected
\end_layout

\begin_layout Subsection
Tcpdump
\end_layout

\begin_layout Standard
Tcpdump costituisce un'ottima alternativa a wireshark, molto più frequente
 tra chi si occupa di sicurezza informatica, essendo un programma che offre
 molte possibilità, vedremo solo alcuni comandi d'esempio, e andremo ad
 arricchire mano a mano il lancio del comando:
\end_layout

\begin_layout Itemize
tcpdump -D //mostra l'elenco delle interfacce disponibili per catturare
 pacchetti
\end_layout

\begin_layout Itemize
tcpdump -i any //cattura pacchetti su qualsiasi interfaccia di rete, il
 flag 
\begin_inset Quotes eld
\end_inset

-i
\begin_inset Quotes erd
\end_inset

 è utilizzato per indicare l'interfaccia di rete
\end_layout

\begin_layout Itemize
tcpdump -i wlan0 //cattura pacchetti sull'interfaccia di rete wlan0
\end_layout

\begin_layout Itemize
tcpdump -i wlan0 -n //non risolve gli hostname, mostrando gli indirizzi
 IP grazie al flag 
\begin_inset Quotes eld
\end_inset

-n
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
tcpdump -i wlan0 -nn //non risolve gli hostname e i nomi dei servizi associati
 alle porte più comuni
\end_layout

\begin_layout Itemize
tcpdump -i wlan0 -nn -q //è più quiet (quindi meno verbose), con il flag
 
\begin_inset Quotes eld
\end_inset

-q
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
tcpdump -i wlan0 -nn -q -t //non stampa il timestamp col flag 
\begin_inset Quotes eld
\end_inset

-t
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
tcpdump -i wlan0 -nn -q -tttt //stampa un timestamp più completo contenente
 anche la data utilizzando il flag 
\begin_inset Quotes eld
\end_inset

-tttt
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
tcpdump -i wlan0 -nn -q -X //è conciso sulle informazioni di testa del pacchetto
 
\begin_inset Quotes eld
\end_inset

-q
\begin_inset Quotes erd
\end_inset

 ma stampa anche il contenuto di ogni pacchetto 
\begin_inset Quotes eld
\end_inset

-X
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
tcpdump -i wlan0 -nn -X //stampa informazioni sul pacchetto di default +
 contenuto
\end_layout

\begin_layout Itemize
tcpdump -i wlan0 -nn -v –number//mostra più informazioni, il flag 
\begin_inset Quotes eld
\end_inset

-v
\begin_inset Quotes erd
\end_inset

 sta per verbose, e possiamo essere ancora più verbose utilizzando 
\begin_inset Quotes eld
\end_inset

-vv
\begin_inset Quotes erd
\end_inset

 o 
\begin_inset Quotes eld
\end_inset

-vvv
\begin_inset Quotes erd
\end_inset

, a differenza di quante informazioni vogliamo sui pacchetti, numera i pacchetti
\end_layout

\begin_layout Itemize
tcpdump -i wlan0 -nn -v -e –number//in questo modo mostriamo anche le informazio
ni sull'header ethernet, utile ad esempio per visualizzare indirizzi MAC,
 inoltre numera i pacchetti
\end_layout

\begin_layout Itemize
tcpdump -i wlan0 -nn -v -e -X -c10 //cattura pacchetti includendo più informazio
ni 
\begin_inset Quotes eld
\end_inset

-v
\begin_inset Quotes erd
\end_inset

 (incluse quelle relative all'header ethernet 
\begin_inset Quotes eld
\end_inset

-e
\begin_inset Quotes erd
\end_inset

), cattura anche il contenuto dei pacchetti 
\begin_inset Quotes eld
\end_inset

-X
\begin_inset Quotes erd
\end_inset

 ma cattura solo 10 pacchetti grazie al flag 
\begin_inset Quotes eld
\end_inset

-c
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
tcpdump -i wlan0 -vvv -tttt -nn -e -X -w capture_file.pcap //esegue una scansione
, salvando anche informazioni su header ethernet 
\begin_inset Quotes eld
\end_inset

-e
\begin_inset Quotes erd
\end_inset

 e sul contenuto 
\begin_inset Quotes eld
\end_inset

-X
\begin_inset Quotes erd
\end_inset

 in un file 
\begin_inset Quotes eld
\end_inset

.pcap
\begin_inset Quotes erd
\end_inset

 grazie al flag 
\begin_inset Quotes eld
\end_inset

-w
\begin_inset Quotes erd
\end_inset

, questo è utile per fare analisi a posteriori
\end_layout

\begin_layout Itemize
tcpdump -r capture_file.pcap //con il flag 
\begin_inset Quotes eld
\end_inset

-r
\begin_inset Quotes erd
\end_inset

 riusciamo a leggere ed analizzare un file .pcap
\end_layout

\begin_layout Itemize
tcpdump -r capture_file.pcap -X //anche in modalità lettura si applicano
 gli stessi flag, quindi possiamo ad esempio visualizzare il contenuto dei
 pacchetti col flag 
\begin_inset Quotes eld
\end_inset

-X
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Queste sono solo alcuni flag di base di tcpdump, ma il cuore è costituito
 dalla possibilità di inserire capture filters che utilizzano la notazione
 
\begin_inset Quotes eld
\end_inset

Berkeley Packet Filter
\begin_inset Quotes erd
\end_inset

 notation, vediamo qualche esempio di filtro:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

src 2.3.4.5 # cattura solo il traffico che ha come sorgente l'ip specificato
\end_layout

\begin_layout Plain Layout

dst 3.4.5.6 # cattura solo il traffico che ha come destinazione l'ip specificato
\end_layout

\begin_layout Plain Layout

net 1.2.3.0/24 # cattura solo il traffico appartenente alla rete specificata
\end_layout

\begin_layout Plain Layout

port 3600
\end_layout

\begin_layout Plain Layout

src port 3333
\end_layout

\begin_layout Plain Layout

icmp
\end_layout

\begin_layout Plain Layout

ip6
\end_layout

\begin_layout Plain Layout

portrange 21-23
\end_layout

\begin_layout Plain Layout

less 32 # cattura solo pacchetti più piccoli di 32 byte
\end_layout

\begin_layout Plain Layout

greater 64 # cattura solo pacchetti più grandi di 64 byte
\end_layout

\begin_layout Plain Layout

<= 128 # cattura solo pacchetti più piccoli o uguali alla dimensione di
 128 byte
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# possiamo combinare filtri con operatori come and (o &&), or (o ||) o not
 (o !)
\end_layout

\begin_layout Plain Layout

dst 192.168.0.2 and src net and not icmp
\end_layout

\begin_layout Plain Layout

src 10.0.2.4 and (dst port 3389 or 22)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Vediamo un semplice esempio di come unire questi filtri con i flag visti
 prima:
\end_layout

\begin_layout Itemize
tcpdump -i wlan0 -nn -X -w capture_file.pcap 'port 80' //combiniamo diverse
 opzioni e utilizziamo un filtro in BPFN, gli apici sono opzionali, ma per
 questioni di leggibilità preferisco inserirli, in modo da separare il filtro
 in BPFN dal resto dei flag
\end_layout

\begin_layout Itemize
tcpdump -i wlan0 -vvv -tttt -nn -e -X -w capture_file.pcap 'src 10.0.2.4 and
 (dst port 3389 or 22)'
\end_layout

\begin_layout Standard
vediamo alcuni esempi per isolare specifici pacchetti TCP con determinati
 flag:
\end_layout

\begin_layout Itemize
tcpdump 'tcp[13] & 32!=0' //mostrami solo i pacchetti con il flag URG settato
\end_layout

\begin_layout Itemize
tcpdump 'tcp[13] & 16!=0' //mostrami solo i pacchetti con il flag ACK settato
\end_layout

\begin_layout Itemize
tcpdump 'tcp[13] & 8!=0' //mostrami solo i pacchetti con il flag PSH settato
\end_layout

\begin_layout Itemize
tcpdump 'tcp[13] & 4!=0' //mostrami solo i pacchetti con il flag RST settato
\end_layout

\begin_layout Itemize
tcpdump 'tcp[13] & 2!=0' //mostrami solo i pacchetti con il flag SYN settato
\end_layout

\begin_layout Itemize
tcpdump 'tcp[13] & 1!=0' //mostrami solo i pacchetti con il flag FIN settato
\end_layout

\begin_layout Itemize
tcpdump 'tcp[13]=18' //mostrami solo i pacchetti SYN/ACK
\end_layout

\begin_layout Standard
comunque esistono anche notazioni funzionalmente analoghe ma più semplici
 da leggere come ad esempio:
\end_layout

\begin_layout Itemize
tcpdump 'tcp[tcpflags] == tcp-syn'
\end_layout

\begin_layout Itemize
tcpdump 'tcp[tcpflags] == tcp-rst'
\end_layout

\begin_layout Itemize
tcpdump 'tcp[tcpflags] == tcp-fin'
\end_layout

\begin_layout Standard
Altri filtri utili in reti con macchine Windows, è evitare questi protocolli
 (smb || nbns || dcerpc || nbss || dns).
\end_layout

\begin_layout Standard
Possiamo fare diverse prove con tcpdump, magari mettendoci in ascolto su
 una porta specifica e provando a mandare traffico, con specifici programmi,
 oppure con netcat.
 Una combinazione interessante è accoppiare tcpdump con un packet crafter
 (e.g., scapy), e farli comunicare su una porta specifica magari sull'interfaccia
 di loopback, in modo da poter fare tutti i nostri esperimenti.
\end_layout

\begin_layout Standard
Possiamo anche utilizzare tcpdump per fare detection di arp poisoning, ad
 esempio guardando dispositivi che seguono questa logica:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

192.168.1.100 is 00:00:00:00
\end_layout

\begin_layout Plain Layout

192.168.1.100 is ff:ff:ff:ff
\end_layout

\end_inset

cioè se lo stesso IP compare con due indirizzi MAC diversi in breve tempo,
 allora la situazione è sospettosa e probabilmente ci troviamo in una situazione
 di ARP cache poisoning.
 In genere se questo comportamento è associato all'indirizzo di un gateway
 allora MOLTO probabilmente siamo in una situazione di ARP cache poisoning.
\end_layout

\begin_layout Subsubsection
Eseguire tcpdump e tante altre utility senza permessi di root
\end_layout

\begin_layout Itemize
groupadd pcap
\end_layout

\begin_layout Itemize
usermod -a -G pcap giuseppe //sostituire giuseppe col nome utente
\end_layout

\begin_layout Itemize
chgrp pcap /usr/sbin/tcpdump
\end_layout

\begin_layout Itemize
chmod 750 /usr/sbin/tcpdump
\end_layout

\begin_layout Itemize
setcap cap_net_raw,cap_net_admin=eip /usr/sbin/tcpdump
\end_layout

\begin_layout Itemize
ln -s /usr/sbin/tcpdump /usr/local/bin/tcpdump
\end_layout

\begin_layout Standard
a volte (quindi solo su alcune distro ad esempio su alcune OpenSUSE) è anche
 necessario aggiungere in alcune distribuzioni l'opzione 
\begin_inset Quotes eld
\end_inset

file_caps=1
\begin_inset Quotes erd
\end_inset

 come kernel line nel boot manager.
 
\end_layout

\begin_layout Standard
Una volta eseguite queste operazioni, nel caso volessimo ad esempio usare
 scapy, quello che dobbiamo fare è assegnare le capabilities a python e
 a scapy, con:
\end_layout

\begin_layout Itemize
setcap cap_net_raw=eip /path/to/pythonX.X
\end_layout

\begin_layout Itemize
setcap cap_net_raw=eip /path/to/scapy
\end_layout

\begin_layout Standard
un altro esempio è quello di dare capabilities a perl per la cattura di
 pacchetti eccetera.
\end_layout

\begin_layout Subsection
IpTables (Firewall)
\end_layout

\begin_layout Standard
Il programma IpTables un'interfaccia per gli amministratori di sistema vincolata
 al kernel Linux e costituisce un programma di gestione 
\begin_inset Quotes eld
\end_inset

firewall
\begin_inset Quotes erd
\end_inset

 per sistemi GNU/Linux.
 Nei sistemi Debian based, esistono delle applicazioni di front-end come
 ad esempio 
\begin_inset Quotes eld
\end_inset

ufw
\begin_inset Quotes erd
\end_inset

 non esistono script o eseguibili per lanciare iptables, mentre su distro
 Red-Hat based esistono degli script nella directory /etc/init.d/, possiamo
 visualizzarli con: 
\begin_inset Quotes eld
\end_inset

ls -al /etc/init.d/ip*
\begin_inset Quotes erd
\end_inset

, e possiamo quindi iniziare il processo con:
\end_layout

\begin_layout Itemize
sudo service iptables start //inizia il processo iptables
\end_layout

\begin_layout Itemize
sudo service iptables stop
\end_layout

\begin_layout Standard
Nelle distro Debian-based invece si abilita il firewall attraverso:
\end_layout

\begin_layout Itemize
sudo ufw enable
\end_layout

\begin_layout Standard
e si può verificare lo stato del firewall con:
\end_layout

\begin_layout Itemize
sudo ufw status
\end_layout

\begin_layout Standard
inoltre i log di ufw vengono salvati in 
\begin_inset Quotes eld
\end_inset

/var/log/ifw.log
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Vediamo ora, una volta installato e avviato iptables, alcuni comandi da
 utilizzare:
\end_layout

\begin_layout Itemize
iptables -L //elenca le regole presenti sul firewall, in output, in input
 e in forwarding
\end_layout

\begin_layout Standard
Per isolare completamente un computer dalla rete, eseguiamo:
\end_layout

\begin_layout Itemize
iptables -P INPUT DROP //disabilita su tutte le porte richieste di input
\end_layout

\begin_layout Itemize
iptables -P OUTPUT DROP //disabilita il traffico di output su tutte le porte
\end_layout

\begin_layout Itemize
iptables -P FORWARDING DROP //disabilita l'inoltro dei pacchetti su tutte
 le porte
\end_layout

\begin_layout Standard
mentre per abilitare ad esempio la porta 
\begin_inset Quotes eld
\end_inset

22
\begin_inset Quotes erd
\end_inset

 per il con TCP, in ingresso eseguiamo:
\end_layout

\begin_layout Itemize
iptables -A INPUT -p tcp –dport 22 -j ACCEPT
\end_layout

\begin_layout Standard
mentre per abilitare il traffico di uscita sulla stessa porta sempre con
 TCP, eseguiamo:
\end_layout

\begin_layout Itemize
iptables -A OUTPUT -p tcp –sport 22 -j ACCEPT
\end_layout

\begin_layout Standard
Comandi utili per salvare e caricare le configurazioni sono:
\end_layout

\begin_layout Itemize
iptables-save > fileName //salva la configurazione attuale in un file
\end_layout

\begin_layout Itemize
iptables-restore < fileName //ripristina la configurazione salvata in fileName
\end_layout

\begin_layout Standard
Un'altro programma che fa da interfaccia front-end per iptables molto utilizzato
 e con ottima documentazione è 
\begin_inset Quotes eld
\end_inset

shorewall
\begin_inset Quotes erd
\end_inset

, inoltre per salvare la configurazione, si può installare 
\begin_inset Quotes eld
\end_inset

iptables-persistent
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Per cancellare regole facciamo:
\end_layout

\begin_layout Itemize
sudo iptables -F //si cancellano tutte le regole
\end_layout

\begin_layout Subsection
Hosts Deny e Hosts Allow (Deprecati)
\end_layout

\begin_layout Standard
Dei file che costituiscono una blacklist (o whitelist) per le connessioni
 sono i file 
\begin_inset Quotes eld
\end_inset

hosts.allow
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

hosts.deny
\begin_inset Quotes erd
\end_inset

, questi file venivano usati come firewall, ma oggigiorno non costituiscono
 un buon firewall, in quanto iptables è un meccanismo più a basso livello
 ed è più sicuro, riuscendo a negare direttamente i tentativi di connessione,
 mentre questi due file permettono lo scambio di informazioni con un altro
 host fino a quando non si scopre che l'host è nella blacklist (o la whitelist);
 pertanto non vengono usati come firewall.
 
\end_layout

\begin_layout Paragraph
Principio di funzionamento di hosts.allow e hosts.deny
\end_layout

\begin_layout Standard
Questi due file, hanno un ordine di lettura, viene prima letto 
\begin_inset Quotes eld
\end_inset

hosts.allow
\begin_inset Quotes erd
\end_inset

 e successivamente 
\begin_inset Quotes eld
\end_inset

hosts.deny
\begin_inset Quotes erd
\end_inset

, quindi dobbiamo fare attenzione a non scrivere impostazioni che possono
 andare in conflitto.
 Configurare questi file è molto semplice comunque, prendiamo come esempio
 
\begin_inset Quotes eld
\end_inset

hosts.allow
\begin_inset Quotes erd
\end_inset

, basta scrivere:
\end_layout

\begin_layout Standard
——————————————————————————-
\end_layout

\begin_layout Standard
ssh: LOCAL 192.168.1.195 #imponiamo il diritto di potersi connettere in ssh
 all'indirizzo ip indicato, il servizio ssh, su sistemi RH-based è sshd
\end_layout

\begin_layout Standard
——————————————————————————-
\end_layout

\begin_layout Standard
avremmo potuto scrivere altrimenti nel file 
\begin_inset Quotes eld
\end_inset

hosts.deny
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Standard
——————————————————————————-
\end_layout

\begin_layout Standard
ssh: ALL EXCEPT 192.168.1.195 #imponiamo il diritto di potersi connettere in
 ssh all'indirizzo ip indicato e lo neghiamo a tuti gli altri indirizzi
 IP
\end_layout

\begin_layout Standard
——————————————————————————-
\end_layout

\begin_layout Standard
Al posto di ssh, avremmo potuto inserire 
\begin_inset Quotes eld
\end_inset

httpd
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

mysqld
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

ALL
\begin_inset Quotes erd
\end_inset

, e tanti altri servizi.
 Una volta effettuate le modifiche, dobbiamo riavviare i servizi coinvolti
 nella modifica, o riavviare semplicemente il sistema.
\end_layout

\begin_layout Subsection
Netstat
\end_layout

\begin_layout Standard
Il programma netstat è molto utile per monitorare la rete sul nostro sistema.
 Vediamo alcuni esempi applicativi:
\end_layout

\begin_layout Itemize
netstat -a | more //elenca tutte le porte (listening e non listening)
\end_layout

\begin_layout Itemize
netstat -at | more //elenca tutte le porte tcp
\end_layout

\begin_layout Itemize
netstat -t | more //elenca tutte le porte tcp in uno stato aperto ma non
 in listening (come ad esempio 
\begin_inset Quotes eld
\end_inset

established
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Itemize
netstat -au | more //elenca tutte le porte udp
\end_layout

\begin_layout Itemize
netstat -aw | more //mostra tutte le porte RAW
\end_layout

\begin_layout Itemize
netstat -ax | more //mostra tutte le porte unix usate per l'IPC (InterProcess
 Communication) sulla macchina locale
\end_layout

\begin_layout Itemize
netstat -l | more //elenca tutti i socket che sono in 
\begin_inset Quotes eld
\end_inset

Listening
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
netstat -lt | more //mostra tutte le porte TCP in 
\begin_inset Quotes eld
\end_inset

Listening
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
netstat -lu | more //mostra tutte le porte UDP in 
\begin_inset Quotes eld
\end_inset

Listening
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
netstat -ie //visualizza le interfaccie di rete, come 
\begin_inset Quotes eld
\end_inset

ifconfig
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

-i
\begin_inset Quotes erd
\end_inset

 sta per interface e 
\begin_inset Quotes eld
\end_inset

-e
\begin_inset Quotes erd
\end_inset

 per extended, in quanto viene visualizzato un insieme esteso di informazioni
\end_layout

\begin_layout Itemize
netstat -i //visualizza le interfaccie di rete, con un insieme esiguo di
 informazioni
\end_layout

\begin_layout Itemize
netstat -rn //visualizza le tabelle di routing, dove 
\begin_inset Quotes eld
\end_inset

-r
\begin_inset Quotes erd
\end_inset

, significa mostrami le tabelle di routing e 
\begin_inset Quotes eld
\end_inset

-n
\begin_inset Quotes erd
\end_inset

 non risolvere i nomi di dominio per gli indirizzi ip
\end_layout

\begin_layout Itemize
netstat -a //visualizza tutte le connessioni presenti sul sistema
\end_layout

\begin_layout Itemize
netstat -uta //visualizza tutte 
\begin_inset Quotes eld
\end_inset

-a
\begin_inset Quotes erd
\end_inset

 le connessioni UDP 
\begin_inset Quotes eld
\end_inset

-u
\begin_inset Quotes erd
\end_inset

 e TCP 
\begin_inset Quotes eld
\end_inset

-t
\begin_inset Quotes erd
\end_inset

 sul sistema
\end_layout

\begin_layout Itemize
netstat -aute //è analogo al precedente, ma grazie al flag 
\begin_inset Quotes eld
\end_inset

-e
\begin_inset Quotes erd
\end_inset

, visualizza informazioni estese, mostrandoci anche a quale processo è legata
 ogni connessione
\end_layout

\begin_layout Itemize
netstat -lp //visualizza le applicazioni, come ssh, apache, eccetera sul
 sistema
\end_layout

\begin_layout Itemize
netstat -s //visualizza un summary 
\begin_inset Quotes eld
\end_inset

-s
\begin_inset Quotes erd
\end_inset

, cioè un resoconto delle statistiche e dei dati riguardanti la rete
\end_layout

\begin_layout Itemize
netstat -pt //visualizza informazioni sui programmi che gestiscono connessioni,
 il loro stato e il PID del processo legato al programma
\end_layout

\begin_layout Itemize
nestat -c //visualizza le informazioni di netstat con aggiornamento periodico
\end_layout

\begin_layout Itemize
netstat -ap //visualizza tutte le applicazioni che sono in esecuzione con
 il relativo stato
\end_layout

\begin_layout Itemize
netstat -ap | grep ssh //visualizza informazioni sulle porte utilizzate
 dal programma 
\begin_inset Quotes eld
\end_inset

ssh
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
netstat -an //visualizza tutti i processi di rete con relativa porta utilizzata
\end_layout

\begin_layout Itemize
netstat -an | grep ':80' //visualizza solo i processi relativi alla porta
 
\begin_inset Quotes eld
\end_inset

80
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
netstat –inet //visualizza solo i socket di rete IPv4e non quelli per l'IPC
 (interprocess communication), in quanto questi ultimi nell'ambito del networkin
g, non ci interessano
\end_layout

\begin_layout Itemize
netstat –tcp –listening –programs //visualizza i programmi in ascolto per
 il protocollo TCP, è equivalente ad 
\begin_inset Quotes eld
\end_inset

-tlp
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
netstat -ntlp //molto usato per vedere programmi in ascolto sulle porte,
 è una delle configurazioni di flag per netstat a mio parere più utili
\end_layout

\begin_layout Itemize
netstat -ntu //mostra gli utenti collegati alla mia macchina in termini
 di IP
\end_layout

\begin_layout Itemize
sudo netstat –inet -lnp //visualizza i processi che utilizzano determinate
 porte in listening riguardo i socket di rete, a volte è bene utilizzare
 netstat con i diritti di amministratore, in quanto si potrebbero non avere
 i diritti di visualizzare le applicazioni in ascolto, in questo modo invece
 si ha un quadro completo di chi sta occupando cosa
\end_layout

\begin_layout Itemize
sudo netstat -ntlp4 //visualizza tutte le porte in listening utilizzanti
 protocollo IPv4 con annessi processi
\end_layout

\begin_layout Itemize
sudo netstat -ntlp4e //visualizza tutte le porte in listening utilizzanti
 protocollo IPv4 con annessi processi ed inode, infatti a volte potrebbe
 capitare di non poter visualizzare un nome processo, possiamo scoprire
 l'inode relativo utilizzando il flag 
\begin_inset Quotes eld
\end_inset

-e
\begin_inset Quotes erd
\end_inset

 e poi andandolo a cercare in /proc oppure possiamo utilizzare un 
\begin_inset Quotes eld
\end_inset

lsof | grep <inodenumber>
\begin_inset Quotes erd
\end_inset

 per poter visualizzare il nome del processo, ad ogni modo in alcuni casi
 anche questo approccio ci porterà ad un inode fantasma, in quanto il processo
 è morto e le informazioni che mostra il kernel non sono aggiornate, comunque
 non è nulla di allarmante
\end_layout

\begin_layout Standard
un'alternative è quella di usare lsof, con:
\end_layout

\begin_layout Itemize
sudo lsof -iTCP:631 -sTCP:LISTEN //guarda chi è in ascolto sulla porta TCP
 631, citando il process name
\end_layout

\begin_layout Standard
Quindi per visualizzare le porte di rete aperte e in 
\begin_inset Quotes eld
\end_inset

LISTEN
\begin_inset Quotes erd
\end_inset

 (cioè quelle potenzialmente pericolose) su una macchina, (se abbiamo l'accesso)
 possiamo eseguire:
\end_layout

\begin_layout Itemize
sudo netstat -pnl –inet | grep LISTEN //visualizza le porte di rete in ascolto
 sulla macchina locale, cioè le porte TCP in listening e le porte UDP, che
 per loro natura sono sempre in LISTEN e accettano dati, in quanto 
\begin_inset Quotes eld
\end_inset

UDP is stateless so it's always LISTENING and accepting data at the same
 time
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
che è equivalente ad un:
\end_layout

\begin_layout Itemize
nmap -sS -p 1-65535 -T 5 localhost; nmap -sU -p 1-65535 -T 5 localhost //una
 scansione nmap su tutte le porte TCP e UDP, il flag 
\begin_inset Quotes eld
\end_inset

-T 5
\begin_inset Quotes erd
\end_inset

 è utilizzato per effettuare una scansione veloce (ergo, molto traffico,
 è anche un po' più impreciso, nel caso dovessimo avere risultati completamente
 diversi è meglio toglierlo o al posto di 
\begin_inset Quotes eld
\end_inset

5
\begin_inset Quotes erd
\end_inset

 inserire 
\begin_inset Quotes eld
\end_inset

4
\begin_inset Quotes erd
\end_inset

), ma non è importante in quanto siccome la scansione è locale, non ci importa
 di creare molto traffico, senza l'opzione 
\begin_inset Quotes eld
\end_inset

-T 5
\begin_inset Quotes erd
\end_inset

 la scansione UDP potrebbe risultare ancora più lenta
\end_layout

\begin_layout Standard
Ma netstat avvierà una scansione moooolto più veloce in quanto è lo sturmento
 adatto da usare in locale, mentre nmap è fatto per scansioni su un pc remoto
 in LAN o all'esterno della rete locale.
\end_layout

\begin_layout Standard
Netstat, oggigiorno è deprecato in favore di 
\begin_inset Quotes eld
\end_inset

ss
\begin_inset Quotes erd
\end_inset

.
 La sintassi di 
\begin_inset Quotes eld
\end_inset

ss
\begin_inset Quotes erd
\end_inset

 è identica a quella di netstat, in modo da favorire la transizione (per
 fortuna), inoltre supporta aggiuntivi filtri, vediamo alcuni esempi:
\end_layout

\begin_layout Itemize
ss -nt '( dst :443 or dst :80 )' //in questo caso stiamo cercando le connessioni
 di tipo TCP 
\begin_inset Quotes eld
\end_inset

-t
\begin_inset Quotes erd
\end_inset

 e senza risolvere i domini 
\begin_inset Quotes eld
\end_inset

-n
\begin_inset Quotes erd
\end_inset

 con porta di destinazione 443 o 80
\end_layout

\begin_layout Itemize
ss -nt dst :443 or dst :80 //equivalente al comando sopracitato
\end_layout

\begin_layout Itemize
ss -nt dport = :80 //mostra solo i dati relativi a connessioni che hanno
 come porta di destinazione la 
\begin_inset Quotes eld
\end_inset

80
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
ss -at '( dport = :ssh or sport = :ssh )' //in questo caso stiamo tutte
 le connessioni, cioè in qualsiasi stato 
\begin_inset Quotes eld
\end_inset

-a
\begin_inset Quotes erd
\end_inset

, di tipo TCP, 
\begin_inset Quotes eld
\end_inset

-t
\begin_inset Quotes erd
\end_inset

, che hanno come porta sorgente o di destinazione il processo 
\begin_inset Quotes eld
\end_inset

ssh
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
ss dst 192.168.1.5 //mostra tutte le connessioni associate all'indirizzo IP
 menzionato come destinatario
\end_layout

\begin_layout Itemize
ss dst 192.168.1.5:http //mostra tutte le connessioni associate all'indirizzo
 IP e porta menzionati come destinatario, al posto di 
\begin_inset Quotes eld
\end_inset

http
\begin_inset Quotes erd
\end_inset

 avrei anche potuto specificare un numero di porta
\end_layout

\begin_layout Itemize
ss -np -f inet //è l'equivalente di netstat -np –inet e mostra solo i socket
 di rete associati ad IPv4 (che nella maggior parte dei casi è quello che
 ci interessa), guardare il man per le altre opzioni
\end_layout

\begin_layout Itemize
ss src 75.126.153.214 //mostra tutte le connessioni associate all'indirizzo
 IP menzionato come sorgente
\end_layout

\begin_layout Itemize
ss src 75.126.153.214:80 //mostra tutte le connessioni associate all'indirizzo
 IP e porta menzionati come sorgente
\end_layout

\begin_layout Standard
N.B.: Possiamo notare la differenza in velocità dei due comandi attraverso
 il programma 
\begin_inset Quotes eld
\end_inset

time
\begin_inset Quotes erd
\end_inset

, proviamo ad esempio ad effettuare un:
\end_layout

\begin_layout Itemize
time netstat -at
\end_layout

\begin_layout Standard
e successivamente un:
\end_layout

\begin_layout Itemize
time ss -atr //il flag 
\begin_inset Quotes eld
\end_inset

-r
\begin_inset Quotes erd
\end_inset

 è utilizzato per risolvere gli indirizzi in nomi di dominio, in quanto
 netstat lo esegue di default, mentre 
\begin_inset Quotes eld
\end_inset

ss
\begin_inset Quotes erd
\end_inset

 no, infatti per non farlo eseguire a netstat, dobbiamo passare il flag
 
\begin_inset Quotes eld
\end_inset

-n
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Per quanto riguarda l'output, possiamo notare che:
\end_layout

\begin_layout Itemize
The “Recv-Q” and “Send-Q” columns tell us how much data is in the queue
 for that socket, waiting to be read (Recv-Q) or sent (Send-Q).
 In short: if this is 0, everything’s ok, if there are non-zero values anywhere,
 there may be trouble.
 If you look closely at the example, you’ll see that two sockets have a
 Recv-Q with 38 unread bytes in them.
 We’ll look into those connections once we know what the other columns mean.
\end_layout

\begin_layout Subsection
Iptraf
\end_layout

\begin_layout Standard
Il programma iptraf costituisce uno strumento utilizzato per monitorare
 il traffico locale di una macchina, è simile al programma wireshark.
 Vediamo alcuni esempi:
\end_layout

\begin_layout Itemize
iptraf //esegue il programma iptraf
\end_layout

\begin_layout Itemize
iptraf -s eth0 -B & //avvia in background iptraf sull'interfaccia di rete
 eth0, possiamo visualizzare i log in 
\begin_inset Quotes eld
\end_inset

/var/log/iptraf/
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Section
Data, Ora e Linuga nei sistemi GNU/Linux
\end_layout

\begin_layout Subsection
Date, e cal
\end_layout

\begin_layout Standard
Il comando date è utilizzato per visualizzare la data e l'ora, vediamo alcuni
 esempi:
\end_layout

\begin_layout Itemize
date //visualizza data e ora
\end_layout

\begin_layout Itemize
date -R //visualizza data e ora, aggiungendo l'offset al tempo UTC
\end_layout

\begin_layout Itemize
date +%T //visualizza solo l'ora 
\end_layout

\begin_layout Itemize
date +%a //visualizza solo il giorno della settimana abbreviato
\end_layout

\begin_layout Itemize
date +%A //visualizza solo il giorno della settimana
\end_layout

\begin_layout Standard
Nel manuale (attraverso 
\begin_inset Quotes eld
\end_inset

man date
\begin_inset Quotes erd
\end_inset

) troviamo tutta una serie di opzioni con cui possiamo effettuare l'output
 del comando date.
 Vediamo altri esempi applicativi, utili anche nel momento in cui scriviamo
 script:
\end_layout

\begin_layout Itemize
date -d now //mostra la data e l'ora attuale, è analogo a 
\begin_inset Quotes eld
\end_inset

date
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
date -d yesterday //mostra la data di ieri alla stessa ora
\end_layout

\begin_layout Itemize
date -d tomorrow //mostra la data di domani alla stessa ora
\end_layout

\begin_layout Itemize
date -r nomeFile //mostra l'ultima volta che è stato modificato un file
\end_layout

\begin_layout Itemize
date -u //mostra data e ora universali 
\begin_inset Quotes eld
\end_inset

UTC
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
date +%T -s 
\begin_inset Quotes eld
\end_inset

14:05:3
\begin_inset Quotes erd
\end_inset

 //imposta l'ora alle 
\begin_inset Quotes eld
\end_inset

14:05:3
\begin_inset Quotes erd
\end_inset

, il flag 
\begin_inset Quotes eld
\end_inset

-s
\begin_inset Quotes erd
\end_inset

 possiamo ricordarlo come 
\begin_inset Quotes eld
\end_inset

set
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
date +%a -s 
\begin_inset Quotes eld
\end_inset

Mon
\begin_inset Quotes erd
\end_inset

 //imposta il giorno della settimana a Lunedì
\end_layout

\begin_layout Itemize
date -s 
\begin_inset Quotes eld
\end_inset

16 jul 2013 14:00:00
\begin_inset Quotes erd
\end_inset

 //imposta data e ora
\end_layout

\begin_layout Itemize
date –rfc-3339=date //mostra nel formato RFC 3339 solo la data
\end_layout

\begin_layout Itemize
date –rfc-3339=seconds //mostra nel formato RFC 3339 data e ora esplicitando
 anche i secondi
\end_layout

\begin_layout Itemize
date –rfc-3339=ns //mostra nel formato RFC 3339 la data, l'ora, i secondi
 e i nanosecondi
\end_layout

\begin_layout Itemize
date –date='15 days ago' //mostra nel formato RFC 3339 la data di quindici
 giorni fa
\end_layout

\begin_layout Itemize
date –date='15 month ago' //mostra nel formato RFC 3339 la data di quindici
 mesi fa
\end_layout

\begin_layout Itemize
date –date='15 years ago' //mostra nel formato RFC 3339 la data di quindici
 anni fa
\end_layout

\begin_layout Itemize
date –date='15 minutes ago' //mostra nel formato RFC 3339 la data di quindici
 minuti fa
\end_layout

\begin_layout Itemize
date -u -d "@${time_in_seconds}" +"%T" //mostra il tempo in ore:minuti:secondi,
 data in pasto una variabile chiamata 
\begin_inset Quotes eld
\end_inset

time_in_seconds
\begin_inset Quotes erd
\end_inset

, quindi prima dovremmo inserire time_in_seconds=180 ad esempio
\end_layout

\begin_layout Standard
possiamo aprire un calendario con:
\end_layout

\begin_layout Itemize
cal //visualizza il calendario, solo il mese corrente
\end_layout

\begin_layout Itemize
cal -A2 -B2 //visualizza il calendario, con 
\begin_inset Quotes eld
\end_inset

-A
\begin_inset Quotes erd
\end_inset

 dico quanti mesi successivi al presente voglio mostrare e con 
\begin_inset Quotes eld
\end_inset

-B
\begin_inset Quotes erd
\end_inset

 quanti mesi precedenti al mese corrente
\end_layout

\begin_layout Itemize
cal -y 1999 //visualizza il calendario per l'intero anno 1999
\end_layout

\begin_layout Subsection
Localtime e Timezone
\end_layout

\begin_layout Subsubsection
Localtime
\end_layout

\begin_layout Standard
Il localtime è localizzato in 
\begin_inset Quotes eld
\end_inset

/etc/localtime
\begin_inset Quotes erd
\end_inset

, questo costituisce un link o una copia di un file in un'altra directory,
 in quest'altra directory troviamo la lista dei vari timezone che possiamo
 selezionare, una volta trovato il timezone di interesse, per cambiarlo,
 eseguiamo:
\end_layout

\begin_layout Itemize
rm /etc/localtime //per eliminare il file di localtime corrente
\end_layout

\begin_layout Itemize
cp /usr/share/zoneinfo/America/New_York /etc/localtime //in questo caso
 impostiamo l'ora locale di New York e presupponiamo che i file di localtime
 siano localizzata in 
\begin_inset Quotes eld
\end_inset

/usr/share/timezone
\begin_inset Quotes erd
\end_inset

, al posto della copia avremmo potuto creare anche un link, sarebbe stato
 uguale
\end_layout

\begin_layout Itemize
date //lo usiamo per verificare che il cambio di localtime sia stato effettuato
\end_layout

\begin_layout Standard
Vediamo altri comandi utili:
\end_layout

\begin_layout Itemize
locale -a //mostra i caratteri abilitati sul nostro sistema
\end_layout

\begin_layout Itemize
locale //mostra tutte le impostazioni legate alla lingua sul nostra sistema
 di default, possiamo modificarle andando a sovrascriverle impostando variabili
 d'ambiente con lo stesso nome, possiamo rendere permanenti queste modifiche
 andando ad accodare queste variabili col loro valore nel file 
\begin_inset Quotes eld
\end_inset

.bash_profile
\begin_inset Quotes erd
\end_inset

, possiamo invece applicarle globalmente al sistema (tutti gli utenti) attravers
o il file 
\begin_inset Quotes eld
\end_inset

/etc/rc.local
\begin_inset Quotes erd
\end_inset

 (anche se è consigliato vedere la sezione sulla Bash e le variabili d'ambiente
 per utilizzare il file corretto)
\end_layout

\begin_layout Standard
E' da notare che la directory 
\begin_inset Quotes eld
\end_inset

/usr/share/zoneinfo
\begin_inset Quotes erd
\end_inset

 è molto importante, ha diverse funzioni:
\end_layout

\begin_layout Itemize
a directory and text based “database” of all available known timezones throughou
t the world ◦
\end_layout

\begin_layout Itemize
used by a large number of applications and local system utilities to get
 information about timezones, times in other zones, zone information in
 large zone settings, etc ◦
\end_layout

\begin_layout Itemize
used by localtime to provide information as part of its call back response
 to system time calls
\end_layout

\begin_layout Subsubsection
Timezone
\end_layout

\begin_layout Standard
Il timezone invece identifica la nostra posizione nel mondo e quindi le
 ore di differenza rispetto all'orario universale, quindi GMT+2 o GMT+1,
 infatti la differenza viene così descritta: Timezone tells your system
 where you are in the world.
 i.e.
 GMT-4 or GMT+2 (depending on your exact location on the planet).
\end_layout

\begin_layout Standard
Localtime tells your system exactly what time it is at your location.
 Per selezionare il timezone possiamo utilizzare:
\end_layout

\begin_layout Standard
Nei sistemi Red-Hat based possiamo utilizzare i seguenti comandi:
\end_layout

\begin_layout Itemize
tzselect //avvia uno script interattivo che ci permette di selezionare il
 timezone, alla fine dello script ci sono indicazioni su come rendere il
 cambio di timezone permanente
\end_layout

\begin_layout Itemize
export TZ=
\begin_inset Quotes erd
\end_inset

Central Time
\begin_inset Quotes erd
\end_inset

 //imposta la variabile adibita al timezone a 
\begin_inset Quotes eld
\end_inset

Central Time
\begin_inset Quotes erd
\end_inset

, questa voce deve essere inserita nel file di configurazione shell .profile
 per diventare permanente
\end_layout

\begin_layout Itemize
nano /etc/timezone //un'altra possibilità è modificare o creare (in caso
 di assenza) questo file e immetere il codice Timezone che metteremmo in
 altro caso nella variabile d'ambiente o che viene indicato dalla procedura
 tzselect, questo caso, il timezone è applicato all'intero sistema
\end_layout

\begin_layout Standard
Nei sistemi Debian based possiamo invece effettuare:
\end_layout

\begin_layout Itemize
dpkg-reconfigure tzdata //riconfigura il timezone, una volta esisteva un
 comando chiamato 
\begin_inset Quotes eld
\end_inset

tzconfig
\begin_inset Quotes erd
\end_inset

 ma nelle nuove distro è deprecato
\end_layout

\begin_layout Itemize
export TZ=
\begin_inset Quotes erd
\end_inset

Central Time
\begin_inset Quotes erd
\end_inset

 //imposta la variabile adibita al timezone a 
\begin_inset Quotes eld
\end_inset

Central Time
\begin_inset Quotes erd
\end_inset

, questa voce deve essere inserita nel file di configurazione shell .profile
 per diventare permanente
\end_layout

\begin_layout Itemize
nano /etc/timezone //un'altra possibilità è modificare o creare (in caso
 di assenza) questo file e immetere il codice Timezone che metteremmo in
 altro caso nella variabile d'ambiente o che viene indicato dalla procedura
 tzselect, questo caso, il timezone è applicato all'intero sistema
\end_layout

\begin_layout Subsubsection
Lingua dei pacchetti e locale
\end_layout

\begin_layout Standard
Il sistema 
\begin_inset Quotes eld
\end_inset

Locale
\begin_inset Quotes erd
\end_inset

 costituisce un sottoinsieme dell'ambiente dell'utente che definisce la
 lingua dell'utente, la sua nazione e altre particolari opzioni che l'utente
 preferisce visualizzare nella sua personale interfaccia.
\end_layout

\begin_layout Standard
Tutte le variabili d'ambiente appartenenti al sistema 
\begin_inset Quotes eld
\end_inset

Locale
\begin_inset Quotes erd
\end_inset

 iniziano per 
\begin_inset Quotes eld
\end_inset

LC_
\begin_inset Quotes erd
\end_inset

.
 Ad esempio 
\begin_inset Quotes eld
\end_inset

LC_TIME
\begin_inset Quotes erd
\end_inset

 è una variabile del sistema "locale" che definisce come la data e l'ora
 sono formattate mentre 
\begin_inset Quotes eld
\end_inset

LC_NUMERIC
\begin_inset Quotes erd
\end_inset

 può essere usato per cambiare il separatore decimale (punto o virgola).Vediamo
 ora una lista delle variabili del sistema 
\begin_inset Quotes eld
\end_inset

Locale
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Itemize
LC_CTYPE Character classification and case conversion.
 Also indicates the language which should be used with XIM.
\end_layout

\begin_layout Itemize
LC_NUMERIC Non-monetary numeric formats.
 
\end_layout

\begin_layout Itemize
LC_TIME Date and time formats.
 
\end_layout

\begin_layout Itemize
LC_COLLATE Collation order used for comparing and sorting.
 
\end_layout

\begin_layout Itemize
LC_MONETARY Monetary formats.
 
\end_layout

\begin_layout Itemize
LC_MESSAGES Formats of informative and diagnostic messages and interactive
 responses (also for graphical user interfaces).
 
\end_layout

\begin_layout Itemize
LC_PAPER Paper format.
 
\end_layout

\begin_layout Itemize
LC_NAME 
\end_layout

\begin_layout Itemize
LC_ADDRESS 
\end_layout

\begin_layout Itemize
LC_TELEPHONE 
\end_layout

\begin_layout Itemize
LC_MEASUREMENT 
\end_layout

\begin_layout Itemize
LC_IDENTIFICATION 
\end_layout

\begin_layout Standard
Esistono inoltre altre due variabili che modificano il valore di molte delle
 variabili che abbiamo elencato:
\end_layout

\begin_layout Itemize
LANG: Its value is used to set the value of all LC_* variables which are
 not explicitely set (those already set are not changed).
 Also, any LC_* variable can be modified after setting LANG.
 
\end_layout

\begin_layout Itemize
LC_ALL: Il suo valore sovrascriverà quello di tutte le variabili LC_* (ma
 non di LANG).
 Dopo aver impostato LC_ALL, tutte le modifiche a qualsiasi variabile LC_*
 non è permessa.
\end_layout

\begin_layout Standard
In generale, è raccomandato lasciare LC_ALL non settata, e settare invece
 la variabile LANG, e poi cambiare manualmente nel caso fosse necessario
 le altre variabili LC_.
 Per visualizzare le opzioni che possiamo assegnare alla variabile LANG,
 ci basta visualizzare il file 
\begin_inset Quotes eld
\end_inset

/etc/locale.gen
\begin_inset Quotes erd
\end_inset

 oppure per LC_ALL il file 
\begin_inset Quotes eld
\end_inset

/etc/locale.alias
\begin_inset Quotes erd
\end_inset

 anche se la presenza di questi file deve sempre essere verificata a differenza
 della distro.
 Inoltre questi file contengono la lista delle lingue disponibili, quindi
 può essere utile consultarli.
 E' utile ricordare che potrebbe essere necessaria lanciare il comando 
\begin_inset Quotes eld
\end_inset

locale-gen
\begin_inset Quotes erd
\end_inset

 una volta effettuata una modifica in uno di questi file.
 Possiamo cambiare il valore delle variabili LC_ con:
\end_layout

\begin_layout Itemize
export nomeVariabile=valore //imposta una variabile d'ambiente
\end_layout

\begin_layout Standard
nota che una variabile può anche essere definita come:
\end_layout

\begin_layout Itemize
nomeVariabile=valore //imposta una variabile di shell, quindi una variabile
 valida solo all'interno del processo shell corrente
\end_layout

\begin_layout Standard
la differenza sta appunto che nel caso di 
\begin_inset Quotes eld
\end_inset

export
\begin_inset Quotes erd
\end_inset

 la variabile (d'ambiente) verrà passata ad ogni processo figlio chiamato
 dalla shell.
 export makes the variable available to sub-processes.
 That is, export name=value means that the variable name is available to
 any process you run from that shell process.
 If you want a process to make use of this variable, use export, and run
 the process from that shell.
\end_layout

\begin_layout Standard
name=value means the variable scope is restricted to the shell, and is not
 available to any other process.
 You would use this for (say) loop variables, temporary variables etc.
\end_layout

\begin_layout Standard
nel caso volessimo impostare una variabile con un valore permanente, allora
 possiamo aggiungere l'assegnazione del valore nei file indicati per la
 Bash\SpecialChar endofsentence

\end_layout

\begin_layout Standard
A volte dopo un aggiornamento i link ai file delle lingue potrebbero rompersi,
 oppure potrebbe essere utile rigenerare i link alle lingue in quanto abbiamo
 effettuato una modifica nei file 
\begin_inset Quotes eld
\end_inset

/etc/locale.gen
\begin_inset Quotes erd
\end_inset

 o 
\begin_inset Quotes eld
\end_inset

/etc/locale.alias
\begin_inset Quotes erd
\end_inset

 quindi possiamo utilizzare il comando:
\end_layout

\begin_layout Itemize
sudo locale-gen //rigenera i link ai file delle lingue
\end_layout

\begin_layout Paragraph
Modificare permanentemente la lingua di sistema
\end_layout

\begin_layout Standard
Per modificare permenentemente la lingua di sistema possiamo generalmente
 andare nel file 
\begin_inset Quotes eld
\end_inset

/etc/locale.gen
\begin_inset Quotes erd
\end_inset

, qui decommentiamo le lingue che ci interessano e poi lanciamo un:
\end_layout

\begin_layout Itemize
locale-gen //rigenera le lingue e imposta permanentemente le lingue di sistema
\end_layout

\begin_layout Standard
N.B.: E' consigliato scegliere tra le varie scelte di una determinata lingua,
 quella con UTF-8 se presente.
\end_layout

\begin_layout Subsubsection
Tastiera
\end_layout

\begin_layout Paragraph
Modifiche temporanee al layout della tastiera
\end_layout

\begin_layout Standard
Per cambiare runtime il layout della tastiera eseguiamo:
\end_layout

\begin_layout Itemize
loadkeys it //per cambiare la lingua della tastiera in italiano per la sessione
 corrente da un ambiente terminale 
\begin_inset Quotes eld
\end_inset

shell di login
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
se loadkeys non dovesse esserci come programma installato possiamo usare:
\end_layout

\begin_layout Itemize
setxkbmap it //per cambiare la lingua della tastiera in italiano per la
 sessione corrente in un ambiente grafico
\end_layout

\begin_layout Standard
Per impostare permanentemente il layout della tastiera dobbiamo o modificare
 un file Xorg manualmente o utilizzare il comando 
\begin_inset Quotes eld
\end_inset

localectl
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Dopo aver impostato il layout, potrebbe essere necessario un reboot, o riavviare
 il demone della tastiera; in altri casi invece la gestione del layout della
 tastiera è lasciata al Desktop Environment, quindi dovremo andare nelle
 impostazioni del Desktop Environment per poter cambiare layout.
\end_layout

\begin_layout Paragraph
Modifiche permanenti al layout della tastiera
\end_layout

\begin_layout Standard
Un keymap persistente può essere impostato attraverso il file /etc/vconsole.conf,
 che viene normalmente letto da systemd (o altro gestore di demoni) al boot.
 Possiamo trovare i layout disponibili con (anche se il percorso può cambiare
 da distro a distro):
\end_layout

\begin_layout Itemize
find /usr/share/kbd/keymaps/ -type f 
\end_layout

\begin_layout Subparagraph
Settaggio permanente della lingua con systemd
\end_layout

\begin_layout Standard
Ad ogni modo può risultare utile il programma 
\begin_inset Quotes eld
\end_inset

localectl
\begin_inset Quotes erd
\end_inset

 contenuto in 
\begin_inset Quotes eld
\end_inset

systemd
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Itemize
localectl status //mostra lo stato della lingua e del layout attuale
\end_layout

\begin_layout Itemize
localectl list-keymaps //elenca i layout disponibili
\end_layout

\begin_layout Itemize
localectl list-keymaps | grep -i cz //ricerca il keymap 
\begin_inset Quotes eld
\end_inset

cz
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
per impostare un layout persistente senza andare a modificare manualmente
 il file /etc/vconsole.conf facciamo:
\end_layout

\begin_layout Itemize
localectl set-keymap –no-convert it //in questo caso settiamo il layout
 del terminale (shell di login) di tastiera italiano, l'opzione 
\begin_inset Quotes eld
\end_inset

–no-convert
\begin_inset Quotes erd
\end_inset

 può essere usata per prevenire di cambiare in automatico ad un altra lingua
 vicina nel caso in cui il keymap indicato non dovesse esistere
\end_layout

\begin_layout Itemize
localectl –no-convert set-x11-keymap it //in questo caso settiamo il layout
 della tastiera in un ambiente X (e shell di non login), l'opzione 
\begin_inset Quotes eld
\end_inset

–no-convert
\begin_inset Quotes erd
\end_inset

 può essere usata per prevenire di cambiare in automatico ad un altra lingua
 vicina nel caso in cui il keymap indicato non dovesse esistere
\end_layout

\begin_layout Subparagraph
Settaggio permanente della lingua con startx
\end_layout

\begin_layout Standard
Nel caso non si usasse systemd, possiamo aggiungere il comando 
\begin_inset Quotes eld
\end_inset

setxkbmap it
\begin_inset Quotes erd
\end_inset

 per aggiungere il layout nel file 
\begin_inset Quotes eld
\end_inset

.xinitrc
\begin_inset Quotes erd
\end_inset

, nel caso usassimo 
\begin_inset Quotes eld
\end_inset

startx
\begin_inset Quotes erd
\end_inset

 per avviare l'ambiente grafico, la voce va aggiunta prima dell'exec dell'ambien
te grafico.
\end_layout

\begin_layout Subparagraph
Settaggio permanente della lingua senza startx e senza systemd
\end_layout

\begin_layout Standard
In questo caso, ad esempio se abbiamo un window manager che non avviamo
 con 
\begin_inset Quotes eld
\end_inset

startx
\begin_inset Quotes erd
\end_inset

, creiamo uno script per X, situato in 
\begin_inset Quotes eld
\end_inset

etc/X11/xorg.conf.d/00-keyboard.conf
\begin_inset Quotes erd
\end_inset

 e ci mettiamo:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Section "InputClass"         
\end_layout

\begin_layout Plain Layout

	Identifier "system-keyboard"
\end_layout

\begin_layout Plain Layout

	MatchIsKeyboard "on"   
\end_layout

\begin_layout Plain Layout

	Option "XkbLayout" "it,us"         
\end_layout

\begin_layout Plain Layout

EndSection
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Character Encoding
\end_layout

\begin_layout Standard
Ogni file è scritto utilizzando un determinato Character Encoding, cioè
 un repertorio preciso di caratteri codificato in un certo modo, esistono
 diversi tipi di character encoding, i più famosi sono:
\end_layout

\begin_layout Itemize
UTF-8 
\end_layout

\begin_layout Itemize
ASCII
\end_layout

\begin_layout Itemize
UTF-16
\end_layout

\begin_layout Itemize
UTF-32
\end_layout

\begin_layout Standard
Un programma molto utilizzato per effettuare conversioni di character encoding
 dei file è 
\begin_inset Quotes eld
\end_inset

iconv
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsubsection
Iconv
\end_layout

\begin_layout Standard
Possiamo utilizzare il comando 
\begin_inset Quotes eld
\end_inset

iconv
\begin_inset Quotes erd
\end_inset

 per convertire un file con un certa codifica in un'altra:
\end_layout

\begin_layout Itemize
iconv -f ASCII -t UTF-32 nomeFile > fileConvertito //il flag 
\begin_inset Quotes eld
\end_inset

-f
\begin_inset Quotes erd
\end_inset

 sta per 
\begin_inset Quotes eld
\end_inset

from
\begin_inset Quotes erd
\end_inset

 e cioè specifica la codifica di partenza del file, mentre 
\begin_inset Quotes eld
\end_inset

-t
\begin_inset Quotes erd
\end_inset

 specifica la codifica finale che avrà il file, questa conversione di codifica
 avverrà sul file chiamato 
\begin_inset Quotes eld
\end_inset

nomeFile
\begin_inset Quotes erd
\end_inset

 e il risultato sarà il file chiamato 
\begin_inset Quotes eld
\end_inset

fileConvertito
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
per visualizzare il tipo di codifica utilizzato per un file possiamo utilizzare:
\end_layout

\begin_layout Itemize
file nomeFile //visualizza il tipo di codifica utilizzato da un file
\end_layout

\begin_layout Standard
mentre per avere una lista delle codifiche disponibili col comando 
\begin_inset Quotes eld
\end_inset

iconv
\begin_inset Quotes erd
\end_inset

 possiamo utilizzare:
\end_layout

\begin_layout Itemize
iconv –list //mostra la lista di codifiche dei caratteri disponibili quando
 si invoca iconv
\end_layout

\begin_layout Subsection
Hwclock
\end_layout

\begin_layout Standard
Il programma hwclock ha lo scopo di visualizzare o reimpostare il clock
 hardware di sistema, questo clock è fornito di batteria esterna e localizzato
 sulla nostra scheda madre, ed è lo stesso clock che fornisce la data e
 l'ora all'interfaccia firmware (es.
 BIOS).
 Quando si parla di sistemi GNU/Linux, in realtà il sistema operativo utilizza
 queste informazioni di orario hardware solo al boot, mentre una volta avviato
 il sistema operativo, viene aggiornato e utilizzato l'orario di sistema;
 questo avviene perchè quando un computer è spento non riesce ad aggiornare
 l'orario del sistema operativo, quindi al boot richiede l'orario hardware
 in modo da potersi aggiornare.
 Potrebbe essere utile salvare l'orario di sistema sull'orario hardware
 o viceversa.
 Vediamo alcuni esempi applicativi del programma 
\begin_inset Quotes eld
\end_inset

hwclock
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Itemize
hwclock -r //visualizza l'orario hardware
\end_layout

\begin_layout Itemize
hwclock -s //sincronizza l'orario di sistema all'orario hardware
\end_layout

\begin_layout Itemize
hwclock -w //sincronizza l'orario hardware all'orario di sistema
\end_layout

\begin_layout Subsection
NTP (Network Time Protocol)
\end_layout

\begin_layout Standard
Il protocollo NTP, ha lo scopo di gestire la sincronizzazione dell'orario,
 attraverso un'architettura client-server, il protocollo si basa su UDP
 e solitamente funziona sulla porta 123.
 Il protocollo NTP, a grandi linee (molto grandi) funziona in questo modo:
 il client manda un pacchetto al server, il server manda l'orario esatto,
 e in tutto questo viene misurato il tempo di transito del pacchetto fino
 a che non ritorna al client, in questo modo riusciamo a sincronizzare l'ora
 del client a quella del server, ovviamente sempre con una certa varianza.
 NTP uses a hierarchical, semi-layered system of time sources.
 Each level of this hierarchy is termed a "stratum" and is assigned a number
 starting with zero at the top.
 A server synchronized to a stratum n server will be running at stratum
 n + 1.
 The number represents the distance from the reference clock and is used
 to prevent cyclical dependencies in the hierarchy.
 Stratum is not always an indication of quality or reliability; it is common
 to find stratum 3 time sources that are higher quality than other stratum
 2 time sources.
 La prima operazione da fare per usufruire del protocollo NTP è installarlo
 e possiamo farlo con:
\end_layout

\begin_layout Itemize
apt-get install ntp //installa il protocollo ntp
\end_layout

\begin_layout Standard
Una volta installato, avremo un file di configurazione in 
\begin_inset Quotes eld
\end_inset

/etc/ntp.conf
\begin_inset Quotes erd
\end_inset

 dove potremo mettere mano alla configurazione di ntp.
 Esistono diversi server pubblici per NTP e possiamo aggiungerli al file
 ntp.conf attraverso righe come:
\end_layout

\begin_layout Itemize
server indirizzoServer.org //esempio di riga all'interno di ntp.conf
\end_layout

\begin_layout Standard
possiamo avere più server, ed è possibile anche indicare il server preferito.
 Possiamo poi lanciare:
\end_layout

\begin_layout Itemize
service ntpd status //mostra a schermo lo stato del demone che gestisce
 ntp, in questo caso è stato usato service, ma nel caso di systemd avremmo
 dovuto usare 
\begin_inset Quotes eld
\end_inset

systemctl status ntpd
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Una volta che ci siamo accertati che il demone è attivo, possiamo lanciare:
\end_layout

\begin_layout Itemize
ntpdate //imposta data e ora attraverso NTP
\end_layout

\begin_layout Standard
Possiamo visualizzare informazioni sui nodi a cui siamo connessi con ntp,
 attraverso:
\end_layout

\begin_layout Itemize
ntpq -p //visualizza informazioni sui nodi utilizzati per la sincronizzazione
 attraverso ntp, se davanti al nome del nodo vediamo un asterisco 
\begin_inset Quotes eld
\end_inset

*
\begin_inset Quotes erd
\end_inset

, allora vuol dire che attualmente siamo sincronizzati a quel nodo, qui
 possiamo vedere informazioni come livello di stratum 
\begin_inset Quotes eld
\end_inset

st
\begin_inset Quotes erd
\end_inset

, delay (tempo impiegato dal pacchetto ad arrivare al server e tornare di
 nuovo al client), jitter (deviazione nel tempo che viene riportato dal
 server al client), offset, eccetera
\end_layout

\begin_layout Section
Stampare
\end_layout

\begin_layout Standard
Per stampare sui sistemi GNU/Linux il programma principale utilizzato è
 CUPS, anche se in passato era molto utilizzato LPD e molte distro ancora
 lo supportano, quindi diamo un'occhiata ad entrambi.
\end_layout

\begin_layout Subsection
LPD (Linux Printer Daemon)
\end_layout

\begin_layout Standard
LPD ha costituito per molti anni un sistema di gestione del sistema di stampa,
 è utile conoscerlo in quanto il più moderno CUPS è compatibile con LPD,
 e i comandi sono analoghi.
 Per installa il sistema LPD, eseguiamo:
\end_layout

\begin_layout Itemize
sudo apt-get install lpr //installa il sistema LPD, nota che LPD non può
 essere installato assieme a CUPS, possiamo avere o l'uno o l'altro
\end_layout

\begin_layout Standard
Vediamo alcuni esempi di applicazione dei comandi di stampa:
\end_layout

\begin_layout Itemize
lpr -P PDF test.txt //in questo caso, eseguiamo una stampa, e col flag 
\begin_inset Quotes eld
\end_inset

-P
\begin_inset Quotes erd
\end_inset

 scegliamo la stampante, che è un file PDF, mentre il file da stmpare è
 test.txt
\end_layout

\begin_layout Itemize
lpr test.txt //in questo caso stampa con la stampante di default
\end_layout

\begin_layout Itemize
lpstat -d //mostra il nome della stampante di default
\end_layout

\begin_layout Itemize
lpstat -p //mostra la lista di tutte le stampanti associate alla macchina
\end_layout

\begin_layout Itemize
lpoptions -d nomeStampante //mostra informazioni sulla stampante, le info
 mostrate con questo comando devono essere messe nel file 
\begin_inset Quotes eld
\end_inset

/etc/printcap
\begin_inset Quotes erd
\end_inset

 se non già esistenti, (non in tutte le distro esiste questo file) che è
 un link al file 
\begin_inset Quotes eld
\end_inset

/etc/cups/printers.conf
\begin_inset Quotes erd
\end_inset

 (questo esiste in tutte le distro) infatti all'interno di questo file troviamo
 anche la lista delle stampanti con le relative informazioni
\end_layout

\begin_layout Standard
Per stampare possiamo sia usare il comando 
\begin_inset Quotes eld
\end_inset

lp
\begin_inset Quotes erd
\end_inset

 che il comando 
\begin_inset Quotes eld
\end_inset

lpr
\begin_inset Quotes erd
\end_inset

, sono analoghi, differiscono solo per parametri, ad esempio:
\end_layout

\begin_layout Itemize
lp -d nomeStampante nomefile //stampa il file chiamato nomeFile con la stampante
 nomeStampante
\end_layout

\begin_layout Itemize
lpr -P nomeStampante nomefile //stampa il file chiamato nomeFile con la
 stampante nomeStampante
\end_layout

\begin_layout Itemize
xpp //apre il gestore grafico adibito alla stampa, comodo quando abbiamo
 X a disposizione
\end_layout

\begin_layout Itemize
cupsenable nomeStampante //riabilita una stampante se è stata disabilitata
\end_layout

\begin_layout Subsection
CUPS (Common Unix Printing System)
\end_layout

\begin_layout Standard
CUPS è un sistema di stampa per sistemi GNU/Linux caratterizzato da un sistema
 di gestione via browser, che semplifica il settaggio delle impostazioni,
 possiamo di default accedere a questo sistema, collegandoci a 
\begin_inset Quotes eld
\end_inset

localhost:631
\begin_inset Quotes erd
\end_inset

.
 E' sempre buona norma installare una stampante PDF, che è molto utile.
 Per installa cups, facciamo:
\end_layout

\begin_layout Itemize
apt-get install cups //installa cups
\end_layout

\begin_layout Itemize
apt-get install cups-pdf //installa la stampante pdf
\end_layout

\begin_layout Standard
Per quanto riguarda la linea di comando, valgono gli stessi comandi utilizzati
 per LPD, sia per stampare, che per gestire/visualizzare le stampanti.
\end_layout

\begin_layout Standard
Infatti CUPS mantiene una certa compatibilità con LPD, ad esempio la maggior
 parte dei comandi sono rimasti uguali, rimpiazza LPD con un sistema di
 più semplice gestione.
 Di default, CUPS è basato su due demoni, che gestiscono il sistema di stampa:
\end_layout

\begin_layout Itemize
cupsd
\end_layout

\begin_layout Itemize
cups-browsed
\end_layout

\begin_layout Standard
Per avviare (o riavviare) il demone di che gestisce il sistema di stampa,
 che può essere in alcune distro un'operazione necessaria dopo l'installazione,
 possiamo effettuare:
\end_layout

\begin_layout Itemize
/etc/init.d/cupsd restart //riavvia il demone che gestisce il sistema di
 stampa, con systemd sarebbe 
\begin_inset Quotes eld
\end_inset

systemctl restart cupsd
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
/etc/init.d/cups-browsed restart //riavvia il demone che gestisce il sistema
 di configurazione via web, con systemd sarebbe 
\begin_inset Quotes eld
\end_inset

systemctl restart cups-browsed
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Inoltre se al riavvio non è abilitato, è buona norma abilitarlo dopo ogni
 boot (la maggior parte delle distro dovrebbe farlo di default), con systemd
 possiamo usare:
\end_layout

\begin_layout Itemize
systemctl enable cupsd //abilita anche dopo il boot cupsd
\end_layout

\begin_layout Itemize
systemctl enable cups-browsed //abilita anche dopo il boot cups-browsed
\end_layout

\begin_layout Standard
Vediamo ora alcuni file di configurazione e directory importanti:
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

/etc/cups/cups-browsed.conf
\begin_inset Quotes erd
\end_inset

: questo file di configurazione contiene le impostazioni di configurazione
 del server di stampa, in questo file, possiamo abilitare o disabilitare
 indirizzi ip per cercare/trovare stampanti, possiamo restringere il range
 di ip, da cui gli altri ad esempio possono stampare
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

/etc/cups/cupsd.conf
\begin_inset Quotes erd
\end_inset

: questo file di configurazione contiene la porta di configurazione di CUPS
 e l'indirizzo a cui è hostato il webserver di configurazione, che di default
 è 
\begin_inset Quotes eld
\end_inset

localhost:631
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

/var/spool/cups
\begin_inset Quotes erd
\end_inset

: questa directory contiene tutti i file rappresentanti i Job per cui è
 stata richiesta una stampa, finchè questi job non vengono rimossi da qui,
 una richiesta di stampa può essere rieseguita
\end_layout

\begin_layout Subsubsection
Gestione delle Code con CUPS
\end_layout

\begin_layout Standard
Vediamo ora alcuni comandi per gestire le code con CUPS:
\end_layout

\begin_layout Itemize
lpstat -a //mostra lo stato di tutte le stampanti
\end_layout

\begin_layout Itemize
lpq //mostra la coda di stampa, ad ogni richiesta di stampa è associato
 un 
\begin_inset Quotes eld
\end_inset

Job
\begin_inset Quotes erd
\end_inset

 ID che permette di identificare univocamente la richiesta, se quando effettuiam
o questo comando leggiamo in testa che la stampante non è pronta, ma con
 lpstat invece dice che è pronta ad accettare richieste, questo vuol dire
 che la stampante è in pausa
\end_layout

\begin_layout Itemize
lpq -P nomeStampante //mostra la coda di stampa per la stampante nomeStampante
\end_layout

\begin_layout Itemize
lprm //rimuove tutti i Job per la stampante di default
\end_layout

\begin_layout Itemize
lprm 22 //rimuove il job con ID 22
\end_layout

\begin_layout Itemize
cupsenable nomeStampante //riabilita la stampante nomeStampante, se era
 in pausa ora è di nuovo possibile stampare
\end_layout

\begin_layout Itemize
cupsdisable nomeStampante //disabilita la stampante nomeStampante, mettendola
 in uno stato di pausa, le richieste verranno messe in coda
\end_layout

\begin_layout Itemize
cupsreject nomeStampante //non permette di effettuare stampe, le richieste
 non verranno messe in coda, ma reiettate
\end_layout

\begin_layout Itemize
cupsaccept nomeStampante //riabilita la stampante dallo stato di 
\begin_inset Quotes eld
\end_inset

reject
\begin_inset Quotes erd
\end_inset

 abilitato col comano precedente
\end_layout

\begin_layout Section
Scansione Documenti
\end_layout

\begin_layout Standard
Un famoso pacchetto per la scansione dei documenti è 
\begin_inset Quotes eld
\end_inset

sane
\begin_inset Quotes erd
\end_inset

 ed 
\begin_inset Quotes eld
\end_inset

xsane
\begin_inset Quotes erd
\end_inset

, quest'ultimo costituisce la versione grafica.
 Una volta installati dobbiamo assicurarci di aver aggiunto l'utente con
 cui si vuole utilizzare il dispositivo di scansione al grouppo di scansione,
 solitamente questo è il gruppo 
\begin_inset Quotes eld
\end_inset

scanner
\begin_inset Quotes erd
\end_inset

 o il gruppo 
\begin_inset Quotes eld
\end_inset

lp
\begin_inset Quotes erd
\end_inset

, quindi si eseguirà:
\end_layout

\begin_layout Itemize
sudo usermod -a -G scanner nomeUtente //per aggiungere il gruppo 
\begin_inset Quotes eld
\end_inset

scanner
\begin_inset Quotes erd
\end_inset

 all'utente nomeUtente
\end_layout

\begin_layout Standard
oppure 
\end_layout

\begin_layout Itemize
sudo usermod -a -G lp nomeUtente //per aggiungere il gruppo 
\begin_inset Quotes eld
\end_inset

lp
\begin_inset Quotes erd
\end_inset

 all'utente nomeUtente
\end_layout

\begin_layout Standard
nel caso non si conoscesse il gruppo e non si dovesse sapere come aggiungere
 il proprio utente, possiamo attraverso il comando:
\end_layout

\begin_layout Itemize
lsusb //visualizza le periferiche usb (utile se il nostro scanner è usb
\end_layout

\begin_layout Standard
oppure 
\end_layout

\begin_layout Itemize
lspci //visualizza le periferiche pci (utile se il nostro scanner è pci)
\end_layout

\begin_layout Standard
visualizzare il numero di 
\begin_inset Quotes eld
\end_inset

bus
\begin_inset Quotes erd
\end_inset

 ed il numero di 
\begin_inset Quotes eld
\end_inset

device
\begin_inset Quotes erd
\end_inset

, in questo modo possiamo o aggiungere manualmente i permessi di scrittura
 sulla periferica o ricavare il gruppo, se ad esempio il nostro lsusb ritorna
 un'output del genere del tipo:
\end_layout

\begin_layout Itemize
Bus 002 Device 001: ID 1d6b:0002 Scanner XY //output del comando lsusb (o
 lspci)
\end_layout

\begin_layout Standard
allora andremo ad eseguire:
\end_layout

\begin_layout Itemize
sudo chmod a+w /dev/bus/usb/002/001 //impostiamo i diritti di scrittura
 per tutti gli utenti sulla periferica
\end_layout

\begin_layout Standard
in realtà una modalità meno brusca sarebbe quella di effettuare:
\end_layout

\begin_layout Itemize
ls -al /dev/bus/usb/002/ //visualizza l'elenco file nella directory contenente
 il dispositivo d'interesse
\end_layout

\begin_layout Standard
da questo elenco dovremo vedere un file col device ID del nostro scanner,
 dopo l'utente proprietario (che solitamente è root) vedremo un gruppo,
 ecco ci basta aggiungere quel gruppo all'utente con cui vogliamo utilizzare
 lo scanner, se il gruppo non dovesse esistere, possiamo creare un nostro
 gruppo e assegnarlo al device, e aggiungere al nostro utente quel gruppo.
\end_layout

\begin_layout Subsection
Programmi per Scansione Documenti
\end_layout

\begin_layout Standard
Possiamo usare il programma 
\begin_inset Quotes eld
\end_inset

xscanimage
\begin_inset Quotes erd
\end_inset

 per scandire un'immagine, questo programma è contenuto solitamente nel
 pacchetto 
\begin_inset Quotes eld
\end_inset

sane-frontends
\begin_inset Quotes erd
\end_inset

.
 AGGIUNGERE UN MINITUTORIAL A XSCANIMAGE
\end_layout

\begin_layout Section
Filesystems e Tuning
\end_layout

\begin_layout Subsection
Ext Utilities
\end_layout

\begin_layout Standard
Other useful utilities on ext filesystems are attributes, which are characterist
ics of files, we can view attributes with 
\end_layout

\begin_layout Itemize
lsattr to view attributes
\end_layout

\begin_layout Standard
or we can change attributes with:
\end_layout

\begin_layout Itemize
chattr +i fileName
\end_layout

\begin_layout Standard
the attributes 
\begin_inset Quotes eld
\end_inset

i
\begin_inset Quotes erd
\end_inset

 says that now the file is not deletable, there are many flags, and it is
 recommended to view them by doing a 
\begin_inset Quotes eld
\end_inset

man chattr
\begin_inset Quotes erd
\end_inset

, for example a good way to reduce I/O is to tell the OS to not save date
 and hour informations on disk with a certain flag, which is 
\begin_inset Quotes eld
\end_inset

A
\begin_inset Quotes erd
\end_inset

 (very useful for laptops), it is a good idea for the Orlov block allocator
 to set the /home directory with a 
\begin_inset Quotes eld
\end_inset

T
\begin_inset Quotes erd
\end_inset

 flag, since its subdirectories are not related and can be on separated
 disk's blocks.
\end_layout

\begin_layout Section
Automatizzare Processi
\end_layout

\begin_layout Standard
Nei sistemi unix-like due strumenti molto utilizzati per automatizzare processi
 sono:
\end_layout

\begin_layout Itemize
Cron
\end_layout

\begin_layout Itemize
AT
\end_layout

\begin_layout Subsection
Cron
\end_layout

\begin_layout Standard
Cron è uno strumento nato per pianificare processi/operazioni, devo ricordare
 che esistono diverse gerarchie di configurazione:
\end_layout

\begin_layout Itemize
System Cron //Un sistema di automatizzazione processi a livello di sistema
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Il file in cui sono contenute le configurazioni di sistema è 
\begin_inset Quotes eld
\end_inset

/etc/crontab
\begin_inset Quotes erd
\end_inset

, e una volta modificato e salvato il file, le modifche verranno applicate
 automaticamente, senza nessuna necessità di riavviare servizi.
\end_layout

\end_deeper
\begin_layout Itemize
User Cron //Un sistema di automatizzazione processi a livello utente
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Le configurazioni a livello utente invece sono contenute nella directory
 
\begin_inset Quotes eld
\end_inset

/var/spool/cron
\begin_inset Quotes erd
\end_inset

 o 
\begin_inset Quotes eld
\end_inset

/var/spool/crontab/
\begin_inset Quotes erd
\end_inset

, la collocazione della directory dipende dalla distro, anche se è sconsigliato
 mettere mano direttamente a questi file, l'editing deve avvenire tramite
 comando 
\begin_inset Quotes eld
\end_inset

crontab -e
\begin_inset Quotes erd
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
Possiamo modificare la configurazione di un utente attraverso il comando:
\end_layout

\begin_layout Itemize
crontab -e //modifica la configurazione di crontab a livello utente, è valido
 per l'utente che ha lanciato il comando, una volta modificato, il file
 sarà salvato all'interno della directory 
\begin_inset Quotes eld
\end_inset

/var/spool/cron/
\begin_inset Quotes erd
\end_inset

 o 
\begin_inset Quotes eld
\end_inset

/var/spool/crontab
\begin_inset Quotes erd
\end_inset

, mentre i log sono memorizzati in 
\begin_inset Quotes eld
\end_inset

/var/log/cron
\begin_inset Quotes erd
\end_inset

 o in 
\begin_inset Quotes eld
\end_inset

var/log/crontab
\begin_inset Quotes erd
\end_inset

, anche in questo caso dipende dalla distro utilizzata.
\end_layout

\begin_layout Standard
Vediamo altri esempi di comandi crontab:
\end_layout

\begin_layout Itemize
crontab -l //visualizza il file di crontab
\end_layout

\begin_layout Itemize
crontab -r //rimuove i file di crontab
\end_layout

\begin_layout Itemize
crontab -v //mostra l'ultima volta che è stato modificato il file di crontab
\end_layout

\begin_layout Itemize
tail -f /var/log/cron //mostra in tempo reale il log del cron, è utile sia
 per effettuare verifiche che per monitorare alcune attività del sistema
\end_layout

\begin_layout Standard
Analizziamo ora la configurazione di sistema, le prime righe del file 
\begin_inset Quotes eld
\end_inset

/etc/crontab
\begin_inset Quotes erd
\end_inset

 contengono alcune opzioni, come il tipo di shell utilizzata, dove andare
 a pescare i programmi eeguibili, eccetera.
 Solitamente (in alcune distro) sono contenuti già dei processi di automatizzazi
one di default che puntano a determinate directory, vediamo un esempio di
 file di configurazione globale:
\end_layout

\begin_layout Standard
———————————————————–
\end_layout

\begin_layout Standard
01 * * * * root run-parts /etc/cron.hourly
\end_layout

\begin_layout Standard
02 4 * * * root run-parts /etc/cron.daily
\end_layout

\begin_layout Standard
22 4 * * 0 root run-parts /etc/cron.weekly
\end_layout

\begin_layout Standard
42 4 1 * * root run-parts /etc/cron.monthly
\end_layout

\begin_layout Standard
———————————————————–
\end_layout

\begin_layout Standard
In pratica tutto quello contenuto in queste directory viene inteso come
 processo da automatizzare, questo grazie all'opzione inserita 
\begin_inset Quotes eld
\end_inset

run-parts
\begin_inset Quotes erd
\end_inset

.
 Recapitolando le directory importanti sono:
\end_layout

\begin_layout Itemize
/etc/crontab //file di configurazione globale
\end_layout

\begin_layout Itemize
/var/spool/cron || /var/spool/crontab //file di configurazione a livello
 utente
\end_layout

\begin_layout Itemize
/var/log/cron || /var/log/crontab //file di log relativi al crontab
\end_layout

\begin_layout Standard
Altri file importanti sono:
\end_layout

\begin_layout Itemize
/etc/cron.deny //tutti gli utenti elencati in questo file non possono usare
 cron, gli utenti sono separati da un invio
\end_layout

\begin_layout Itemize
/etc/cron.allow //a tutti gli utenti del sistema non è possibile usare cron
 eccetto a quelli elencati in questo file
\end_layout

\begin_layout Standard
N.B.: Solo uno dei file elencati sopra deve esistere, altrimenti le informazioni
 fornite dai due file sono in conflitto, inoltre è da ricordare che l'utente
 di root è esente da queste regole, root può sempre tutto.
\end_layout

\begin_layout Subsubsection
Come pianificare le operazioni nei file di crontab
\end_layout

\begin_layout Standard
La pianificazione di un'operazione è suddivisa su 7 campi:
\end_layout

\begin_layout Enumerate
indica i minuti
\end_layout

\begin_layout Enumerate
indica le ore
\end_layout

\begin_layout Enumerate
indica il giorno del mese
\end_layout

\begin_layout Enumerate
indica il mese
\end_layout

\begin_layout Enumerate
indica il giorno della settimana
\end_layout

\begin_layout Enumerate
indica l'utente con cui eseguire il comando
\end_layout

\begin_layout Enumerate
indica il comando da eseguire
\end_layout

\begin_layout Standard
Vediamo alcuni esempi (ricorda che il nomeUtente è incluso solo nel file
 
\begin_inset Quotes eld
\end_inset

/etc/crontab
\begin_inset Quotes erd
\end_inset

 quindi nella configurazione globale, mentre per le configurazioni locali
 basta mettere solo il comando dopo aver specificato i primi 5 campi):
\end_layout

\begin_layout Standard
————————–
\end_layout

\begin_layout Itemize
* 2 * * * nomeUtente nomeComando //indica di eseguire il comando 
\begin_inset Quotes eld
\end_inset

nomeComando
\begin_inset Quotes erd
\end_inset

 alle 2 AM, per tutti i minuti (quindi dalle 2.00 alle 2.59), tutti i giorni
 del mese, tutti i mesi, tutti i giorni della settimana
\end_layout

\begin_layout Itemize
* 2-5 * * * nomeUtente nomeComando2 //indica di eseguire il comando 
\begin_inset Quotes eld
\end_inset

nomeComando2
\begin_inset Quotes erd
\end_inset

 dalle 2AM alle 5AM, per tutti i minuti (quindi dalle 2.00 alle 5.59), tutti
 i giorni del mese, tutti i mesi, tutti i giorni della settimana
\end_layout

\begin_layout Itemize
* 2,5 * * * nomeUtente nomeComando3 //indica di eseguire il comando 
\begin_inset Quotes eld
\end_inset

nomeComando3
\begin_inset Quotes erd
\end_inset

 dalle 2AM alle 3 AM e dalle 5AM alle 6 AM, per tutti i minuti, tutti i
 giorni del mese, tutti i mesi, tutti i giorni della settimana
\end_layout

\begin_layout Itemize
* * 1-20 * * nomeUtente nomeComando4 //indica di eseguire il comando 
\begin_inset Quotes eld
\end_inset

nomeComando4
\begin_inset Quotes erd
\end_inset

 per tutti i minuti, tutte le ore, ma solo per i giorni dall'1 al 20 del
 mese, tutti i mesi, tutti i giorni della settimana
\end_layout

\begin_layout Itemize
* * * * 5 nomeUtente nomeComando5 //indica di eseguire il comando 
\begin_inset Quotes eld
\end_inset

nomeComando5
\begin_inset Quotes erd
\end_inset

 per tutti i minuti, tutte le ore, tutti i mesi, solo il venerdì
\end_layout

\begin_layout Itemize
* * * * 0 nomeUtente nomeComando5 //indica di eseguire il comando 
\begin_inset Quotes eld
\end_inset

nomeComando5
\begin_inset Quotes erd
\end_inset

 per tutti i minuti, tutte le ore, tutti i mesi, solo la domenica
\end_layout

\begin_layout Itemize
*/2 * * * * nomeUtente nomeComando6 //indica di eseguire il comando 
\begin_inset Quotes eld
\end_inset

nomeComando6
\begin_inset Quotes erd
\end_inset

 ogni due minuti, col carattere slash indichiamo la frequenza
\end_layout

\begin_layout Itemize
3-50/2 * * * * nomeUtente nomeComando7 //indica di eseguire il comando 
\begin_inset Quotes eld
\end_inset

nomeComando dal minuto 3 al minuto 50 di ogni ora di ogni giorno ogni 2
 minuti
\end_layout

\begin_layout Itemize
@reboot macchanger -r wlan0 //in questo caso questa operazione viene effettuata
 ad ogni reboot, quindi ogni volta che accendiamo il computer, viene avviata
 l'applicazione macchanger per fare in modo che il nostro MAC address venga
 cambiato con uno generato casualmente
\end_layout

\begin_layout Itemize
40 * * * * cd /home/user/scripts/ && bash myscript.sh //execute a bash script
 every hour at minute 40
\end_layout

\begin_layout Standard
nel caso volessimo schedulare più comandi ogni x minuti ma uno successivo
 all'altro possiamo usare un trucchetto, questo trucchetto ci permette di
 avere una granularità al secondo con cron:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

*/2 * * * * cd /home/user/scripts && bash first.sh
\end_layout

\begin_layout Plain Layout

*/2 * * * * cd /home/user/scripts && sleep 15 bash second.sh
\end_layout

\begin_layout Plain Layout

*/2 * * * * cd /home/user/scripts && sleep 30 bash third.sh > /home/user/logs/log.
txt 2>&1
\end_layout

\begin_layout Plain Layout

*/2 * * * * cd /home/user/scripts && sleep 45 bash fourth.sh
\end_layout

\end_inset


\end_layout

\begin_layout Standard
E' utile ricordare che il sistema manda dei messaggi all'utente in /var/mail/$US
ER.
 Possiamo assicurarci che cron si sia avviato da /var/log/syslog o /var/log/cron
, è utile ricordare che dobbiamo riavviare il servizio di cron ongi qualvolta
 cambiamo la configurazione.
\end_layout

\begin_layout Subsection
AT
\end_layout

\begin_layout Standard
Il programma 
\begin_inset Quotes eld
\end_inset

at
\begin_inset Quotes erd
\end_inset

 ci permette di pianificare operazioni che dovranno avvenire nel futuro,
 ma a differenza di Cron che pianifica operazioni periodiche, AT ci permette
 di pianificare operazioni che devono essere effettuate una volta sola.
 Vediamo subito qualche esempio applicativo:
\end_layout

\begin_layout Itemize
at now + 1 minute //esegui le operazioni che ti indicherò dopo l'invio tra
 un minuto, una volta inseriti i comandi, dobbiamo premere Ctr+D per terminare
\end_layout

\begin_layout Itemize
at now + 3 minutes //esegui le operazioni che ti indicherò dopo l'invio
 tra tre minuti, una volta inseriti i comandi, dobbiamo premere Ctr+D per
 terminare
\end_layout

\begin_layout Itemize
atq //visualizza le operazioni pianificate col comando at, e quando verranno
 eseguite
\end_layout

\begin_layout Itemize
at now + 5 hours //esegui le operazioni che ti indicherò dopo l'invio tra
 cinque ore, una volta inseriti i comandi, dobbiamo premere Ctr+D per terminare
\end_layout

\begin_layout Itemize
at 1430 //esegui le operazioni che ti indicherò dopo l'invio alle 14.30,
 una volta inseriti i comandi, dobbiamo premere Ctr+D per terminare
\end_layout

\begin_layout Itemize
at teatime //esegui le operazioni che ti indicherò dopo l'invio alle 4 PM,
 una volta inseriti i comandi, dobbiamo premere Ctr+D per terminare
\end_layout

\begin_layout Itemize
atrm jobNumber //rimuove un'operazione pianificata con 
\begin_inset Quotes eld
\end_inset

at
\begin_inset Quotes erd
\end_inset

, il jobNumber possiamo visualizzarlo eseguendo 
\begin_inset Quotes eld
\end_inset

atq
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Vediamo altri esempi possibili autoesplicativi:
\end_layout

\begin_layout Itemize
at now 2:30 PM tomorrow
\end_layout

\begin_layout Itemize
at 2:30 PM next month
\end_layout

\begin_layout Itemize
at 2:30 PM Fri
\end_layout

\begin_layout Itemize
at 9:00 AM
\end_layout

\begin_layout Itemize
at midnight
\end_layout

\begin_layout Itemize
at noon
\end_layout

\begin_layout Itemize
at 2:30 PM 21.10.14
\end_layout

\begin_layout Itemize
at 2:30 PM 10/21/2014
\end_layout

\begin_layout Itemize
at 4 PM + 2 days
\end_layout

\begin_layout Itemize
at now + 3 weeks
\end_layout

\begin_layout Itemize
at now + 4 months
\end_layout

\begin_layout Itemize
at next monday
\end_layout

\begin_layout Itemize
at now + 5 years
\end_layout

\begin_layout Standard
Alcuni file importanti sono:
\end_layout

\begin_layout Itemize
/etc/at.deny //tutti gli utenti elencati in questo file non possono usare
 at, gli utenti sono separati da un invio
\end_layout

\begin_layout Itemize
/etc/at.allow //a tutti gli utenti del sistema non è possibile usare at eccetto
 a quelli elencati in questo file
\end_layout

\begin_layout Standard
N.B.: Solo uno dei file elencati sopra deve esistere, altrimenti le informazioni
 fornite dai due file sono in conflitto, inoltre è da ricordare che l'utente
 di root è esente da queste regole, root può sempre tutto.
\end_layout

\begin_layout Section
Secure Host
\end_layout

\begin_layout Standard
finger
\end_layout

\begin_layout Section
Accesso Remoto e SSH
\end_layout

\begin_layout Subsection
SSH
\end_layout

\begin_layout Standard
L'accesso remoto ha molteplici vantaggi e utilità, in passato a questo scopo
 veniva molto utilizzato Telnet, ma siccome il protocollo è oggigiorno altamente
 insicuro, è stato sostituito con SSH, che utilizza algoritmi per criptare
 le comunicazioni.
 Il client SSH, è installato di default su tutte le moderne distro, ma nel
 caso ci dovesse servire un server SSH, facciamo:
\end_layout

\begin_layout Itemize
apt-get install openssh-server //installa il server ssh, in una distro Red-Hat
 based avremmo eseguito yum install openssh-server
\end_layout

\begin_layout Standard
Per avviare il servizio ssh, una volta installato eseguiamo:
\end_layout

\begin_layout Itemize
/etc/init.d/ssh restart //riavvia o lancia il servizio ssh, nota che in alcune
 distro, come le Red-Hat based, il servizio è chiamato sshd
\end_layout

\begin_layout Standard
Vediamo ora alcuni comandi per eseguire accesso con ssh:
\end_layout

\begin_layout Itemize
ssh -l nomeUtente 192.168.1.100 //esegue l'accesso ssh, con l'utente nomeUtente
 all'indirizzo ip indicato
\end_layout

\begin_layout Itemize
ssh nomeUtente@192.168.1.100 //analogo al comando precedente
\end_layout

\begin_layout Itemize
ssh -l nomeUtente -v 192.168.1.100 //esegue ssh in modalità verbose, mostrando
 più info per quanto riguarda la connessione, utile per risolvere problemi
\end_layout

\begin_layout Itemize
ssh nomeUtente@192.168.1.114 -t 'command; bash -l' //si connette alla macchina
 ed esegue il comando specificato, dopo il comando apre una shell
\end_layout

\begin_layout Itemize
ssh -l nomeUtente -vv 192.168.1.100 //esegue ssh in modalità + verbose, mostrando
 più info per quanto riguarda la connessione, utile per risolvere problemi
\end_layout

\begin_layout Itemize
ssh -l nomeUtente -vvv 192.168.1.100 //esegue ssh in modalità ancora + verbose
 della precedente, mostrando più info per quanto riguarda la connessione,
 utile per risolvere problemi
\end_layout

\begin_layout Itemize
ssh -i deployment_key.txt demo@192.237.248.66 //effettuo il login, specificando
 la chiave privata ssh dell'account demo, nota che sul file devono essere
 applicati i permessi 600, per farlo prima di eseguire il login eseguiamo:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
chmod 600 deployment_key.txt
\end_layout

\end_deeper
\begin_layout Standard
Una volta eseguito per la prima volta l'accesso, ci verrà chiesto qualora
 vogliamo salvare la chiave RSA, questa chiava verrà salvata in un file
 e ci permetterà di verificare le successive connessioni alla macchina.
 Dopo il primo utilizzo di ssh, troveremo nella directory home una directory
 chiamata 
\begin_inset Quotes eld
\end_inset

.ssh/
\begin_inset Quotes erd
\end_inset

, in questa directory esisterà un file chiamato 
\begin_inset Quotes eld
\end_inset

known_hosts
\begin_inset Quotes erd
\end_inset

, che conterrà le chiavi per verificare le connessioni alle varie macchine
 per cui siamo già stati collegati almeno una volta; nel caso dovessimo
 avere problemi a connetterci ad una macchina a cui siamo stati collegati
 in passato, allora la soluzione è cancellare il file 
\begin_inset Quotes eld
\end_inset

known_hosts
\begin_inset Quotes erd
\end_inset

 o cancellare la voce corrispettiva alla macchina.
\end_layout

\begin_layout Standard
NOTA BENE: Nel caso in cui dopo la prova d'accesso non vedo nessun messaggio,
 cioè nemmeno messaggi d'errore, il problema è il firewall, dovremo infatti
 aprire la porta su cui vogliamo servire il servizio ssh.
\end_layout

\begin_layout Paragraph
Chiavi DSA e RSA
\end_layout

\begin_layout Standard
Un metodo di accesso più semplice è quello di utilizzare chiavi per il login
 anzichè password degli utenti sulla macchina remota, in quanto le password
 degli utenti sono hackabili attraverso bruteforce, non c'è un meccanismo
 di encryption ma solo una verifica degli hash, mentre utilizzando una chiave
 si riesce ad avere un sistema di sicurezza maggiore attraverso un'encrypting
 della passphrase.
 SSH supporta chiavi DSA e RSA, ma la scelta più sicura è RSA, in quanto
 più casuale, quindi più difficile da crackare con un brute-force.
 Possiamo decidere sia algoritmo che grandezza della chiave, vediamo come
 generare una chiave:
\end_layout

\begin_layout Itemize
ssh-keygen -t dsa //crea una chiave di tipo 
\begin_inset Quotes eld
\end_inset

-t
\begin_inset Quotes erd
\end_inset

 DSA, questo genera due file, uno chiamato 
\begin_inset Quotes eld
\end_inset

id_dsa
\begin_inset Quotes erd
\end_inset

 e l'altro chiamato 
\begin_inset Quotes eld
\end_inset

id_dsa.pub
\begin_inset Quotes erd
\end_inset

, il secondo costituisce la chiave pubblica che viene trasmessa quando deve
 avvenire un exchange di chiavi, ed è quello che viene utilizzato per decriptare
 la chiave privata
\end_layout

\begin_layout Standard
Se avessimo voluto creare una chiave rsa, avremmo fatto:
\end_layout

\begin_layout Itemize
ssh-keygen -t rsa //crea una chiave RSA, anche in questo caso vengono generati
 due file
\end_layout

\begin_layout Standard
Una volta generate le chiavi, eseguiamo:
\end_layout

\begin_layout Itemize
ssh-copy-id nomeUtenteConCuiCiVogliamoConnettere@192.168.1.195 //copia le chiavi
 generate e presenti sull'account da cui viene eseguito il comando, (è possibile
 usare il flag 
\begin_inset Quotes eld
\end_inset

-i
\begin_inset Quotes erd
\end_inset

 per specificare file diversi da quello di default), se l'utente ha sia
 file di chiavi DSA che RSA, viene automaticamente scelta la chiave RSA,
 in quanto più sicura, richiederà la password dell'utente.
 Attenzione, l'utente indicato nel comando indica un'utente presente sulla
 macchina remota, e l'indirizzo ip rappresenta la macchina remota
\end_layout

\begin_layout Standard
Una volta eseguito lo scambio di chiavi, possiamo effettuare il login, senza
 specificare l'utente, facendo:
\end_layout

\begin_layout Itemize
ssh 192.168.1.195 //effettua il login, chiedendoci la password relativa alla
 chiave scambiata
\end_layout

\begin_layout Standard
Una volta eseguito il login, possiamo notare sulla macchina remota la generazion
e di un file chiamato 
\begin_inset Quotes eld
\end_inset

authorized keys
\begin_inset Quotes erd
\end_inset

 nella directory dell'utente ssh 
\begin_inset Quotes eld
\end_inset

.ssh/
\begin_inset Quotes erd
\end_inset

, questo file regola gli accessi attraverso le chiavi, o meglio contiene
 la chiave pubblica id_rsa.pub che possiede il client.
 Infatti nel caso lo eliminassimo, allora il login sarebbe ancora disponibile
 ma solo attraverso la password dell'utente, cioè login classico.
 Per una spiegazione dettagliata del funzionamento di SSH, fare riferimento
 a 
\begin_inset CommandInset href
LatexCommand href
name "Guida ad SSH"
target "www.slashroot.in/secure-shell-how-does-ssh-work"

\end_inset

.
\end_layout

\begin_layout Paragraph
SSH-Agent
\end_layout

\begin_layout Standard
E' possibile tenere in memoria le password attraverso ssh-agent, questo
 è un demone che basilarmente tiene salvate le password in memoria, in modo
 che non è necessario reinserire la chiave tutte le volte, possiamo lanciarlo
 attraverso:
\end_layout

\begin_layout Itemize
eval `ssh-agent -s` //esegue in background il programma ssh-agent, con shell
 BASH
\end_layout

\begin_layout Standard
ora possiamo aggiungere le chiavi possedute all'agent eseguendo:
\end_layout

\begin_layout Itemize
ssh-add //aggiunge le chiavi presenti nella home directory dell'utente all'agent
\end_layout

\begin_layout Standard
Ora, per tutto il tempo per cui saremo connessi, non dovremo più usare la
 passphrase, possiamo verificare la corretta memorizzazione delle password,
 eseguendo un:
\end_layout

\begin_layout Itemize
ssh-add -l //visualizza gli utenti ssh per cui è memorizzata la password
\end_layout

\begin_layout Paragraph
SSH Config Files
\end_layout

\begin_layout Standard
Nella directory 
\begin_inset Quotes eld
\end_inset

/etc/ssh
\begin_inset Quotes erd
\end_inset

 troviamo file di configurazione di ssh, e una serie di chiavi utilizzate
 dal sistema come seme per generare le chiavi dei vari utenti; i due file
 principali sono:
\end_layout

\begin_layout Itemize
/etc/ssh/ssh_config //costituisce il file di configurazione per il client
 SSH, ad esempio se usiamo di default una porta diversa dalla 22, per l'ssh,
 qui possiamo inserire 
\begin_inset Quotes eld
\end_inset

Port 34213
\begin_inset Quotes erd
\end_inset

 nel caso volessimo usare la porta 34213 di default, in questo modo non
 dobbiamo tutte le volte inserire il flag 
\begin_inset Quotes eld
\end_inset

-p
\begin_inset Quotes erd
\end_inset

 per specificare la porta
\end_layout

\begin_layout Itemize
/etc/ssh/sshd_config //costituisce il file di configurazione per il server
 SSH
\end_layout

\begin_layout Standard
una configurazione utile lato client, se non volessimo che la connessione
 cadesse con un server ssh, è quella di configurare l'invio periodico di
 pacchetti null, possiamo effettuare questa configurazione andando a mettere
 la stringa: 
\begin_inset Quotes eld
\end_inset

ServerAliveInterval 10
\begin_inset Quotes erd
\end_inset

 all'interno di /etc/ssh/ssh_config o /etc/ssh_config.
\end_layout

\begin_layout Standard
Inoltre per chiudere una connessione ssh bloccata possiamo utilizzare il
 carattere di escape di ssh che è 
\begin_inset Quotes eld
\end_inset

~.
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsubsection
SSH ed X
\end_layout

\begin_layout Standard
E' possibile utilizzare ssh e poter runnare programmi grafici, per poter
 effettuare questo, lato server dobbiamo abilitare la voce 
\begin_inset Quotes eld
\end_inset

X11Forwarding yes
\begin_inset Quotes erd
\end_inset

 nel file 
\begin_inset Quotes eld
\end_inset

/etc/ssh/sshd_config
\begin_inset Quotes erd
\end_inset

, mentre lato client ci basterà eseguire:
\end_layout

\begin_layout Itemize
export DISPLAY=:0.0
\end_layout

\begin_layout Itemize
ssh -X nomeUtente@192.168.1.114 //in questo caso stiamo abilitando l'X forwarding
 lato client
\end_layout

\begin_layout Standard
ora potremo avviare qualsiasi applicazione grafica, quindi ad esempio 
\begin_inset Quotes eld
\end_inset

firefox
\begin_inset Quotes erd
\end_inset

 o qualsiasi altra cosa, e vedremo una finestra separata aprirsi, lato client
 ssh.
\end_layout

\begin_layout Subsubsection
SSHFS
\end_layout

\begin_layout Standard
SSHFS è un file system per i sistemi operativi unix-like (Mac OS X, Linux,
 BSD).
 Questo file system permette di montare in locale una directory posizionata
 su un server remoto in cui gira SSH, similmente a quanto avviene con le
 cartelle condivise di netbios/samba ma con il vantaggio di avere una connession
e cifrata non intercettabile (tramite ssh).
 Questo software implementa il modulo del kernel FUSE.
 Possiamo installarlo, eseguendo:
\end_layout

\begin_layout Itemize
sudo apt-get install sshfs fuse
\end_layout

\begin_layout Standard
poi ci assicuriamo che il modulo fuse sia caricato all'interno del kernel:
\end_layout

\begin_layout Itemize
lsmod | grep fuse //visualizza se il modulo del kernel 
\begin_inset Quotes eld
\end_inset

fuse
\begin_inset Quotes erd
\end_inset

 è caricato o meno, se non caricato, dobbiamo caricarlo
\end_layout

\begin_layout Standard
poi dobbiamo aggiungere l'utente di root al gruppo fuse, eseguendo ad esempio:
\end_layout

\begin_layout Itemize
useradd root fuse //aggiunge l'utente root al gruppo fuse, se il gruppo
 fuse non esiste, dobbiamo crearlo
\end_layout

\begin_layout Standard
Poi creiamo la directory in cui vogliamo montare il filesystem con:
\end_layout

\begin_layout Itemize
sudo mkdir /mnt/sshfs_home_milano //crea una directory, questa directory
 verrà usata per hostare la directory remota
\end_layout

\begin_layout Itemize
chown root /backup
\end_layout

\begin_layout Standard
Vediamo il comando per effettuare il mount:
\end_layout

\begin_layout Itemize
sshfs -o idmap=user andrew@192.168.0.69:/home/utente_remoto /mnt/sshfs_home_milano
 //montiamo la directory /etc della macchina remota all'indirizzo IP indicato
 nella directory in /mnt/etc_on_server/, nota che l'opzione -o idmap=user
 deve essere ricopiata così com'è, cioè NON dobbiamo sostituire a 
\begin_inset Quotes eld
\end_inset

user
\begin_inset Quotes erd
\end_inset

 il nostro nome utente.
\end_layout

\begin_layout Standard
Possiamo eventualmente (opzionale) aggiungere la partizione ad fstab, con
 una voce del tipo:
\end_layout

\begin_layout Standard
——————————————————————————–————————————-
\end_layout

\begin_layout Standard
sshfs#user@remote.machine.net:/remote/dir /work fuse user,_netdev,reconnect,uid=10
00,gid=1000,idmap=user,allow_other
\end_layout

\begin_layout Standard
0 0
\end_layout

\begin_layout Standard
——————————————————————————–————————————-
\end_layout

\begin_layout Subsubsection
SCP
\end_layout

\begin_layout Standard
Per copiare file attraverso ssh, possiamo utilizzare il comando 
\begin_inset Quotes eld
\end_inset

scp
\begin_inset Quotes erd
\end_inset

, la sintassi è questa:
\end_layout

\begin_layout Itemize
scp nomeFile nomeUtente@ipAddress:/path/to/Dir //in questo caso copiamo
 un file dalla nostra macchina ad un server remoto
\end_layout

\begin_layout Itemize
scp -r /media/disk/estate_pics/ mike@192.168.1.1:"/var/www/Estate 2014/" //in
 questo caso viene copiata una directory attraverso il flag 
\begin_inset Quotes eld
\end_inset

-r
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Subsubsection
SFTP
\end_layout

\begin_layout Standard
Per avere un'interfaccia più comoda per il trasferimento file, possiamo
 utilizzare il protocollo 
\begin_inset Quotes eld
\end_inset

sftp
\begin_inset Quotes erd
\end_inset

, cioè una versione criptata del protocollo 
\begin_inset Quotes eld
\end_inset

ftp
\begin_inset Quotes erd
\end_inset

, solitamente è installato in automatico, una volta installato un server
 ssh, possiamo accedere alla comoda interfaccia per il trasferimento file,
 attraverso:
\end_layout

\begin_layout Itemize
sftp linus@kernel.org //si connette all'sftp del dominio specificato
\end_layout

\begin_layout Standard
oppure se è stato impostato un server ssh, possiamo utilizzare:
\end_layout

\begin_layout Itemize
sftp nomeUtente@ipAddress //cioè proprio come un normale accesso ssh, infatti
 il trasferimento file avviene nei termini del protocollo ssh
\end_layout

\begin_layout Itemize
sftp -P 4555 nomeUtente@ipAddress //avvia sftp sulla porta specificata
\end_layout

\begin_layout Standard
una volta effettuato l'accesso possiamo eseguire diverse operazioni interessanti
, ad esempio:
\end_layout

\begin_layout Itemize
ls //mostra i file sulla macchina remota
\end_layout

\begin_layout Itemize
lls //mostra i file sulla macchina locale, è da notare che i noti comandi
 preceduti da 
\begin_inset Quotes eld
\end_inset

l
\begin_inset Quotes erd
\end_inset

, indicano un'esecuzione sulla nostra macchina
\end_layout

\begin_layout Itemize
cd nome/dir //cambia directory sulla macchina remota
\end_layout

\begin_layout Itemize
lcd nome/dir //cambia directory sulla nostra macchina locale
\end_layout

\begin_layout Itemize
get nomeFile //scarica il file dalla presente nella macchina remota e lo
 mette sulla macchina locale nella directory corrente (visualizzabile con
 lpwd)
\end_layout

\begin_layout Itemize
get nomeFile /home/giuseppe/miaDir/mioFile //scarica il file dalla presente
 nella macchina remota e lo mette sulla macchina locale nella directory
 specificata nel comando
\end_layout

\begin_layout Itemize
get -r percorso/nomeDir //scarica in locale la directory, 
\begin_inset Quotes eld
\end_inset

-r
\begin_inset Quotes erd
\end_inset

 sta per recursively, ed è utilizzato per trasferire directory intere
\end_layout

\begin_layout Itemize
put nomeFile //fa l'upload di un file presente sulla macchina locale nella
 directory corrente della macchina remota (visualizzabile con pwd)
\end_layout

\begin_layout Itemize
put nomeFile /nomeDir/remota/nomeFile //fa l'upload di un file presente
 sulla macchina locale nella directory specificata sulla macchina remota
\end_layout

\begin_layout Itemize
put -r percorso/nomeDir //fa l'upload della directory, 
\begin_inset Quotes eld
\end_inset

-r
\begin_inset Quotes erd
\end_inset

 sta per recursively, ed è utilizzato per trasferire directory intere, attenzion
e la directory deve esistere sul server remoto, se non esiste la copia non
 avviene, infatti in genere uqesto comando è preceduto da 
\begin_inset Quotes eld
\end_inset

mkdir percorso/nomeDir
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
!nomeComando //esegue il comando 
\begin_inset Quotes eld
\end_inset

nomeComando
\begin_inset Quotes erd
\end_inset

 sulla macchina locale
\end_layout

\begin_layout Itemize
? //mostra l'help, utile per quando non ricordiamo alcuni comandi o la loro
 sintassi
\end_layout

\begin_layout Standard
E' da notare che la maggior parte dei comandi (forse tutti) funzionano anche
 per il protocollo ftp e quindi la maggior parte (forse tutti) i client
 ftp, anche se l'utilizzo di un sistema ftp, è fortemente sconsigliato per
 i noti problemi di sicurezza.
 Una valida ed equivalente alternativa (sotto certi aspetti) al protocollo
 SFTP è il protocollo FTPS.
\end_layout

\begin_layout Subsubsection
Alcuni Trucchi con SSH
\end_layout

\begin_layout Itemize
ssh nomeUtente@macchina cat 
\begin_inset Quotes eld
\end_inset

Videos/Path/To/Video.mp4
\begin_inset Quotes erd
\end_inset

 | vlc - //questo ci permette di visualizzare un video in locale senza dover
 effettuare il forwarding di X o avviare sftp/scp, una cosa simile può essere
 fatta anche per le immagini, con un adeguato lettore di immagini, dobbiamo
 stare attenti a specificare bene il percorso 
\end_layout

\begin_layout Subsection
OpenPGP
\end_layout

\begin_layout Standard
OpenPGP è uno standard Internet per l'interoperabilità dei messaggi protetti
 tramite crittografia asimmetrica.
 I due più comuni programmi che utilizzano OpenPGP sono:
\end_layout

\begin_layout Itemize
Pretty Good Privacy (PGP), erede diretto della versione iniziale di Phil
 Zimmermann e ora prodotto commerciale della PGP Corporation 
\end_layout

\begin_layout Itemize
GNU Privacy Guard (GPG), sua alternativa GPL
\end_layout

\begin_layout Subsubsection
Principio di funzionamento
\end_layout

\begin_layout Standard
Un utente può generare attraverso PGP una chiave composta da una parte pubblica
 e una parte privata, lui condivide al mondo la parte pubblica, ma deve
 proteggere e salvaguardare la sua parte privata.
 Riporto una conversazione IRC che spiega qual'è il meccanismo di base di
 PGP:
\end_layout

\begin_layout Standard
——————————————————————————–——————
\end_layout

\begin_layout Standard
<nebbia> can somebody explain me how GPG works ? 
\end_layout

\begin_layout Standard
<BasketCase> nebbia: it is the same key pair concept where one key decrypts
 what the other encrypts <BasketCase> this is one of the better explanations
 I have seen: http://maths.straylight.co.uk/archives/108 
\end_layout

\begin_layout Standard
<BasketCase> essentially, if someone wants to send you a secret they encrypt
 it with your public key.
 now only you with your private key can decrypt it.
 
\end_layout

\begin_layout Standard
<BasketCase> if someone wants to verify that you signed something they decrypt
 the signature with your public key verifying that it was made by your private
 key (this is close to key authentication in ssh) 
\end_layout

\begin_layout Standard
<BasketCase> ooh, there is a video version of that explanation: http://www.youtub
e.com/watch?&v=3QnD2c4Xovk
\end_layout

\begin_layout Standard
<nebbia> BasketCase i was thinking about what you said...
 
\end_layout

\begin_layout Standard
<nebbia> but the first case is clear 
\end_layout

\begin_layout Standard
<nebbia> but the second...
 how can somebody verify that i signed something ? 
\end_layout

\begin_layout Standard
<nebbia> with only my public key ? 
\end_layout

\begin_layout Standard
<BasketCase> ok, you take a hash of the "something".
 say an sha256 hash.
 Then you encrypt that hash with your private key.
 <nebbia> ok what is this something ? my signature ?
\end_layout

\begin_layout Standard
<BasketCase> the other person hashes the same something, decrypts your encrypted
 hash using your public key and compares them.
 If the hashes match you signed it AND it hasn't been modified
\end_layout

\begin_layout Standard
<BasketCase> "something" in that context means whatever data you are signing
 
\end_layout

\begin_layout Standard
<nebbia> ohh ok ...
 thank you ! 
\end_layout

\begin_layout Standard
<BasketCase> so, if I make a file, sha256sum it, then encrypt the hash with
 my private key you only need my public key and the sha256sum tool to verify
 that I sent you that file
\end_layout

\begin_layout Standard
——————————————————————————–——————
\end_layout

\begin_layout Standard
Un video esplicativo, è questo 
\begin_inset CommandInset href
LatexCommand href
name "Spiegazione PGP"
target "https://www.youtube.com/watch?&v=3QnD2c4Xovk"

\end_inset

.
\end_layout

\begin_layout Subsubsection
GnuPG su sistemi GNU/Linux
\end_layout

\begin_layout Standard
Per installare GnuPG, eseguiamo:
\end_layout

\begin_layout Itemize
apt-get install gnupg //installa gnupg
\end_layout

\begin_layout Standard
Vediamo ora alcuni esempi di comandi:
\end_layout

\begin_layout Itemize
gpg –gen-key //esegue una procedura guidata per generare le chiavi, alla
 fine di questa procedura verrà chiesta una passphrase e successivamente
 viene creata una directory chiamata 
\begin_inset Quotes eld
\end_inset

.gnupg/
\begin_inset Quotes erd
\end_inset

 dove saranno contenute le chiavi
\end_layout

\begin_layout Itemize
gpg –list-keys //elenca le chiavi possedute
\end_layout

\begin_layout Itemize
gpg –export -a 
\begin_inset Quotes eld
\end_inset

Giuseppe Nebbione
\begin_inset Quotes erd
\end_inset

 > public.key //attenzione, il nome deve essere uguale a quello inserito
 all'interno della procedura guidata per la chiave privata
\end_layout

\begin_layout Itemize
gpg –send-keys 'Giuseppe Nebbione' –keyserver hkp://subkeys.pgp.net //invia
 le chiavi ad un sito che raccoglie tutte le chiavi pubbliche
\end_layout

\begin_layout Itemize
gpg –import pubkey.txt //importa una chiave pubblica
\end_layout

\begin_layout Itemize
gpg –recv-keys user@mail.net –keyserver hkp://subkeys.pgp.net //importa dal
 sito raccoglitore di chiavi la chiave pubblica corrispondente alla mail
 
\begin_inset Quotes eld
\end_inset

user@mail.net
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
gpg –encrypt –recipient 
\begin_inset Quotes eld
\end_inset

Nome Destinatario
\begin_inset Quotes erd
\end_inset

 nome_file_da_cifrare //esempio di cifratura di un file
\end_layout

\begin_layout Itemize
gpg –delete-key 
\begin_inset Quotes eld
\end_inset

Giuseppe Nebbione
\begin_inset Quotes erd
\end_inset

 //rimuove la chiave pubblica menzionata
\end_layout

\begin_layout Itemize
gpg –delete-secret-keys 
\begin_inset Quotes eld
\end_inset

Giuseppe Nebbione
\begin_inset Quotes erd
\end_inset

 //rimuove la chiave privata menzionata
\end_layout

\begin_layout Standard
Un sito utile per ricercare chiavi pubbliche al momento è 
\begin_inset CommandInset href
LatexCommand href
name "Chiavi Pubbliche PGP"
target "https://keyserver.pgp.com/vkd/GetWelcomeScreen.event"

\end_inset

.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Section
Web Server
\end_layout

\begin_layout Standard
Vediamo qui alcune configurazioni del web server più famoso, cioè 
\begin_inset Quotes eld
\end_inset

Apache
\begin_inset Quotes erd
\end_inset

, una volta installato con:
\end_layout

\begin_layout Itemize
apt install apache2 
\end_layout

\begin_layout Standard
oppure
\end_layout

\begin_layout Itemize
yum install httpd
\end_layout

\begin_layout Standard
dobbiamo abilitare il servizio di apache attraverso ad esempio:
\end_layout

\begin_layout Itemize
systemctl start apache2
\end_layout

\begin_layout Standard
una volta abilitato, possiamo leggere i log all'interno di 
\begin_inset Quotes eld
\end_inset

/var/log/apache2/
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Itemize
tail -f /var/log/apache2/* //leggo i log in runtime
\end_layout

\begin_layout Standard
la directory di default varia da distro a distro, comunque solitamente è
 in 
\begin_inset Quotes eld
\end_inset

/var/www
\begin_inset Quotes erd
\end_inset

 oppure in 
\begin_inset Quotes eld
\end_inset

/srv/www/htdocs
\begin_inset Quotes erd
\end_inset

, ma potrebbe essere anche in altre directory.
 Il file di configurazione di apache2 è in 
\begin_inset Quotes eld
\end_inset

/etc/apache2
\begin_inset Quotes erd
\end_inset

, anche in questo caso varia da distro a distro ma è o 
\begin_inset Quotes eld
\end_inset

apache2.conf
\begin_inset Quotes erd
\end_inset

 o 
\begin_inset Quotes eld
\end_inset

httpd.conf
\begin_inset Quotes erd
\end_inset

 Vediamo ora alcune configurazioni comuni.
\end_layout

\begin_layout Standard
Siccome configurazioni diverse possono essere in file diversi è bene eseguire
 dei 
\begin_inset Quotes eld
\end_inset

grep -nir configurazioneCercata
\begin_inset Quotes erd
\end_inset

 per cercare le configurazioni.
\end_layout

\begin_layout Subsection
Configurazione centralizzata vs Configurazione decentralizzata
\end_layout

\begin_layout Standard
Apache mantiene i file di configurazione nella directory /etc/, ad ogni
 modo è possibile avere dei file di configurazione per directory, chiamati
 
\begin_inset Quotes eld
\end_inset

.htaccess
\begin_inset Quotes erd
\end_inset

, l'utilizzo di questi file è consigliato solo se non si hanno i permessi
 di accesso all'intero server, in quanto implica degli slow down significativi
 alla navigazione, questi file potrebbero ad esempio essere utilizzati da
 servizi di hosting quando ci viene fornita solo una directory all'interno
 di un server.
 Quindi nel momento in cui abbiamo accesso completo al server le impostazioni
 che dovremmo mettere nel file .htaccess le andiamo a mettere nelle varie
 sezioni 
\begin_inset Quotes eld
\end_inset

<Directory>
\begin_inset Quotes erd
\end_inset

 dei file di ocnfigurazione principali.
 Ad ogni modo l'utilizzo dei file 
\begin_inset Quotes eld
\end_inset

.htaccess
\begin_inset Quotes erd
\end_inset

 deve essere permesso comunque dalla configurazione principale di Apache
 (i.e., quella nei file /etc/), l'opzione che disabilita questa impostazione
 è:
\end_layout

\begin_layout Itemize
AllowOverride None //disabilito l'utilizzo dei file .htaccess all'interno
 della directory a cui fa parte questa configurazione
\end_layout

\begin_layout Standard
per abilitare l'utilizzo dei file 
\begin_inset Quotes eld
\end_inset

.htaccess
\begin_inset Quotes erd
\end_inset

 invece dobbiamo avere:
\end_layout

\begin_layout Itemize
AllowOverride All //abilito l'utilizzo dei file .htaccess all'interno della
 directory a cui fa parte questa configurazione
\end_layout

\begin_layout Subsection
Directory Listing
\end_layout

\begin_layout Standard
Basta aggiungere nel file di configurazione di apache in una delle 
\begin_inset Quotes eld
\end_inset

<Directory>
\begin_inset Quotes erd
\end_inset

 e facciamo:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<Directory "/var/www/html">     
\end_layout

\begin_layout Plain Layout

	# Show directory listing, and allow symbolic links
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

	Options Indexes FollowSymLinks       
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	# With the following option we impose that configuration cannot be overriden
 with .htaccess files.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	AllowOverride None
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	# With the following options we controls who can get stuff from this server
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

	Order allow,deny     
\end_layout

\begin_layout Plain Layout

	Allow from all 
\end_layout

\begin_layout Plain Layout

</Directory>
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Mod Rewrite
\end_layout

\begin_layout Subsubsection
Redirection di qualsiasi richiesta all'interno di una directory
\end_layout

\begin_layout Standard
Possiamo all'interno di una configurazione 
\begin_inset Quotes eld
\end_inset

<Directory>
\begin_inset Quotes erd
\end_inset

 includere il modulo 
\begin_inset Quotes eld
\end_inset

mod_rewrite.c
\begin_inset Quotes erd
\end_inset

 e gestire redirections, ad esempio:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<IfModule mod_rewrite.c>
\end_layout

\begin_layout Plain Layout

	RewriteEngine on
\end_layout

\begin_layout Plain Layout

	RewriteRule (.*) webroot/ [L]
\end_layout

\begin_layout Plain Layout

</IfModule>
\end_layout

\begin_layout Plain Layout

#in questo caso (.*) significa qualsiasi stringa
\end_layout

\end_inset


\end_layout

\begin_layout Standard
in questo caso ad ogni richiesta redirigo alla directory webroot/, il flag
 
\begin_inset Quotes eld
\end_inset

[L]
\begin_inset Quotes erd
\end_inset

 serve ad indicare che questa è una richiesta 
\begin_inset Quotes eld
\end_inset

last
\begin_inset Quotes erd
\end_inset

, cioè eseguita questa le eventuali prossime richieste non devono essere
 eseguite, questa è equivalente ad un 
\begin_inset Quotes eld
\end_inset

break;
\begin_inset Quotes erd
\end_inset

 in altri linguaggi di programmazione, per le rewrite rule, il primo parametro
 è un regular expression e la seconda è un indirizzo a cui redirigere, il
 terzo campo è composto dagli eventuali flag.
\end_layout

\begin_layout Subsubsection
Se un file richiesto non esiste eseguire un determinato script
\end_layout

\begin_layout Standard
In questo caso si utilizzano le condizioni 
\begin_inset Quotes eld
\end_inset

RewriteCond
\begin_inset Quotes erd
\end_inset

, la meccanica è questa, se tutte le rewrite condition sono vere (bisogna
 considerarle in AND logico) allora viene eseguita l'istruzione successiva
 
\begin_inset Quotes eld
\end_inset

RewriteRule
\begin_inset Quotes erd
\end_inset

.
 In pratica quello che avviene è, se la risorsa richiesta non è un file
 e non è una directory (cioè se non esiste) allora si esegue la rewrite
 rule, in questo caso si esegue lo script chiamato 
\begin_inset Quotes eld
\end_inset

script.php
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<IfModule mod_rewrite.c>
\end_layout

\begin_layout Plain Layout

	RewriteEngine on
\end_layout

\begin_layout Plain Layout

	RewriteCond %{REQUEST_FILENAME} !-f
\end_layout

\begin_layout Plain Layout

	RewriteCond %{REQUEST_FILENAME} !-d 
\end_layout

\begin_layout Plain Layout

	RewriteRule ^(.*)$ script.php [PT,L]
\end_layout

\begin_layout Plain Layout

</IfModule>
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Porta del Server
\end_layout

\begin_layout Standard
Possiamo cercare la porta su cui è in ascolto apache eseguendo nella directory
 in cui sono contenuti i file di configurazione di apache:
\end_layout

\begin_layout Itemize
grep -nir listen 
\end_layout

\begin_layout Standard
Possiamo mettere apache in ascolto su un'altra porta attraverso:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

# Listen: Allows you to bind Apache to specific IP addresses and/or ports.
 
\end_layout

\begin_layout Plain Layout

Listen 8000
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Virtual Hosts
\end_layout

\begin_layout Standard
Per impostare virtual host localmente (ad esempio per testare diverse web
 applications in locale), allora innanzitutto dobbiamo assegnare a 
\begin_inset Quotes eld
\end_inset

localhost
\begin_inset Quotes erd
\end_inset

 (i.e., 127.0.0.1) i vari nomi dei domini, quindi nel file 
\begin_inset Quotes eld
\end_inset

/etc/hosts
\begin_inset Quotes erd
\end_inset

 andremo a scrivere:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

127.0.0.1 myfirstwebapp
\end_layout

\begin_layout Plain Layout

127.0.0.1 mysecondwebapp
\end_layout

\begin_layout Plain Layout

127.0.0.1 mythirdwebapp
\end_layout

\end_inset


\end_layout

\begin_layout Standard
una volta scritti questi, nella configurazione di apache principale, quella
 dove sono segnati i 
\begin_inset Quotes eld
\end_inset

localhost
\begin_inset Quotes erd
\end_inset

, ad esempio su debian in 
\begin_inset Quotes eld
\end_inset

/etc/apache2/sites-enabled/000-default.conf
\begin_inset Quotes erd
\end_inset

 e qui dovremo avere una configurazione del tipo:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<VirtualHost *:80>
\end_layout

\begin_layout Plain Layout

	#Con ServerName impostiamo il nome del dominio
\end_layout

\begin_layout Plain Layout

	ServerName myfirstwebapp
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	#Con DocumentRoot impostiamo la directory in cui è contenuta la web app
\end_layout

\begin_layout Plain Layout

	DocumentRoot /var/www/html/myfirst
\end_layout

\begin_layout Plain Layout

</VirtualHost> 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<VirtualHost *:80>
\end_layout

\begin_layout Plain Layout

	ServerName mysecondwebapp
\end_layout

\begin_layout Plain Layout

	DocumentRoot /var/www/html/mysecond
\end_layout

\begin_layout Plain Layout

</VirtualHost>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<VirtualHost *:80>
\end_layout

\begin_layout Plain Layout

	ServerName mythirdwebapp
\end_layout

\begin_layout Plain Layout

	DocumentRoot /var/www/html/mythirdandlast
\end_layout

\begin_layout Plain Layout

</VirtualHost> 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
la configurazione è identica per siti web hostati sullo stesso webserver,
 ricordiamo che i virtual host sono supportati dalla versione 1.1 dell'HTTP.
\end_layout

\begin_layout Section
NFS
\end_layout

\begin_layout Standard
NFS (Network File System) is a distributed file system protocol originally
 developed by Sun in 1984.
 allowing a user on a client computer to access files over a computer network
 much like local storage is accessed.
 NFS, like many other protocols, builds on the Open Network Computing Remote
 Procedure Call (ONC RPC) system.
 On a debian machine we can check if we support NFS with:
\end_layout

\begin_layout Itemize
grep NFSD /boot/config-`uname -r`
\end_layout

\begin_layout Standard
more generally with any other distros we should check the kernel configuration
 file.
\end_layout

\begin_layout Subsection
Server-Side
\end_layout

\begin_layout Standard
On the server we install:
\end_layout

\begin_layout Itemize
sudo apt-get install nfs-kernel-server
\end_layout

\begin_layout Standard
then we create the directory we want to share, for example:
\end_layout

\begin_layout Itemize
sudo mkdir /var/nfsroot //we create a directory in 
\begin_inset Quotes eld
\end_inset

/var
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
then, we have the table of exports in the file 
\begin_inset Quotes eld
\end_inset

/etc/exports
\begin_inset Quotes erd
\end_inset

, in this file we add a line with:
\end_layout

\begin_layout Itemize
/var/nfsroot <client private ip>/32(rw,root_squash,subtree_check) //where
 for client private ip we put the ip address or an entire subnet, notice
 that since we put root_squash, in this case the root account on the client
 machine will have the same privilege level as the root on the server machine.
 This option has security implications; do not use unless you are sure you
 need it.
\end_layout

\begin_layout Standard
we then update the table of exported directories with:
\end_layout

\begin_layout Itemize
sudo exportfs -a
\end_layout

\begin_layout Standard
and we have to be sure of having the daemon started with:
\end_layout

\begin_layout Itemize
sudo service nfs-kernel-server start //starts the kernel, even a 
\begin_inset Quotes eld
\end_inset

restart
\begin_inset Quotes erd
\end_inset

 could be used
\end_layout

\begin_layout Standard
Notice that in order to not give root access to the filesystem to any NFS
 client, all queries appearing to come from a root user are considered by
 the server as coming from the nobody user.
 This behavior corresponds to the root_squash option, and is enabled by
 default.
 The no_root_squash option, which disables this behavior, is risky and should
 only be used in controlled environments.
 The anonuid=uid and anongid=gid options allow specifying another fake user
 to be used instead of UID/GID 65534 (which corresponds to user nobody and
 group nogroup).
 
\end_layout

\begin_layout Subsubsection
Example
\end_layout

\begin_layout Standard
Let's see some example of sharing directory:
\end_layout

\begin_layout Itemize
mkdir /home/client1; chown nobody:nogroup /home/client1; chmod 755 /home/client1
 //in this case we are sharing a directory the owner user and owner group
 should be these ones, if we want the directory to be writeable by clients,
 even in this case they must be root
\end_layout

\begin_layout Standard
the following step is adding this directory to the NFS configuration file
 
\begin_inset Quotes eld
\end_inset

/etc/exports
\begin_inset Quotes erd
\end_inset

 with:
\end_layout

\begin_layout Itemize
/home/client1 192.168.0.101/32(rw,root_squash,subtree_check) //here we share
 the directory, we use default options
\end_layout

\begin_layout Subsubsection
Server-Side Options
\end_layout

\begin_layout Standard
Let's see some of the possible options we can set server-side, these options
 can be specified in the /etc/exports entry:
\end_layout

\begin_layout Itemize
rw: Read/write filesystem.
 
\end_layout

\begin_layout Itemize
ro: Force clients to connect in the read-only filesystem mode only.
 
\end_layout

\begin_layout Itemize
no_root_squash: The root account on the client machine will have the same
 privilege level as the root on the server machine.
 This option has security implications; do not use unless you are sure you
 need it.
 
\end_layout

\begin_layout Itemize
no_subtree_check: Disable file location checks on partial volume exports.
 This option will speed up transfers on full volume exports.
 
\end_layout

\begin_layout Itemize
sync: Force all transfers to operate in synchronous mode, so all clients
 will wait until their operations are really done.
 This can avoid data corruption in the event of a server crash.
\end_layout

\begin_layout Subsection
Client-Side
\end_layout

\begin_layout Standard
On the client side what we do is:
\end_layout

\begin_layout Itemize
sudo apt-get install nfs-common
\end_layout

\begin_layout Standard
then we create the local directory where we will mount our remote directory
 with:
\end_layout

\begin_layout Itemize
sudo mkdir /mnt/remotenfs 
\end_layout

\begin_layout Standard
then we add the following line to the /etc/fstab file:
\end_layout

\begin_layout Itemize
<server private ip>:/var/nfsroot /mnt/remotenfs nfs rw,async,hard,intr 0
 0
\end_layout

\begin_layout Standard
then we can mount the directory with:
\end_layout

\begin_layout Itemize
sudo mount /mnt/remotenfs 
\end_layout

\begin_layout Standard
In order to see on which port nfs is listening we do:
\end_layout

\begin_layout Itemize
sudo rpcinfo -p 192.168.0.102 //here we will see various rows, what we are
 interested is the presence of 
\begin_inset Quotes eld
\end_inset

NFS
\begin_inset Quotes erd
\end_inset

 and its port, notice that the default port is 2049
\end_layout

\begin_layout Standard
then we can see which directories are shared by the server by doing:
\end_layout

\begin_layout Itemize
sudo showmount -e 192.168.0.102 //in this way we show which directories are
 shared by the mentioned server IP address
\end_layout

\begin_layout Subsubsection
Client-Side Options
\end_layout

\begin_layout Standard
Let's see some of the possible options we have 
\begin_inset Quotes eld
\end_inset

Client-Side
\begin_inset Quotes erd
\end_inset

, these options can be specified using the mount command, or in the /etc/fstab
 entry:
\end_layout

\begin_layout Itemize
rw: Read/write filesystem.
 
\end_layout

\begin_layout Itemize
ro: Read-only filesystem.
 Remote NFS clients can’t modify the filesystem.
 
\end_layout

\begin_layout Itemize
hard: Applications using files stored on an NFS will always wait if the
 server goes down.
 User cannot terminate the process unless the option intr is set.
\end_layout

\begin_layout Itemize
soft: Applications using files stored on an NFS will wait a specified time
 (using the timeo option) if the server goes down, and after that, will
 throw an error.
\end_layout

\begin_layout Itemize
intr: Allows user interruption of processes waiting on a NFS request.
 
\end_layout

\begin_layout Itemize
timeo=<num>: For use with the soft option.
 Specify the timeout for an NFS request.
 
\end_layout

\begin_layout Itemize
nolock: Disable file locks.
 Useful with older NFS servers.
 
\end_layout

\begin_layout Itemize
noexec: Disable execution of binaries or scripts on an NFS share.
 
\end_layout

\begin_layout Itemize
nosuid: Prevents users from gaining ownership of files on the NFS share.
 
\end_layout

\begin_layout Itemize
rsize=<num>: Sets the read block data size.
 Defaults to 8192 on NFSv2 and NFSv3, and 32768 on NFSv4.
 
\end_layout

\begin_layout Itemize
wsize=<num>: Sets the write block data size.
 Defaults to 8192 on NFSv2 and NFSv3, and 32768 on NFSv4.
\end_layout

\begin_layout Section
DNS Server
\end_layout

\begin_layout Standard
We can install various dns servers, a common one is 
\begin_inset Quotes eld
\end_inset

bind
\begin_inset Quotes erd
\end_inset

 also found as 
\begin_inset Quotes eld
\end_inset

bind9
\begin_inset Quotes erd
\end_inset

, we can install this package on our distro, una volta installato possiamo
 verificare che sia in running controllando quale processo sta occupando
 la porta 53 (porta usata dal protocollo DNS), attraverso:
\end_layout

\begin_layout Itemize
sudo netstat -ntlp //mostra i processi attivi sulle relative porte
\end_layout

\begin_layout Standard
dovremo vedere un processo chiamato 
\begin_inset Quotes eld
\end_inset

named
\begin_inset Quotes erd
\end_inset

, che corrisponde proprio a bind, nel caso in cui bind si sia appropriato
 dell'indirizzo di localhost possiamo testarlo eseguendo:
\end_layout

\begin_layout Itemize
dig www.example.com @127.0.0.1 //esegue una query dns utilizzando come local
 nameserver localhost, dobbiamo verificare che la 
\begin_inset Quotes eld
\end_inset

answer section
\begin_inset Quotes erd
\end_inset

 sia valida, se è valida allora il demone sta funzionando correttamente
\end_layout

\begin_layout Standard
Ricordiamo che di default bind funziona in modalità 
\begin_inset Quotes eld
\end_inset

caching-only
\begin_inset Quotes erd
\end_inset

 mode, so no information is cached (stored persistently).
 
\end_layout

\begin_layout Standard
N.B.: Everytime we want to clear the cache of a DNS server it is sufficient
 to just restart the relative daemon.
\end_layout

\begin_layout Subsection
Configurazione di BIND
\end_layout

\begin_layout Standard
Per visualizzare dove è presente il file di configurazione di bind ci basterà
 dare un'occhiata ai file installati col pacchetto, quindi possiamo ad esempio
 in una distro Debian-based eseguire:
\end_layout

\begin_layout Itemize
dpkg -L bind9 //mostra i file installati dal paccheto
\end_layout

\begin_layout Standard
a questo punto scopriamo che il file di configurazione principale è in 
\begin_inset Quotes eld
\end_inset

/etc/bind/named.conf
\begin_inset Quotes erd
\end_inset

 che è leggibile in genere, mentre un altro file di configurazione chiamato
 
\begin_inset Quotes eld
\end_inset

/etc/bind/rndc.key
\begin_inset Quotes erd
\end_inset

 è leggibile solo dall'utente e dal gruppo 
\begin_inset Quotes eld
\end_inset

bind
\begin_inset Quotes erd
\end_inset

.
 Possiamo controllare la versione di bind utilizzando:
\end_layout

\begin_layout Itemize
named -v //mostra la versione
\end_layout

\begin_layout Itemize
named -V //mostra la versione e informazioni aggiuntive, è più verbose rispetto
 al 
\begin_inset Quotes eld
\end_inset

-v
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
DA CONTINUARE
\end_layout

\begin_layout Section
Database Server
\end_layout

\begin_layout Standard
Esistono diverse applicazioni utilizzabili su GNU/Linux per funzionare da
 server per database, ma una scelta comune open-source è 
\begin_inset Quotes eld
\end_inset

MySQL
\begin_inset Quotes erd
\end_inset

, quindi nelle prossime sezioni tratteremo MySQL, ad ogni modo altri server
 per database famosi sono 
\begin_inset Quotes eld
\end_inset

Microsoft Database Server
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

Oracle Database Server
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

Postgres
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsection
MySQL
\end_layout

\begin_layout Subsubsection
Installazione su Red-Hat Based Distro
\end_layout

\begin_layout Standard
Per installare mySQL su distribuzioni basate su Red-Hat, effettuiamo
\end_layout

\begin_layout Itemize
yum search mysql //cerca pacchetti riguardanti mySQL nei repository
\end_layout

\begin_layout Standard
I pacchetti che ci interessano da questa ricerca sono:
\end_layout

\begin_layout Itemize
mysql-server //i pacchetti che faranno da server
\end_layout

\begin_layout Itemize
mysql //i pacchetti che permetteranno di interfacciarci al server
\end_layout

\begin_layout Standard
quindi effettueremo un:
\end_layout

\begin_layout Itemize
yum install mysql-server mysql //installa i pacchetti mysql-server e mysql
\end_layout

\begin_layout Standard
Una volta installato, possiamo verificarne la corretta installazione, effettuand
o un controllo sul demone mysqld
\end_layout

\begin_layout Itemize
service mysqld status //verifica lo stato del processo demone (servizio)
 mysqld, ci aspettiamo qualcosa che ci dica che il servizio non è attivo
 ma in stato di 
\begin_inset Quotes eld
\end_inset

Stop
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
a questo punto, iniziamo il demone attraverso il comando:
\end_layout

\begin_layout Itemize
service mysqld start //inizia il processo mysqld
\end_layout

\begin_layout Standard
per inserire la password dell'utente root lanciamo:
\end_layout

\begin_layout Itemize
mysqladmin -u root password exampleOfPassword //crea una password per l'utente
 di root, la password è composta dalla stringa 
\begin_inset Quotes eld
\end_inset

exampleOfPassword
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Ora l'ambiente mysql è pronto.
\end_layout

\begin_layout Subsubsection
Installazione su Debian Based Distro
\end_layout

\begin_layout Standard
Per installare mySQL su distribuzioni basate su Debian, effettuiamo
\end_layout

\begin_layout Itemize
apt-cache search mysql | mysql //cerca pacchetti riguardanti mySQL nei repositor
y
\end_layout

\begin_layout Standard
I pacchetti che ci interessano da questa ricerca sono:
\end_layout

\begin_layout Itemize
mysql-server //i pacchetti che faranno da server
\end_layout

\begin_layout Itemize
mysql-client //i pacchetti che permetteranno di interfacciarci al server
\end_layout

\begin_layout Standard
quindi effettueremo un:
\end_layout

\begin_layout Itemize
apt-get install mysql-server mysql-client //installa i pacchetti mysql-server
 e mysql-client
\end_layout

\begin_layout Standard
In questo caso, comparirà una procedura guidata per impostare la password
 di root, e non dovremo inserirla manualmente.
\end_layout

\begin_layout Standard
Ora possiamo verificare la corretta installazione di MySQL attraverso il
 comando:
\end_layout

\begin_layout Itemize
/etc/init.d/mysql status //verifica lo stato del processo demone associato
 a mysql
\end_layout

\begin_layout Standard
oppure in alternativa possiamo lanciare:
\end_layout

\begin_layout Itemize
service mysql status //verifica lo stato del processo demone associato a
 mysql
\end_layout

\begin_layout Standard
Ora l'ambiente mysql è pronto.
\end_layout

\begin_layout Subsubsection
Gestione di database con MySQL
\end_layout

\begin_layout Standard
Per entrare in mysql, eseguiamo:
\end_layout

\begin_layout Itemize
mysql -u root -p //esegue l'accesso con l'utente 
\begin_inset Quotes eld
\end_inset

-u
\begin_inset Quotes erd
\end_inset

 root, richiedendo la password 
\begin_inset Quotes eld
\end_inset

-p
\begin_inset Quotes erd
\end_inset

, il flag 
\begin_inset Quotes eld
\end_inset

-p
\begin_inset Quotes erd
\end_inset

 è richiesto ogni qualvolta un utente è munito di password, nel caso in
 cui non venisse messo, allora il login non viene effettuato
\end_layout

\begin_layout Standard
Una volta effettuato il login, vedremo a schemo il prompt di mysql, da questo
 prompt possiamo effettuare diverse operazioni come ad esempio creare database,
 creare tabelle o in genere effettuare query.
 Vediamo alcuni esempi di comandi:
\end_layout

\begin_layout Itemize
show databases; //mostra i database presenti, di default potremmo vedere
 due o tre database d'esempio
\end_layout

\begin_layout Itemize
create database dbName; //crea un database con nome 
\begin_inset Quotes eld
\end_inset

dbName
\begin_inset Quotes erd
\end_inset

, è da notare che il simbolo 
\begin_inset Quotes eld
\end_inset

;
\begin_inset Quotes erd
\end_inset

 è utilizzato per terminare le istruzioni, un semplice invio permette invece
 di continuare un comando, nota che se il nome dovesse contenere caratteri
 particolari come ad esempio 
\begin_inset Quotes eld
\end_inset

-
\begin_inset Quotes erd
\end_inset

 (dash) o doppi apici o parentesi, dobbiamo rinchiudere il nome del database
 tra apici retroversi 
\begin_inset Quotes eld
\end_inset

`
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Itemize
drop database dbName; //elimina il database con nome 
\begin_inset Quotes eld
\end_inset

dbName
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
SHOW GLOBAL VARIABLES LIKE 'PORT'; //mostra su quale porta sta girando mysql
\end_layout

\begin_layout Itemize
SHOW GLOBAL VARIABLES; //mostra tutte le variabili globali
\end_layout

\begin_layout Standard
N.B.: Nota che in SQL, per indicare nomi con caratteri speciali, dobbiamo
 racchiudere il nome tra apici retroversi ``.
\end_layout

\begin_layout Subsubsection
Gestione Utenti in MySQL
\end_layout

\begin_layout Itemize
CREATE USER 'newuser'@'localhost' IDENTIFIED BY 'password'; //crea un utente
 chiamata 
\begin_inset Quotes eld
\end_inset

newuser
\begin_inset Quotes erd
\end_inset

 con la password specificato
\end_layout

\begin_layout Itemize
GRANT ALL PRIVILEGES ON * .
 * TO 'newuser'@'localhost'; //fornire permessi all'utente altrimenti non
 può fare nulla
\end_layout

\begin_layout Itemize
FLUSH PRIVILEGES; //aggiorna i privilegi
\end_layout

\begin_layout Itemize
SET PASSWORD FOR 'root'@'localhost' = PASSWORD('MyNewPass'); //reimposta
 la password per l'account di root sul server locale 
\begin_inset Quotes eld
\end_inset

localhost
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Subsubsection
Creazione di tabelle e gestione delle tabelle
\end_layout

\begin_layout Standard
Una volta creato un database, per poterci lavorare dovremo prima indicare
 l'intenzione di utilizzare il database attraverso:
\end_layout

\begin_layout Itemize
use dbName; //seleziono il database con nome 
\begin_inset Quotes eld
\end_inset

dbName
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Vediamo alcuni comandi per gestire le tabelle:
\end_layout

\begin_layout Itemize
show tables; //mostra le tabelle presenti all'interno del database
\end_layout

\begin_layout Itemize
show columns from `nome Tabella`; //mostra le colonne della tabella col
 tipo di dato, è anche utile per capire qual'è la chiave primaria e che
 opzioni sono applicate sui campi
\end_layout

\begin_layout Itemize
CREATE TABLE nomeTab (id int(5) PRIMARY KEY, name varchar(255), email varchar(25
5), description text); //crea una tabella chiamata 
\begin_inset Quotes eld
\end_inset

nomeTab
\begin_inset Quotes erd
\end_inset

, con tre attributi, uno di tipo intero con massimo 5 cifre che sarà anche
 la chiave primaria, e gli altri due di tipo stringa con un numero massimo
 di caratteri ammessi di 255
\end_layout

\begin_layout Itemize
CREATE TABLE users ( user_id int NOT NULL auto_increment, username varchar(20)
 NOT NULL, password char(40) NOT NULL, mail varchar(255), PRIMARY KEY (user_id),
 UNIQUE KEY username (username) ); //crea una tabella con alcuni attributi
 NOT NULL, e il primo attributo 
\begin_inset Quotes eld
\end_inset

user_id
\begin_inset Quotes erd
\end_inset

 con l'auto increment attivato 
\end_layout

\begin_layout Itemize
DESCRIBE nomeTab; //mostra la struttura della tabella chiamata nomeTab,
 con i propri attributi, il tipo e le chiavi
\end_layout

\begin_layout Itemize
ALTER TABLE users CHANGE COLUMN id id INT(11) PRIMARY KEY AUTO_INCREMENT;
 //cambia una colonna chiamata 
\begin_inset Quotes eld
\end_inset

id
\begin_inset Quotes erd
\end_inset

 nella tabella 
\begin_inset Quotes eld
\end_inset

users
\begin_inset Quotes erd
\end_inset

 e la rinomina ancora 
\begin_inset Quotes eld
\end_inset

id
\begin_inset Quotes erd
\end_inset

, la imposta come chiave primaria
\end_layout

\begin_layout Itemize
ALTER TABLE websites CHANGE COLUMN hash hash varchar(64) NULL; //sulla tabella
 websites importa l'attributo hash in modo che possa essere null
\end_layout

\begin_layout Itemize
ALTER TABLE websites CHANGE COLUMN hash hash varchar(64) NOT NULL; //sulla
 tabella websites importa l'attributo hash in modo che non possa essere
 null
\end_layout

\begin_layout Itemize
ALTER TABLE users CHANGE COLUMN id user_id INT(11) PRIMARY KEY AUTO_INCREMENT;
 //cambia una colonna chiamata 
\begin_inset Quotes eld
\end_inset

id
\begin_inset Quotes erd
\end_inset

 nella tabella 
\begin_inset Quotes eld
\end_inset

users
\begin_inset Quotes erd
\end_inset

 e la rinomina col nome attributo 
\begin_inset Quotes eld
\end_inset

user_id
\begin_inset Quotes erd
\end_inset

, la imposta come chiave primaria
\end_layout

\begin_layout Itemize
INSERT INTO nomeTab (id, name, values) VALUES (1, 'anthony', 'anthony@me.com');
 //inserisce nella tabella chiamata nomeTab una tupla nell'ordine specificato
 (id, name, values) coi valori (1, 
\begin_inset Quotes eld
\end_inset

anthony
\begin_inset Quotes erd
\end_inset

m 
\begin_inset Quotes eld
\end_inset

anthony@me.com
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Itemize
INSERT INTO users (name, mail) VALUES ('giuseppe', 'giuseppe@casa.it'); //nel
 caso avessimo un campo 
\begin_inset Quotes eld
\end_inset

id
\begin_inset Quotes erd
\end_inset

 con autoincremento, basta solo non citarlo all'interno della insert into,
 e per magia l'autoincremento verrà gestito da mysql
\end_layout

\begin_layout Itemize
select * from nomeTab; //mostra tutte le tuple della tabella chiamata 
\begin_inset Quotes eld
\end_inset

nomeTab
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
select name from nomeTab; //mostra solo il campo 
\begin_inset Quotes eld
\end_inset

name
\begin_inset Quotes erd
\end_inset

 di tutte le tuple della tabella chiamata 
\begin_inset Quotes eld
\end_inset

nomeTab
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
select * from nomeTab where name=
\begin_inset Quotes erd
\end_inset

anthony
\begin_inset Quotes erd
\end_inset

; //mostra tutte le tuple della tabella con nome 
\begin_inset Quotes eld
\end_inset

nomeTab
\begin_inset Quotes erd
\end_inset

 che hanno come attributo 
\begin_inset Quotes eld
\end_inset

name
\begin_inset Quotes erd
\end_inset

 esattamente il valore 
\begin_inset Quotes erd
\end_inset

anthony
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
UPDATE nomeTab SET id=3; //cambia il campo 
\begin_inset Quotes eld
\end_inset

id
\begin_inset Quotes erd
\end_inset

 di tutte le tuple della tabella 
\begin_inset Quotes eld
\end_inset

nomeTab
\begin_inset Quotes erd
\end_inset

 al valore 
\begin_inset Quotes eld
\end_inset

3
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
UPDATE nomeTab SET id=1 where name=
\begin_inset Quotes erd
\end_inset

anthony
\begin_inset Quotes erd
\end_inset

; //cambia il campo 
\begin_inset Quotes eld
\end_inset

id
\begin_inset Quotes erd
\end_inset

 solo delle tuple il cui nome è esattamente 
\begin_inset Quotes eld
\end_inset

anthony
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
DELETE from nomeTab where id=3; //elimina la tupla con valore id=3 dalla
 tabella 
\begin_inset Quotes eld
\end_inset

nomeTab
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
desc nomeTabella; //mostra uno schema che ci dice come è fatta una tabella,
 MOOLTO UTILE!
\end_layout

\begin_layout Itemize
select * from nomeTab where id=1 or id=2; //mostra tutte le tuple con id=1
 o id=2
\end_layout

\begin_layout Itemize
select * from nomeTab order by id asc; //mostra tutte le tuple ordinate
 in ordine crescente in funzione del campo 
\begin_inset Quotes eld
\end_inset

id
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
select * from nomeTab order by id desc; //mostra tutte le tuple ordinate
 in ordine decrescente in funzione del campo 
\begin_inset Quotes eld
\end_inset

id
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
select nomeTab.email, nomeTab.name as customers_name, nomeTab2.name from nomeTab,
 nomeTab2 where nomeTab.id=nomeTab2.id; //mostra una tabella sia con campi
 della tabella chiamata 
\begin_inset Quotes eld
\end_inset

nomeTab
\begin_inset Quotes erd
\end_inset

 che della tabella chiamata 
\begin_inset Quotes eld
\end_inset

nomeTab2
\begin_inset Quotes erd
\end_inset

, la keyword 
\begin_inset Quotes eld
\end_inset

as
\begin_inset Quotes erd
\end_inset

 ci permette di visualizzare un determinato campo con un altro nome a schermo
 nel momento in cui la tabella viene visualizzata, in questo caso abbiamo
 effettuato un 
\begin_inset Quotes eld
\end_inset

join
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
ALTER TABLE Persons AUTO_INCREMENT=100; //in questo caso facciamo in modo
 che la tabella persons cominci l'auto incremento dal valore 100
\end_layout

\begin_layout Standard
Vediamo ora come inserire una chiave esterna, se abbiamo ad esempio una
 tabella negozio, e poi una tabella prodotti, ed in prodotti, vogliamo avere
 un riferimento al negozio, allora innanzitutto creiamo una nuova voce nella
 tabella prodotti chiamata 
\begin_inset Quotes eld
\end_inset

id_negozio
\begin_inset Quotes erd
\end_inset

, con:
\end_layout

\begin_layout Itemize
ALTER TABLE prodotti ADD COLUMN id_negozio int not null;
\end_layout

\begin_layout Standard
e ora possiamo includere la chiave esterna con:
\end_layout

\begin_layout Itemize
ALTER TABLE prodotti ADD FOREIGN KEY fk_id_negozio(id_negozio) REFERENCES
 negozi(id_negozio) ON DELETE CASCADE ON UPDATE CASCADE;
\end_layout

\begin_layout Standard
oppure se esiste già la colonna su cui andare a referenziarci possiamo usare:
\end_layout

\begin_layout Itemize
CREATE TABLE Orders ( O_Id int NOT NULL, OrderNo int NOT NULL, P_Id int,
 PRIMARY KEY (O_Id), FOREIGN KEY (P_Id) REFERENCES Persons(P_Id) );
\end_layout

\begin_layout Subsection
Backup Database
\end_layout

\begin_layout Itemize
mysqldump -u nomeUtente -p –databases nomeDb1 nomeDb2 > dump.sql //crea un
 file con il backup del database
\end_layout

\begin_layout Itemize
mysql -u nomeUtente -p -h localhost nomeNuovoDB < dump.sql //questo serve
 ad importare i DB all'interno di uno scritto
\end_layout

\begin_layout Itemize
mysql -u nomeUtente -p -h localhost nomeNuovoDB < dump.sql //if you do not
 know the database name or database name is included in sql dump you can
 try out something as follows
\end_layout

\begin_layout Itemize
mysql -u nomeUtente -p -h 27.12.4.121 nomeNuovoDB < dump.sql //importa su un
 database remoto uno script dump
\end_layout

\begin_layout Standard
oppure exportato un file da ad esempio phpmyadmin, possiamo importarlo con:
\end_layout

\begin_layout Itemize
mysql -u username -p database_name < file.sql //il database deve essere già
 esistente
\end_layout

\begin_layout Subsection
PostgreSQL
\end_layout

\begin_layout Standard
PostgreSQL è un progetto open-source, guidato dalla community, che segue
 il modello ad oggetti e relazionale.
\end_layout

\begin_layout Itemize
sudo apt-get install postgresql postgresql-client //installa sia il server
 che il client di postgresql
\end_layout

\begin_layout Standard
una volta installato dobbiamo eseguire il login come utente root, per poter
 collegarci alla sua shell, quindi:
\end_layout

\begin_layout Itemize
su //switcha all'utente di root
\end_layout

\begin_layout Itemize
su - postgres //switcha all'utente postgres, volendo potrei anche impostare
 una password per questo utente
\end_layout

\begin_layout Standard
ora dalla shell adesso possiamo creare un nuovo utente con il comando:
\end_layout

\begin_layout Itemize
createuser –interactive //il programma createuser fa parte del pacchetto
 postgresql-client Trucchetto: If you create a PostgreSQL user with the
 same name as your Linux username, it allows you to access the PostgreSQL
 database shell without having to specify a user to login (which makes it
 quite convenient).
\end_layout

\begin_layout Itemize
createdb dbNameIWant //creo il database con il nome che preferisco
\end_layout

\begin_layout Standard
adesso possiamo avviare il client psql con l'utente corrente
\end_layout

\begin_layout Itemize
psql -d NomeDBACuiConnettermi //questo avvia la shell di PostgreSQL, se
 non specifichiamo un database, psql proverà a collegarsi ad un database
 che ha lo stesso nome utente dell'utente che ha lanciato il comando
\end_layout

\begin_layout Standard
ora la shell 
\begin_inset Quotes eld
\end_inset

psql
\begin_inset Quotes erd
\end_inset

 oltre a supportare i classici comandi SQL come ad esempio 
\begin_inset Quotes eld
\end_inset

DROP DATABASE nomeDb;
\begin_inset Quotes erd
\end_inset

 (e altri, ricordare sempre il punto e virgola 
\begin_inset Quotes eld
\end_inset

;
\begin_inset Quotes erd
\end_inset

 per i comandi SQL) supporta anche dei comandi 
\begin_inset Quotes eld
\end_inset

shortcut
\begin_inset Quotes erd
\end_inset

 questi comandi chiamati nel gergo 
\begin_inset Quotes eld
\end_inset

metacomandi
\begin_inset Quotes erd
\end_inset

 hanno la caratteristica di iniziare col carattere 
\begin_inset Quotes eld
\end_inset


\backslash

\begin_inset Quotes erd
\end_inset

, vediamo qualche esempio:
\end_layout

\begin_layout Itemize

\backslash
help //mostra l'elenco di tutti i comandi disponibili
\end_layout

\begin_layout Itemize

\backslash
c <database> //si collega al database menzionato
\end_layout

\begin_layout Itemize

\backslash
du //elenca tutti gli utenti con relativo livello di permessi
\end_layout

\begin_layout Itemize

\backslash
dt //show summary information about all tables in the current database
\end_layout

\begin_layout Itemize

\backslash
q //esce dalla console psql, per questo può anche essere utilizzato il la
 combinazione di tasti CTRL+d
\end_layout

\begin_layout Itemize

\backslash
l //elenca i database esistenti
\end_layout

\begin_layout Itemize

\backslash
? //mostra la lista di meta comandi
\end_layout

\begin_layout Standard
N.B.: il prompt del comando 
\begin_inset Quotes eld
\end_inset

psql
\begin_inset Quotes erd
\end_inset

 mostra sempre il nome del database a cui siamo attualmente connessi.
\end_layout

\begin_layout Standard
N.B.: Non dobbiamo cambiare la password dell'account postgres col comando
 
\begin_inset Quotes eld
\end_inset

passwd
\begin_inset Quotes erd
\end_inset

 in quanto in questo caso l'acount diventa loggabile e noi non vogliamo
 fare in modo di poter effettuare il login.
 Quindi eseguo:
\end_layout

\begin_layout Itemize
sudo -u postgres psql postgres //con sudo -u eseguo un comando (in questo
 caso 
\begin_inset Quotes eld
\end_inset

psql postgres
\begin_inset Quotes erd
\end_inset

) col nomeutente specificato come parametro
\end_layout

\begin_layout Standard
poi una volta all'interno di psql eseguiamo:
\end_layout

\begin_layout Itemize

\backslash
password postgres //questo ci permetterà di impostare la nuova password
\end_layout

\begin_layout Standard
un errore comune è quello di avere 
\begin_inset Quotes eld
\end_inset

Failed to connect to the database: FATAL: role "giuseppe" does not exist
\begin_inset Quotes erd
\end_inset

, in questo caso dobbiamo creare il ruolo mancante, possiamo farlo ad esempio,
 andando ad eseguire:
\end_layout

\begin_layout Itemize
sudo -u postgres psql //eseguo la shell di postgresql utilizzando l'utente
 adibito 
\begin_inset Quotes eld
\end_inset

postgres
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
CREATE ROLE giuseppe superuser;
\end_layout

\begin_layout Itemize
CREATE USER giuseppe;
\end_layout

\begin_layout Itemize
ALTER ROLE giuseppe WITH LOGIN; //and then enable login that user, so you
 can run e.g.: psql template1, from normal $ terminal
\end_layout

\begin_layout Standard
possiamo loggare in psql con:
\end_layout

\begin_layout Itemize
psql -d databaseName -U user -W //con il flag 
\begin_inset Quotes eld
\end_inset

-d
\begin_inset Quotes erd
\end_inset

 indichiamo il nome del database, col flag 
\begin_inset Quotes eld
\end_inset

-U
\begin_inset Quotes erd
\end_inset

 indico il nome utente, col flag 
\begin_inset Quotes eld
\end_inset

-W
\begin_inset Quotes erd
\end_inset

 indico di effettuare un prompt per la password
\end_layout

\begin_layout Itemize
psql -d databaseName -U usernameIWant -W -h localhost //questa è l'alternativa
 nel caso in cui ci da l'errore Fatal Error: Peer Authentication Failed,
 possiamo evitare di specificare ogni volta il localhost andando a impostare
 una variabile d'ambiente chiamata PGHOST e impostandola a 
\begin_inset Quotes eld
\end_inset

localhost
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
possiamo creare un database con 
\begin_inset Quotes eld
\end_inset

proprietario
\begin_inset Quotes erd
\end_inset

 (owner) un account specifico, attraverso:
\end_layout

\begin_layout Itemize
CREATE DATABASE dbNameIWant OWNER existingUserIPrefer;
\end_layout

\begin_layout Standard
Per rimuovere un utente invece dall'account abilitato per psql eseguiamo:
\end_layout

\begin_layout Itemize
dropuser nomeUtenteDaRimuovere
\end_layout

\begin_layout Section
Kernel
\end_layout

\begin_layout Standard
Quando si parla della gestione del kernel, dobbiamo tenere a mente il comando
 
\begin_inset Quotes eld
\end_inset

uname
\begin_inset Quotes erd
\end_inset

, vediamo alcuni flag del comando uname che possono esserci utili:
\end_layout

\begin_layout Itemize
-a //visualizza tutte le informazioni
\end_layout

\begin_layout Itemize
-s //nome del kernel
\end_layout

\begin_layout Itemize
-n //nome computer, visualizzabile anche col comando 
\begin_inset Quotes eld
\end_inset

hostname
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
-r //kernel release
\end_layout

\begin_layout Itemize
-v //versione kernel
\end_layout

\begin_layout Itemize
-m //architettura della macchina, visualizzabile anche col comando 
\begin_inset Quotes eld
\end_inset

arch
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
-p //tipo di processore
\end_layout

\begin_layout Itemize
-i //piattaforma hardware
\end_layout

\begin_layout Itemize
-o //sistema operativo
\end_layout

\begin_layout Standard
Il comando uname mostra informazioni dal file 
\begin_inset Quotes eld
\end_inset

/proc/version
\begin_inset Quotes erd
\end_inset

, un'altro file importante è 
\begin_inset Quotes eld
\end_inset

/proc/cmdline
\begin_inset Quotes erd
\end_inset

, in questo file sono contenute alcune informazioni relative all'avvio del
 kernel in fase di boot.
 Innanzitutto possiamo visualizzare le informazioni sul kernel che stiamo
 runnando attraverso:
\end_layout

\begin_layout Itemize
cat /boot/config-$(uname -r) //apre il file di configurazione del kernel
 che stiamo runnando, utile, soprattutto nel momento in cui dovessimo avere
 più kernel
\end_layout

\begin_layout Subsection
Cominciare a capire il Kernel
\end_layout

\begin_layout Standard
Per capire il kernel, uno strumento utile è la documentazione, possiamo
 installare la documentazione su distro RH-based con:
\end_layout

\begin_layout Itemize
yum install kernel-doc //installa la documentazione del kernel
\end_layout

\begin_layout Standard
mentre su distro Debian-based la documentazione è contenuta all'interno
 dei sorgenti, o comunque possiamo scaricarla dal sito ufficiale 
\begin_inset CommandInset href
LatexCommand href
name "Kernel Linux"
target "www.kernel.org/doc"

\end_inset

.
\end_layout

\begin_layout Standard
Una volta installata la documentazione possiamo trovarla attraverso:
\end_layout

\begin_layout Itemize
ls /usr/share/doc/kernel-doc-2.6.32/Documentation //entra nella directory
 contenente la documentazione, su distro RH-based
\end_layout

\begin_layout Itemize
ls /usr/src/linux/Documentation //entra nella directory contenente la documentaz
ione, su distro Debian-based
\end_layout

\begin_layout Standard
ad esempio possiamo trovare la documentazione relativa alla directory /proc,
 a partire dalla directory 
\begin_inset Quotes eld
\end_inset

Documentation/
\begin_inset Quotes erd
\end_inset

 attraverso la directory 
\begin_inset Quotes eld
\end_inset

/filesystems/proc.txt
\begin_inset Quotes erd
\end_inset

; potrebbe essere una buona idea creare un'alias alla directory della documentaz
ione se pensiamo di visualizzarla spesso
\end_layout

\begin_layout Subsection
Tipi di Kernel e file relativi
\end_layout

\begin_layout Standard
I file relativi al kernel possiamo trovarli all'interno della directory
 
\begin_inset Quotes eld
\end_inset

/boot
\begin_inset Quotes erd
\end_inset

, ora all'interno di questa directory abbiamo tutti i kernel installati,
 presupponiamo di avere un solo kernel installato sulla macchina, allora
 possiamo vedere due tipo di directory:
\end_layout

\begin_layout Itemize
/boot/vmlinux //era la directory dove una volta venivano messi i file del
 kernel, questa cartella non è compressa
\end_layout

\begin_layout Itemize
/boot/vmlinuz //è la directory dove attualmente sono messi i file del kernel,
 questa cartella è compressa con algoritmo gzip
\end_layout

\begin_layout Standard
il nome delle directory sopracitate non è completo in quanto queste directory
 hanno un nome composto anche dalla versione del kernel ad esempio 
\begin_inset Quotes eld
\end_inset

/boot/vmlinuz-3.16.0-4-amd64
\begin_inset Quotes erd
\end_inset

 possiamo vedere che tipo di kernel abbiamo e con cosa è stato compresso
 attraverso il comando 
\begin_inset Quotes eld
\end_inset

file
\begin_inset Quotes erd
\end_inset

, quindi eseguiamo:
\end_layout

\begin_layout Itemize
file /boot/vmlinuz-3.16.0-4-amd64 //visualizza informazioni sul file compresso,
 evidenziando il tipo di compressione
\end_layout

\begin_layout Standard
Normalmente quando si compila un kernel abbiamo varie opzioni per il file
 in uscita, innanzitutto viene comunque generato il file non compresso 
\begin_inset Quotes eld
\end_inset

vmlinux
\begin_inset Quotes erd
\end_inset

, poi di default viene generato anche il file 
\begin_inset Quotes eld
\end_inset

vmlinuz
\begin_inset Quotes erd
\end_inset

 che è quello compresso con algorirmo bzip2, ma nel caso volessimo effettuare
 un altro tipo di compressione abbiamo a disposizione:
\end_layout

\begin_layout Itemize
zImage //file compresso con algoritmo gzip, ma che non può essere più grande
 di 512KB
\end_layout

\begin_layout Itemize
bzImage //file compresso ancora con algoritmo gzip, il 
\begin_inset Quotes eld
\end_inset

bz
\begin_inset Quotes erd
\end_inset

 può confondere in quanto porta il lettore a pensare all'algoritmo 
\begin_inset Quotes eld
\end_inset

bzip2
\begin_inset Quotes erd
\end_inset

 ma questo non centra nulla, l'unica differenza con l'algoritmo zImage è
 che in questo caso i 512KB (limite del zImage) possono essere superati
\end_layout

\begin_layout Itemize
uImage //an image file that has a U-Boot wrapper (installed by the mkimage
 utility) that includes the OS type and loader information, is a small kernel
 image with modified header for Uboot enabling U-boot to load this kernel
 image, comunque le ultime versioni di U-Boot possono eseguire boot anche
 di kernel di tipo zImage, un uImage comunque non è altro che un'immagine
 zImage + 64 Byte di header per U-Boot
\end_layout

\begin_layout Subsubsection
File associati ad un kernel
\end_layout

\begin_layout Standard
Ad un kernel solitamente vengono associati alcuni file:
\end_layout

\begin_layout Itemize
un file chiamato 
\begin_inset Quotes eld
\end_inset

System.map
\begin_inset Quotes erd
\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
In Linux, the System.map file is a symbol table used by the kernel.
 A symbol table is a look-up between symbol names and their addresses in
 memory.
 A symbol name may be the name of a variable or the name of a function.
 The System.map is required when the address of a symbol name, or the symbol
 name of an address, is needed.
 It is especially useful for debugging kernel panics and kernel oopses.
 The kernel does the address-to-name translation itself when CONFIG_KALLSYMS
 is enabled so that tools like ksymoops are not required.
 If we run a kernel with no (or an incorrect) System.map, you'll periodically
 see annoying warnings like: 
\begin_inset Quotes eld
\end_inset

System.map does not match actual kernel
\begin_inset Quotes erd
\end_inset

, possiamo verificare questo usando programmi come 
\begin_inset Quotes eld
\end_inset

ps
\begin_inset Quotes erd
\end_inset

, se durante 
\begin_inset Quotes eld
\end_inset

ps
\begin_inset Quotes erd
\end_inset

 vediamo questi messaggi allora il file System.map non matcha il kernel
\end_layout

\end_deeper
\begin_layout Itemize
un file chiamato 
\begin_inset Quotes eld
\end_inset

initrd.img
\begin_inset Quotes erd
\end_inset

 (questo compare solo quando in alcune configurazioni, in cui viene utilizzato
 un initial RAM disk)
\end_layout

\begin_layout Standard
E' buona convenzione mantenere i nomi del kernel e dei file relativi con
 la stessa dicitura, nel caso di manutenzione manuale dei kernel, in quanto
 una dicitura scorretta porterebbe ad uno scorretto funzionamento del kernel.
\end_layout

\begin_layout Standard
Ad esempio, se abbiamo due kernel su una macchina, un kernel linux versione
 4.1 chiamato 
\begin_inset Quotes eld
\end_inset

vmlinuz-4.1-mioKernel
\begin_inset Quotes erd
\end_inset

 e un altro kernel linux versione 4.2 chiamato 
\begin_inset Quotes eld
\end_inset

vmlinuz-4.2-tuoKernel
\begin_inset Quotes erd
\end_inset

, allora i file relativi al primo kernel dovranno essere:
\end_layout

\begin_layout Itemize
System.map-4.1-mioKernel
\end_layout

\begin_layout Itemize
initrd.img-4.1-mioKernel
\end_layout

\begin_layout Standard
mentre i file relativi al secondo kernel saranno:
\end_layout

\begin_layout Itemize
System.map-4.2-tuoKernel
\end_layout

\begin_layout Itemize
initrd.img-4.2-tuoKernel
\end_layout

\begin_layout Subsection
Initial RAM disk
\end_layout

\begin_layout Standard
L'initial RAM disk è il sistema che si occupa di caricare un filesystem
 temporaneo durante il processo di boot del kernel atto a caricare il vero
 filesystem e fare in modo che i driver possano interfacciarsi col vero
 filesystem.
 Il kernel linux non può accedere immediatamente dopo il boot al filesystem,
 gli mancano i driver necessari per farlo, che devono essere caricati come
 moduli, ma per caricarli come moduli abbiamo bisogno di accedere al filesystem,
 abbiamo un cane che si mangia la coda, quindi è stato pensato di utilizzare
 questo filesystem temporaneo che si occupa di risolvere questo problema.
 Un'altra soluzione sarebbe stata quella di includere i moduli all'interno
 del kernel linux, ma includere molti moduli ingrandisce significativamente
 l'immagine del kernel.
 Esistono due tipi di Initial RAM disks:
\end_layout

\begin_layout Itemize
initrd //utilizzato nelle meno recenti versioni del kernel, precedenti alla
 2.6.13, costituiva un'immagine compressa montata attraverso /dev/ram, il
 modulo usato in initrd deve essere compilato all'interno del kernel, spesso
 quindi un block device driver 
\begin_inset Quotes eld
\end_inset

ext2
\begin_inset Quotes erd
\end_inset

 o 
\begin_inset Quotes eld
\end_inset

cramfs
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
initramfs //è il nuovo tipo di initial RAM disks, è un archivio cpio, viene
 scompattato dal kernel in tmpfs che è un filesystem minimale che diventa
 il filesystem radice temporaneo, il vantaggio di questo schema è quello
 non aver bisogno di driver del filesystem o dei dispositivi di base che
 devono essere compilati nel kernel, quindi presenta anche una sequenza
 di boot più veloce, per questioni storiche possiamo ancora vedere delle
 immagini initramfs che però vengono chiamate initrd, ricordare che queste
 sono in realtà initramfs, in quanto solo chi usa versioni del kernel precedenti
 alla 2.6 deve gestire initrd
\end_layout

\begin_layout Standard
Nota che in entrambi i sistemi, l'immagine è ancora chiamata 
\begin_inset Quotes eld
\end_inset

initrd
\begin_inset Quotes erd
\end_inset

.
 In pratica questo initial ram disk, è comunemente utilizzato in configurazioni
 in cui c'è bisogno di effettuare delle operazioni preliminari prima di
 montare il vero e proprio filesystem root, quindi viene utilizzato in molti
 scenari in cui non si hanno boot normali (o comuni, insomma parlo dei PC
 da casa) del sistema, ma boot più complicati, ad esempio voglio eseguire
 il boot di un disco utilizzante partizionamento logico LVM, o utilizzante
 una configurazione RAID, o un disco criptato, o altri svariati scenari
 di cui non sono a conoscenza personalmente.
\end_layout

\begin_layout Subsubsection
Visualizzare il kernel e l'Initial RAM Disk
\end_layout

\begin_layout Standard
All'interno della directory /boot esiste anche l'immagine dell'initial RAM
 disk, infatti questa si chiamerà 
\begin_inset Quotes eld
\end_inset

initramfs-versioneKernel
\begin_inset Quotes erd
\end_inset

, eseguire un 
\begin_inset Quotes eld
\end_inset

file
\begin_inset Quotes erd
\end_inset

 su questo file, ci mostrerà che è compresso attraverso gzip, possiamo quindi
 pensare di decomprimerlo, una volta decompresso, possiamo scompattarlo
 attraverso 
\begin_inset Quotes eld
\end_inset

cpio -id nomeArchivio
\begin_inset Quotes erd
\end_inset

, vedremo un vero e proprio filesystem, a grandi linee questo è un mini
 sistema operativo atto ad avviare il vero e proprio sistema operativo.
\end_layout

\begin_layout Subsection
Parametri del Kernel
\end_layout

\begin_layout Standard
Quando un kernel viene lanciato, il boot loader gli passa dei parametri
 che gli indicano come dovrebbe partire; questi parametri possono specificare
 un largo insieme di opzioni e behaviour del kernel, come ad esempio, la
 quantità di messaggi di diagnostica che quest'ultimo deve produrre, oppure
 opzioni specifiche ad un determinato driver.
 Possiamo visualizzare le opzioni con cui è stato lanciato un kernel in
 running attraverso:
\end_layout

\begin_layout Itemize
cat /proc/cmdline
\end_layout

\begin_layout Standard
vediamo alcuni importanti parametri:
\end_layout

\begin_layout Itemize
root=UUID=70ccd6e7-6ae6-44f6-812c-51aab8036d29 //indica al kernel dove è
 collocata la partizione di root, possiamo anche specificare il device con
 root=/dev/sda2, ma dobbiamo ricordare gli svantaggi di specificare un device
 file anzichè un UUID
\end_layout

\begin_layout Itemize
ro //questo parametro indica al kernel di essere lanciato in modalità read-only
 fino a quando non parte lo user-space, questo è utile, in quanto solitamente
 all'avvio avviene un file system check (fsck), e se il filesystem è montato
 in scrittura, non possiamo eseguirlo in modo sicuro; dopo il check, il
 filesystem viene rimontato in modalità read-write
\end_layout

\begin_layout Standard
Nel caso in cui il kernel incontra un parametro che non capisce, allora
 lo salva e lo passa al gestore di demoni (ad esempio init, openrc, upstart,
 systemd, ecc...), ad esempio il parametro 
\begin_inset Quotes eld
\end_inset

-s
\begin_inset Quotes erd
\end_inset

, non è capito dal kernel, ma da init, è compreso, e viene lanciato il sistema
 in single-user mode.
\end_layout

\begin_layout Subsection
Compilare un kernel
\end_layout

\begin_layout Standard
Possiamo scaricare il kernel da sito web 
\begin_inset CommandInset href
LatexCommand href
name "Sito Ufficiale del Kernel Linux"
target "www.kernel.org"

\end_inset

, una volta scaricato, possiamo decomprimerlo attraverso:
\end_layout

\begin_layout Itemize
sudo tar -Jxvf linux-3.18.5.tar.xz -C /usr/src/kernels/ //decomprime ed estrae
 l'archivio 
\begin_inset Quotes eld
\end_inset

xz
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
ora creiamo un link nella directory padre, eseguiamo:
\end_layout

\begin_layout Itemize
sudo ln -s /usr/src/kernels/linux-3.18.5 /usr/src/linux //crea un link della
 directory del pacchetto appena estratto nella directory padre chiamata
 
\begin_inset Quotes eld
\end_inset

linux
\begin_inset Quotes erd
\end_inset

, in quanto in fase di compilazione il sorgente deve essere in 
\begin_inset Quotes eld
\end_inset

/usr/src/linux
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Per compilare il kernel, abbiamo bisogno di alcuni prerequisiti, nelle distro
 Red-Hat based possiamo eseguire:
\end_layout

\begin_layout Itemize
sudo yum groupinstall 
\begin_inset Quotes eld
\end_inset

Development Tools
\begin_inset Quotes erd
\end_inset

 //installa tutti i tool richiesti per la compilazione, per vedere quali
 pacchetti vengono installati possiamo eseguire 
\begin_inset Quotes eld
\end_inset

yum groupinfo 
\begin_inset Quotes eld
\end_inset

Development Tools
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
sudo yum install ncurses-devl //modulo richiesto per fornire un menu per
 la selezione dei moduli basato su ncurses
\end_layout

\begin_layout Standard
Ora per compilare il kernel, assicuriamoci di essere nella directory giusta
 che è 
\begin_inset Quotes eld
\end_inset

/usr/src/linux
\begin_inset Quotes erd
\end_inset

, quindi eseguiamo:
\end_layout

\begin_layout Itemize
cd /usr/src/linux
\end_layout

\begin_layout Standard
Poi eseguiamo:
\end_layout

\begin_layout Itemize
make clean
\end_layout

\begin_layout Itemize
make menuconfig //apre il menu grafico per selezionare i moduli preferiti,
 una volta eseguita la configurazione desiderata, possiamo selezionare 
\begin_inset Quotes eld
\end_inset

save
\begin_inset Quotes erd
\end_inset

 e poi 
\begin_inset Quotes eld
\end_inset

exit
\begin_inset Quotes erd
\end_inset

 fino a quando non esce dal programma, possiamo premere 
\begin_inset Quotes eld
\end_inset

 ?
\begin_inset Quotes erd
\end_inset

 per avere aiuto e descrizione su una specifica voce del menu, oppure 
\begin_inset Quotes eld
\end_inset

/
\begin_inset Quotes erd
\end_inset

 per cercare voci nel menu, una volta trovate, possiamo posizionarci alle
 voci con i numeri, ad esempio 
\begin_inset Quotes eld
\end_inset

1
\begin_inset Quotes erd
\end_inset

 ci riporta alla posizione della prima voce trovata eccetera.
\end_layout

\begin_layout Standard
Se eseguiamo ora un 
\begin_inset Quotes eld
\end_inset

ls -a
\begin_inset Quotes erd
\end_inset

 dovremmo visualizzare un file chiamato 
\begin_inset Quotes eld
\end_inset

.config
\begin_inset Quotes erd
\end_inset

 che rappresenta la configurazione che abbiamo salvato, ora possiamo eseguire:
\end_layout

\begin_layout Itemize
make bzImage //crea un'immagine compressa di tipo bzImage, qui possiamo
 sostituire volendo 
\begin_inset Quotes eld
\end_inset

bzImage
\begin_inset Quotes erd
\end_inset

 con 
\begin_inset Quotes eld
\end_inset

zImage
\begin_inset Quotes erd
\end_inset

 o altro tipo di compressione che vogliamo
\end_layout

\begin_layout Itemize
make modules //compila i moduli
\end_layout

\begin_layout Standard
queste due voci, in realtà possono essere sostituite dal comando: 
\end_layout

\begin_layout Itemize
make all -j 5 //se ad esempio il nostro processore ha 4 core, si usa la
 regola pratica, numeroProcessori+1
\end_layout

\begin_layout Standard
una volta compilato, il kernel può essere trovato nella directory 
\begin_inset Quotes eld
\end_inset

arch/<mia_architettura>/boot
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
make modules_install //installa i moduli nelle directory giuste
\end_layout

\begin_layout Itemize
make install //viene installato il nuovo kernel, viene creata (almeno dovrebbe
 farlo) una nuova voce per il bootloader e usa 
\begin_inset Quotes eld
\end_inset

dracut
\begin_inset Quotes erd
\end_inset

 o 
\begin_inset Quotes eld
\end_inset

mkinitrd
\begin_inset Quotes erd
\end_inset

 per generare l'initial RAM disk, quest'operazione può anche essere fatta
 manualmente andando a copiare il file 
\begin_inset Quotes eld
\end_inset

arch/x86_64/vmlinuz
\begin_inset Quotes erd
\end_inset

 e il file 
\begin_inset Quotes eld
\end_inset

System.map
\begin_inset Quotes erd
\end_inset

 in /boot, dove è buona norma copiare vmlinuz con nome 
\begin_inset Quotes eld
\end_inset

vmlinuz-releaseNumber
\begin_inset Quotes erd
\end_inset

 e il file 
\begin_inset Quotes eld
\end_inset

System.map
\begin_inset Quotes erd
\end_inset

 come 
\begin_inset Quotes eld
\end_inset

System.map-releaseNumber
\begin_inset Quotes erd
\end_inset

 dove 
\begin_inset Quotes eld
\end_inset

releaseNumber
\begin_inset Quotes erd
\end_inset

 è la versione del kernel
\end_layout

\begin_layout Standard
per essere sicuri che la voce sia creata possiamo verificare il nuovo kernel
 nella directory /boot, e poi eseguire:
\end_layout

\begin_layout Itemize
grub-mkconfig -o /boot/grub/grub.cfg //questo comando su alcune distro è
 
\begin_inset Quotes eld
\end_inset

grub2-mkconfig -o /boot/grub/grub.cfg, questo ci permette di aggiornare il
 menu di boot
\end_layout

\begin_layout Standard
Una volta eseguita l'installazione possiamo avviare il nuovo kernel al reboot,
 e verificare che l'installazione sia andata a buon fine attraverso il comando:
\end_layout

\begin_layout Itemize
uname -r //visualizza la versione del kernel corrente
\end_layout

\begin_layout Standard
N.B.: Per compilare un kernel 4.3 ad esempio, dobbiamo avere i kernel headers
 della stessa versione o di una versione precedente, in quanto sono retro-compat
ibili, ma non vanno bene headers di una versione più recente.
\end_layout

\begin_layout Subsection
Configurazione del Kernel
\end_layout

\begin_layout Standard
Esistono alcune regole da praticone, diciamo per configurare il kernel,
 a differenza della nostra esigenza, ad esempio alcune scelte comuni sono:
\end_layout

\begin_layout Itemize
caricare una configurazione di default:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
questo è possibile attraverso 
\begin_inset Quotes eld
\end_inset

make defconfig
\begin_inset Quotes erd
\end_inset

, ci permette di selezionare la configurazione di default che hanno elaborato
 gli sviluppatori del kernel, potrebbe non andare bene in molti casi, possiamo
 comunque partire da questa per andare poi ad eseguire 
\begin_inset Quotes eld
\end_inset

make menuconfig
\begin_inset Quotes erd
\end_inset

 e selezionare i moduli necessari, ad ogni modo se eseguiamo 
\begin_inset Quotes eld
\end_inset

make menuconfig
\begin_inset Quotes erd
\end_inset

 senza un 
\begin_inset Quotes eld
\end_inset

make defconfig
\begin_inset Quotes erd
\end_inset

 è uguale, in quanto se non c'è un file di configurazione .config, questo
 viene di default messo da 
\begin_inset Quotes eld
\end_inset

defconfig
\begin_inset Quotes erd
\end_inset

, nota che molte configurazioni ad hoc sono messe a disposizione, per scorrerle
 possiamo navigare nella directory 
\begin_inset Quotes eld
\end_inset

arch/$ARCH/configs
\begin_inset Quotes erd
\end_inset

, ad esempio nella directory 
\begin_inset Quotes eld
\end_inset

arch/powerpc/configs
\begin_inset Quotes erd
\end_inset

 possiamo trovare configurazioni per la Nintendo WII (i.e., 
\begin_inset Quotes eld
\end_inset

wii_defconfig
\begin_inset Quotes erd
\end_inset

) eccetera, è buona norma una volta individuata la configurazione interessata,
 per scrivere la configurazione desiderata la stringa:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
make ARCH=arm sunxi_defconfig //scrive il file di configurazione .config
 per la configurazione 
\begin_inset Quotes eld
\end_inset

sunxi-defconfig
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
ora possiamo eseguire il comando make con le compilazione desiderate
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
caricare la vecchia configurazione più opzioni nuove messe a default (utile
 negli aggiornamenti di kernel)
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
in questo caso ci basterà eseguire un 
\begin_inset Quotes eld
\end_inset

make olddefconfig
\begin_inset Quotes erd
\end_inset

 nella directory del kernel senza poi andare a modificare nulla, questo
 ci permetterà di usare la vecchia configurazione del kernel e mette le
 nuove features aggiunte ad opzioni di defaule (solitamente sicure)
\end_layout

\end_deeper
\begin_layout Itemize
caricare la vecchia configurazione più i moduli utilizzati dal kernel corrente
 interrogando lsmod (utile negli aggiornamenti di kernel)
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
in questo caso ci basterà eseguire un 
\begin_inset Quotes eld
\end_inset

make localmodconfig
\begin_inset Quotes erd
\end_inset

 e rispondere con invio (cioè opzione di default) per le nuove voci, una
 volta fatto, avremo una configurazione compatibile con quella attuale,
 è molto simile a 
\begin_inset Quotes eld
\end_inset

make oldconfig
\begin_inset Quotes erd
\end_inset

 la differenza sta nel fatto che oltre a caricare il vecchio file di configurazi
one interroga anche lsmod per i moduli caricati attualmente dal kernel.
 NOTA: Tutto quello non collegato al computer non verrà incluso, si consiglia
 quindi prima di eseguire questa procedura di montare tutte le periferiche
 che utilizziamo spesso 
\begin_inset Quotes eld
\end_inset

chiavette USB
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

Card Flash/MMC
\begin_inset Quotes erd
\end_inset

 eccetera, per includere le altre cose, ci basterà caricare il vecchio kernel
 e vedere il nome del module (e se dipende da altri moduli), poi utilizzando
 la funzione di ricerca nel menuconfig li aggiungiamo manualmente.
 E' interessante lo scenario in cui volessimo ad esempio compilare il kernel
 per un altro computer, quello che possiamo fare è:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

target$ lsmod > /tmp/mylsmod 
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

target$ scp /tmp/mylsmod host:/tmp
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

host$ make LSMOD=/tmp/mylsmod localmodconfig
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
trovare i moduli necessari a partire da una configurazione di default
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
questo è simile al primo punto, ma a sua differenza abbiamo bisogno di moduli
 che non sono stati aggiunti dalla configurazione di default, questi possiamo
 aggiungerli da una live eseguendo un 
\begin_inset Quotes eld
\end_inset

lspci -k
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

lsusb -v
\begin_inset Quotes erd
\end_inset

 ed 
\begin_inset Quotes eld
\end_inset

lspcmcia
\begin_inset Quotes erd
\end_inset

 se necessario e una volta trovati i nomi dei moduli, possiamo cercarli
 ed abilitarli nel kernel attraverso il 
\begin_inset Quotes eld
\end_inset

make menuconfig
\begin_inset Quotes erd
\end_inset

 e poi il tasto 
\begin_inset Quotes eld
\end_inset

/
\begin_inset Quotes erd
\end_inset

, una volta trovati possiamo abilitarli schiacciando i tasti numerici della
 tastiera per posizionarci direttamente sulle voci di menu trovate dalla
 ricerca
\end_layout

\end_deeper
\begin_layout Standard
N.B.: Potrebbero a volte esserci problemi con kernel che non caricano correttament
e device come alcune schede video (AMD), quindi driver 
\begin_inset Quotes eld
\end_inset

radeon
\begin_inset Quotes erd
\end_inset

 o schede di rete wifi (tipo moduli come iwlwifi), questo può essere dovuto
 al fatto che abbiamo incluso dei driver come 
\begin_inset Quotes eld
\end_inset

built-in
\begin_inset Quotes erd
\end_inset

, infatti alcuni driver hanno la necessità di essere caricati come moduli,
 in quanto hanno bisogno di caricare dei firmware che di per sè sono automaticam
ente moduli, a meno che non sia abilitata la lista dei firmware da caricare
 come built-in attraverso l'opzione 
\begin_inset Quotes eld
\end_inset

CONFIG_EXTRA_FIRMWARE
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
SPIEGAZIONE DETTAGLIATA: I driver caricati come built-in vengono automaticamente
 caricati all'avvio del kernel, e non possono nella fase di avvio andare
 a caricare driver moduli che sono sull'hard disk, quindi siccome alcuni
 device hanno driver che devono richiamare a loro volta dei firmware per
 essere caricati correttamente, se il driver viene caricato 
\begin_inset Quotes eld
\end_inset

built-in
\begin_inset Quotes erd
\end_inset

 non può accedere nella fasi di boot al disco per caricare il driver modulo,
 quindi abbiamo due soluzioni a questo problem:
\end_layout

\begin_layout Itemize
o vengono caricati sia driver che firmware come moduli (soluzione consigliata,
 che comporterebbe semplicemente il caricamente del driver del dispositivo
 come modulo anzichè 
\begin_inset Quotes eld
\end_inset

built-in
\begin_inset Quotes erd
\end_inset

) 
\end_layout

\begin_layout Itemize
o caricare entrambi come built-in, andando a caricare il driver del dispositivo
 come 
\begin_inset Quotes eld
\end_inset

built-in
\begin_inset Quotes erd
\end_inset

 e aggiungendo l'opzione 
\begin_inset Quotes eld
\end_inset

CONFIG_EXTRA_FIRMWARE
\begin_inset Quotes erd
\end_inset

 con i path in cui sono contenuti i firmware, che permette di avere i firmware
 
\begin_inset Quotes eld
\end_inset

built-in
\begin_inset Quotes erd
\end_inset

 e quindi caricati in RAM all'avvio.
\end_layout

\begin_layout Standard
N.B.: Ricordare oltre a caricare i driver della scheda audio, ad includere
 i codec disponibili per la scheda audio.
\end_layout

\begin_layout Standard
Nel caso usassimo un initramfs, the only thing we will need in the kernel
 is CONFIG_BLK_DEV_INITRD=y If you want to build your initramfs image into
 the kernel.
 This way you won't need to pass an initrd option to your bootloader, but
 when you update the initramfs image, you will also need to rebuild the
 kernel.
 If you do want to do this, give the path to the initramfs.cpio file in Initramfs
 source file(s).
\end_layout

\begin_layout Standard
General Setup —> [*] Initial RAM filesystem and RAM disk (initramfs/initrd)
 support () Initramfs source file(s)
\end_layout

\begin_layout Subsection
Alternative a 
\begin_inset Quotes eld
\end_inset

make menuconfig
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Vediamo alcune alternative a make menuconfig, utili in vari casi:
\end_layout

\begin_layout Itemize
make help //questo mostra le varie opzioni che abbiamo per i vari step della
 compilazione, è molto utile nel caso dimenticassimo una delle opzioni di
 compilazione
\end_layout

\begin_layout Itemize
make allmodconfig //imposta la maggior parte delle cose come modulo, potrebbe
 generare un kernel inutilizzabile
\end_layout

\begin_layout Itemize
make allnoconfig //This option creates a config file that will only add
 essential code to the kernel; this answers no to as many questions as possible.
 This can sometimes make a kernel that does not work on the hardware it
 was compiled on
\end_layout

\begin_layout Itemize
make allyesconfig //This option creates a config file that will answer yes
 to as many questions as possible
\end_layout

\begin_layout Itemize
make nconfig //Text-based colored menus - curses (libcdk5-dev) must be installed
\end_layout

\begin_layout Itemize
make ${PLATFORM}_defconfig //Creates a config file using values from arch/$ARCH/
configs/${PLATFORM}_defconfig, utile per cross-compilazione
\end_layout

\begin_layout Standard
Nota che le distro user friendly utilizzano comunemente due soluzioni per
 caricare in automatico i driver necessari, una soluzione è:
\end_layout

\begin_layout Itemize
caricare il filesystem utilizzato per la root partition come built-in e
 tutto il resto dei driver come moduli
\end_layout

\begin_layout Itemize
caricare tutto come modulo ed utilizzare un initramfs che gestisce il corretto
 boot di tutto
\end_layout

\begin_layout Subsection
Sezioni di Configurazione
\end_layout

\begin_layout Standard
The main menu if the configuration programs is split out into the following
 sections:
\end_layout

\begin_layout Itemize
a.
 General setup Provides overall Linux options.
\end_layout

\begin_layout Itemize
b.
 Enable loadable module support 
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Provides the ability to load kernel modules.
 Sub-options provide additional capabilities related to modules.
\end_layout

\end_deeper
\begin_layout Itemize
c.
 Enable the block layer 
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
This needs to be enabled to be able to mound any disk drive.
\end_layout

\end_deeper
\begin_layout Itemize
d.
 Processor type and features 
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
The defaults will set most of these properly for your hardware, but you
 may want to disable options that may not apply such as Multi-core scheduler
 support.
 You can also set the number of CPUs that the kernel supports.
\end_layout

\begin_layout Itemize
You can also set support for some specific laptop brands.
\end_layout

\end_deeper
\begin_layout Itemize
e.
 Power management and ACPI options 
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Controls ACPI (Advanced Configuration and Power Interface) or APM (Advanced
 Power Management) BIOS support.
 These options are most useful on laptops.
\end_layout

\end_deeper
\begin_layout Itemize
f.
 Bus options (PCI etc) Generally only PCI suport is needed here on newer
 systems.
 Go with the defaults.
\end_layout

\begin_layout Itemize
g.
 Executable file formats / Emulations
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Generally only ELF support is needed.
\end_layout

\end_deeper
\begin_layout Itemize
h.
 Networking support 
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
This is where networking (including wireless) is enabled.
 Netfilter (firewall) capabilities are also defined here.
 The defaults are generally satisfactory.
\end_layout

\end_deeper
\begin_layout Itemize
i.
 Device Drivers 
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
This is one of the most important configuration areas.
 If you want the hardware to work, it has to be enabled with a driver.
 Check your devices on a currently running system with `lspci -v` to confirm
 what hardware you have.
 Enable any network or usb devices that you may have.
 Video drivers and sound cards are also enabled here.
 
\end_layout

\begin_layout Itemize
Take your time in this section and make sure you add drivers for all the
 hardware you want to use.
\end_layout

\end_deeper
\begin_layout Itemize
j.
 Firmware Drivers
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
The default is generally OK here.
\end_layout

\end_deeper
\begin_layout Itemize
k.
 File systems
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
If you want reiser, ext4, jfs, xfs, kernel automounter support, or nfs,
 you need to select those capabilities here.
\end_layout

\end_deeper
\begin_layout Itemize
l.
 Kernel hacking
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
If you make changes here, you better know why.
\end_layout

\end_deeper
\begin_layout Itemize
m.
 Security options
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
The defaults are generally OK here too.
\end_layout

\end_deeper
\begin_layout Itemize
n.
 Cryptographic API
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Specialized crytographic capabilites.
 The defaults are OK here.
\end_layout

\end_deeper
\begin_layout Itemize
o.
 Virtualization
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Allows using your Linux host to run other operating systems inside virtual
 machines (guests).
 
\end_layout

\end_deeper
\begin_layout Itemize
p.
 Library routines 
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Various CRC routines.
 The defaults are generally appropriate here unless you have special requirement
s.
 
\end_layout

\end_deeper
\begin_layout Subsection
Cross Compilazione del Kernel
\end_layout

\begin_layout Standard
Per effettuare una cross compilazione del kernel quello che dobbiamo fare
 è settare due variabili d'ambiente:
\end_layout

\begin_layout Itemize
ARCH //questa variabile d'ambiente contiene un'informazione sull'architettura
 target, i valori ammissibili corrispondono alle architetture che vediamo
 nella directory 
\begin_inset Quotes eld
\end_inset

arch/
\begin_inset Quotes erd
\end_inset

 come ad esempio arm, blackfin, cris, powerpc, x86, x86_64, eccetera.
\end_layout

\begin_layout Itemize
CROSS_COMPILE //questa variabile d'ambiente contiene il prefisso alla toolchain
 di cross compilazione
\end_layout

\begin_layout Standard
In alcuni casi può essere utile utilizzare una configurazione pre-esistente
 per farlo possiamo controllare nel path 
\begin_inset Quotes eld
\end_inset

arch/architetturaInteressata/configs/
\begin_inset Quotes erd
\end_inset

 le varie configurazioni, e se per esempio l'architetturaInteressata in
 questione è 
\begin_inset Quotes eld
\end_inset

arm
\begin_inset Quotes erd
\end_inset

 allora eseguiamo:
\end_layout

\begin_layout Itemize
make ARCH=arm wii_defconfig
\end_layout

\begin_layout Standard
una volta scritta la configurazione possiamo continuare con la compilazione.
\end_layout

\begin_layout Standard
Ad esempio nel caso volessimo compilare un kernel per architettura arm,
 una volta installata la toolchain di compilazione, eseguiamo:
\end_layout

\begin_layout Itemize
make -j5 ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- zImage //cross compilo
 un kernel, ricordiamo che zImage è solo un esempio, potrei anche non specificar
e il tipo di immagine, solo che a volte abbiamo dei vincoli in funzione
 del boot loader che utilizziamo
\end_layout

\begin_layout Standard
una volta compilato possiamo compilare i moduli con:
\end_layout

\begin_layout Itemize
make -j5 ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- modules
\end_layout

\begin_layout Standard
e poi possiamo installare i moduli andando ad eseguire:
\end_layout

\begin_layout Itemize
make -j5 ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- INSTALL_MOD_PATH=/path/wher
e/i/have/rootfs modules_install //questo installerà i module, nella directory
 specificata, attenzione la directory specificata dovrà essere il rootfs
 del sistema ospite poi ci penserà make a selezionare la directory giusta
 dove installare i moduli
\end_layout

\begin_layout Subsection
Pulizia dei Sorgenti del Kernel
\end_layout

\begin_layout Standard
Per eseguire una pulizia dei file per un'altra compilazione, in quanto il
 makefile precedentemente ha già generato dei file oggetto per dei sorgenti,
 per evitare conflitti abbiamo diverse alternative:
\end_layout

\begin_layout Itemize
make clean //elimina la maggior parte dei file intermedi e dei file oggetti
\end_layout

\begin_layout Itemize
make mrproper //rimuove tutti i file intermedi, nella rimozione è incluso
 il file 
\begin_inset Quotes eld
\end_inset

.config
\begin_inset Quotes erd
\end_inset

, questo viene utilizzato per ripristinare il source tree del kernel allo
 stati in cui era appena scaricato, estratto o clonato (con git), si chiama
 
\begin_inset Quotes eld
\end_inset

mrproper
\begin_inset Quotes erd
\end_inset

 in quanto una serie di prodotti per la pulizia in alcuni paesi del mondo
 è chiamata così
\end_layout

\begin_layout Itemize
make distclean //simile a mrproper ma elimina anche file di patch e file
 di backup generati magari da editor di testo, insomma non rimane proprio
 nulla
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Subsection
Kernel Runtime Management e Troubleshooting
\end_layout

\begin_layout Standard
Una parte importante del nostro kernel è la capacità di caricare 
\begin_inset Quotes eld
\end_inset

device drivers
\begin_inset Quotes erd
\end_inset

 cioè moduli che vengono caricati che ci permettono di interfacciarci con
 l'hardware esterno, o interno.
 I moduli sono gestiti attraverso i comandi 
\begin_inset Quotes eld
\end_inset

lsmod
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

modprobe
\begin_inset Quotes erd
\end_inset

 e con le opzioni fornite dalla directory 
\begin_inset Quotes eld
\end_inset

/etc/modprobe.d/
\begin_inset Quotes erd
\end_inset

.
 Per visualizzare i moduli correntemente caricati dal kernel possiamo eseguire:
\end_layout

\begin_layout Itemize
lsmod //visualizza i driver correntemente caricati, formattando il contenuto
 del file 
\begin_inset Quotes eld
\end_inset

/proc/modules
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Si rimanda alla sezione sui Moduli, per un approfondimento sulla loro gestione
\end_layout

\begin_layout Subsubsection
Sysctl
\end_layout

\begin_layout Standard
The kernel provides some parameters that may be set at runtime through sysctl.
 the format is `sysctl ${parameter} = ${value}` or `sysctl -a` to display
 all, ad esempio per abilitare la nostra macchina al forwarding dei pacchetti
 possiamo utilizzare.
 Vediamo alcuni esempi di applicazione:
\end_layout

\begin_layout Itemize
sysctl -a //visualizza le possibili opzioni
\end_layout

\begin_layout Itemize
sysctl net.ipv4.ip_forward=1 //imposta l'impostazione ip_forward abilitata,
 questa permette alla nostra macchina di dare da forwarder, questo è equivalente
 ad eseguire 
\begin_inset Quotes eld
\end_inset

echo 1 > /proc/sys/net/ipv4/ip_forward
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Section
Linux Monitoring
\end_layout

\begin_layout Standard
In questa sezione ci occuperemo di:
\end_layout

\begin_layout Itemize
misurare l'utilizzo di risorse
\end_layout

\begin_layout Itemize
risolvere problemi relativi all'utilizzo di risorse
\end_layout

\begin_layout Itemize
migliorare la gestione delle risorse
\end_layout

\begin_layout Standard
Strumenti standard per la gestione delle risorse che sono installati sulla
 maggior parte delle distro di default sono:
\end_layout

\begin_layout Itemize
vmstat
\end_layout

\begin_layout Itemize
uptime
\end_layout

\begin_layout Itemize
who
\end_layout

\begin_layout Itemize
top
\end_layout

\begin_layout Itemize
lsof
\end_layout

\begin_layout Itemize
netstat
\end_layout

\begin_layout Itemize
pstree
\end_layout

\begin_layout Itemize
lsof
\end_layout

\begin_layout Itemize
ps
\end_layout

\begin_layout Subsection
Vmstat
\end_layout

\begin_layout Standard
Il programma 
\begin_inset Quotes eld
\end_inset

vmstat
\begin_inset Quotes erd
\end_inset

 costituisce uno dei programmi più importanti di quelli forniti di default,
 possiamo lanciarlo con:
\end_layout

\begin_layout Itemize
vmstat //avvia vmstat
\end_layout

\begin_layout Itemize
vmstat -S M //avvia vmstat mostrando gli utilizzi di memoria in MB
\end_layout

\begin_layout Itemize
vmstat -a //avvia vmstat mostrato la memoria attiva/inattiva
\end_layout

\begin_layout Itemize
vmstat 5 3 //avvia vmstat, si avvierà 3 volte distanziate da 5 secondi
\end_layout

\begin_layout Standard
vedremo diverse informazioni sullo schermo dove:
\end_layout

\begin_layout Itemize
r: numero totale di processi che aspettano tempo CPU, ergo coda processi
\end_layout

\begin_layout Itemize
b: numero totale di processi bloccati che sono in attesa di risorse come
 disco o rete
\end_layout

\begin_layout Itemize
Swpd: memoria virtuale usata
\end_layout

\begin_layout Itemize
Free: memoria virtuale libera
\end_layout

\begin_layout Itemize
Buff: memoria usata come buffer (percorsi delle directory e cosa c'è all'interno
)
\end_layout

\begin_layout Itemize
Cache: memoria usata come cache (contenuto dei file)
\end_layout

\begin_layout Itemize
Si: quantità di memoria swappata dal disco ogni secondo
\end_layout

\begin_layout Itemize
So: quantità di memoria swappata sul disco ogni secondo
\end_layout

\begin_layout Itemize
Bi: blocchi in ingresso al secondo
\end_layout

\begin_layout Itemize
Bo: blocchi in uscita al secondo
\end_layout

\begin_layout Itemize
In: interrupt al secondo
\end_layout

\begin_layout Itemize
Cs: context switch che avvengono al secondo
\end_layout

\begin_layout Standard
possiamo utilizzare:
\end_layout

\begin_layout Itemize
sudo bash -c 
\begin_inset Quotes eld
\end_inset

echo 3 > /proc/sys/vm/drop_caches
\begin_inset Quotes erd
\end_inset

 //libera la memoria utilizzata dal buffer e dalla cache
\end_layout

\begin_layout Standard
Il problema con questi tool citati presenti nel package 
\begin_inset Quotes eld
\end_inset

procps
\begin_inset Quotes erd
\end_inset

 e che non ci permettono di lavorare con dati storici, quindi non possiamo
 visualizzare in modo comodo una history ed inoltre hanno funzionalità basilari,
 vedremo nelle prossime sezioni strumenti più avanzati.
\end_layout

\begin_layout Subsection
Monitoring da riga di comando
\end_layout

\begin_layout Standard
Per avere un sistema di monitoring più avanzato è utile installare il pacchetto
 
\begin_inset Quotes eld
\end_inset

sysstat
\begin_inset Quotes erd
\end_inset

 che costituisce un'evoluzione del precedente vmstat dal pacchetto 
\begin_inset Quotes eld
\end_inset

procps
\begin_inset Quotes erd
\end_inset

, il pacchetto 
\begin_inset Quotes eld
\end_inset

sysstat
\begin_inset Quotes erd
\end_inset

 contiene tool simili a procps come ad esempio 
\begin_inset Quotes eld
\end_inset

iostat
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

mpstat
\begin_inset Quotes erd
\end_inset

 e ci permettono di raccogliere informazioni periodicamente in modo da avere
 quadri precisi delle prestazioni e un monitoring più completo.
 I dati con sysstat vengono raccolti ogni 10 minuti e possono essere letti
 attraverso 
\begin_inset Quotes eld
\end_inset

sar
\begin_inset Quotes erd
\end_inset

, in pratica lo script 
\begin_inset Quotes eld
\end_inset

sa1
\begin_inset Quotes erd
\end_inset

 raccoglie dati ogni 10 minuti e lo script 
\begin_inset Quotes eld
\end_inset

sa2
\begin_inset Quotes erd
\end_inset

 ne fa un resoconto quotidiano; questi due script, sa1 e sa2 sono abilitati
 attraverso cron.
 Possiamo quindi installare sysstat con:
\end_layout

\begin_layout Itemize
sudo apt-get install sysstat
\end_layout

\begin_layout Standard
sulle distro Debian-based dopo l'installazione dobbiamo abilitare il raccoglimen
to di dati attraverso il file 
\begin_inset Quotes eld
\end_inset

/etc/default/sysstat
\begin_inset Quotes erd
\end_inset

 andando ad abilitare la stringa 
\begin_inset Quotes eld
\end_inset

ENABLED=
\begin_inset Quotes erd
\end_inset

true
\begin_inset Quotes erd
\end_inset


\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Una volta installato possiamo visualizzare il cron relativo con:
\end_layout

\begin_layout Itemize
sudo cat /etc/cron.d/sysstat //visualizza il file di cron di sysstat, di
 default, raccoglie dati ogni 10 minuti con sa1 e fa un resoconto giornaliero
 con sa2
\end_layout

\begin_layout Standard
Gli strumenti di sysstat sono:
\end_layout

\begin_layout Itemize
iostat //fornisce informazioni su CPU e I/O disk
\end_layout

\begin_layout Itemize
mpstat //fornisce informazioni dettagliate su CPU
\end_layout

\begin_layout Itemize
pidstat //mostra informazioni sui processi
\end_layout

\begin_layout Itemize
cifsiostat //mostra informazioni su SAMBA 
\end_layout

\begin_layout Itemize
nfsiostat //mostra informazioni su NFS
\end_layout

\begin_layout Itemize
sar //raccoglie e mostra dati sull'attività del sistema
\end_layout

\begin_layout Standard
Vediamo alcuni esempi applicativi:
\end_layout

\begin_layout Itemize
sar -V //mostra la versione del programma 
\end_layout

\begin_layout Itemize
sar //mostra info sulla CPU
\end_layout

\begin_layout Itemize
sar -q //mostra info sul carico medio
\end_layout

\begin_layout Itemize
sar -q 1 3 //mostra info sul carico medio 3 volte con un intervallo da 1
 secondo
\end_layout

\begin_layout Itemize
sar -q -f /var/log/sa/sa15 //mostra informazioni sul carico medio del giorno
 15 del mese su distro RH-based
\end_layout

\begin_layout Itemize
sar -q -f /var/log/sysstat/sa15 //mostra informazioni sul carico medio del
 giorno 15 del mese su distro Debian-based
\end_layout

\begin_layout Itemize
sar -w //processi creati al secondo e context switch al secondo
\end_layout

\begin_layout Itemize
sar -n DEV //statistiche sull'interfaccia di rete specificata tipo 
\begin_inset Quotes eld
\end_inset

eth0
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
sar -b //dati sulle attività di I/O generale
\end_layout

\begin_layout Itemize
sar -q -s 10:00:00 -e 11:00:00 //mostra informazioni di carico medio dalle
 10 alle 11 del giorno corrente 
\begin_inset Quotes eld
\end_inset

-s
\begin_inset Quotes erd
\end_inset

 (start time) 
\begin_inset Quotes eld
\end_inset

-e
\begin_inset Quotes erd
\end_inset

 (end time)
\end_layout

\begin_layout Itemize
sar -w -s 14:00:00 -e 20:00:00 -f /var/log/sa/sa11 //mostra informazioni
 sui processi e i context switch tra le 14 e le 20 dal giorno 11 del mese
 su distro RH-based, basta cambiare la locazione del file per le distro
 Debian-based
\end_layout

\begin_layout Subsection
Monitoring Grafico con CollectD
\end_layout

\begin_layout Standard
Per mostrare informazioni grafiche di monitoring, dobbiamo installare collectd.
 Possiamo installarlo attraverso:
\end_layout

\begin_layout Itemize
sudo apt-get install collectd
\end_layout

\begin_layout Standard
La configurazione varia molto a differenza della distro, bisogna guardare
 la documentazione.Compilare programmi
\end_layout

\begin_layout Standard
Possiamo compilare programmi, innanzitutto scaricando i sorgenti, questo
 è possibile attraverso:
\end_layout

\begin_layout Itemize
sudo apt-get source nomePGM //scarica il codice sorgente del programma nomePGM
\end_layout

\begin_layout Standard
una volta scaricato il source-code possiamo trovarlo in 
\begin_inset Quotes eld
\end_inset

/usr/src/nomePGMeVersione
\begin_inset Quotes erd
\end_inset

, quindi ci sposteremo nella directory interessata per potere procedere
 con la compilazione
\end_layout

\begin_layout Section
Compilare programmi
\end_layout

\begin_layout Standard
Possiamo compilare programmi, innanzitutto scaricando i sorgenti, questo
 è possibile attraverso:
\end_layout

\begin_layout Itemize
sudo apt-get source nomePGM //scarica il codice sorgente del programma nomePGM
\end_layout

\begin_layout Standard
una volta scaricato il source-code possiamo trovarlo in 
\begin_inset Quotes eld
\end_inset

/usr/src/nomePGMeVersione
\begin_inset Quotes erd
\end_inset

, quindi ci sposteremo nella directory interessata per potere procedere
 con la compilazione, ma prima verifichiamo di aver installato i pacchetti
 fondamentali per poter compilare:
\end_layout

\begin_layout Itemize
sudo apt-get install build-essential //installa i pacchetti fondamentali
 per la compilazione, sulle distro RH-based eseguiremo invece un 
\begin_inset Quotes eld
\end_inset

yum groupinstall 
\begin_inset Quotes eld
\end_inset

Development Tools
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Section
Gentoo Linux
\end_layout

\begin_layout Standard
Portage is the package manager of gentoo, it is completely written in Python
 and Bash and therefore fully visible to the users as both are scripting
 languages.
\end_layout

\begin_layout Standard
Most users will work with Portage through the emerge tool.
 This chapter is not meant to duplicate the information available from the
 emerge man page.
 For a complete rundown of emerge's options, please consult the man page.
\end_layout

\begin_layout Standard
Per vedere il portage tree andiamo in:
\end_layout

\begin_layout Itemize
cd /usr/portage //ci posizioniamo nella directory contenente il tree di
 portage
\end_layout

\begin_layout Standard
il portage di tree è organizzzato in categorie, e in ogni categoria ci sono
 varie applicazioni, e per ogni applicazioni c'è il proprio ebuild, un ebuild
 è un file contenente informazioni per la compilazione di uno specifico
 pacchetto.
 Per poter visualizzare la versione di portage eseguiamo:
\end_layout

\begin_layout Itemize
emerge –info | head //mostra la versione di portage
\end_layout

\begin_layout Standard
an interesting feature for security is:
\end_layout

\begin_layout Itemize
glsa-check //which checks if installed software has vulnerabilities
\end_layout

\begin_layout Subsection
USE Flags
\end_layout

\begin_layout Standard
To help users in deciding what to install/activate and what not, Gentoo
 wanted the user to specify his/her environment in an easy way.
 This forces the user into deciding what they really want and eases the
 process for portage to make useful decisions.
 Quindi cos'è uno USE flag ? Such a flag is a keyword that embodies support
 and dependency-information for a certain concept.
 If someone defines a certain USE flag, Portage will know that they want
 support for the chosen keyword.
 Of course this also alters the dependency information for a package.
 Take a look at a specific example: the kde keyword.
 If this keyword is not in the USE variable, all packages that have optional
 KDE support will be compiled without KDE support.
 All packages that have an optional KDE dependency will be installed without
 installing the KDE libraries (as dependency).
 When the kde keyword is defined, then those packages will be compiled with
 KDE support, and the KDE libraries will be installed as dependency.
 Noi possiamo definire i nostri USE flag all'interno della variabile 
\begin_inset Quotes eld
\end_inset

USE
\begin_inset Quotes erd
\end_inset

.
 To make it easy for users to search and pick USE flags, we already provide
 a default USE setting.
 This setting is a collection of USE flags we think are commonly used by
 the Gentoo users.
 This default setting is declared in the make.defaults files that are part
 of the selected profile.
 
\end_layout

\begin_layout Subsubsection
Kinds of USE Flags
\end_layout

\begin_layout Standard
Ci sono due tipi di USE flags:
\end_layout

\begin_layout Itemize
Globali, sono use flag usati da molti pacchetti, per una configurazione
 di sistema, una lista di USE Flag globali disponibili può essere trovata
 in /usr/portage/profiles/use.desc
\end_layout

\begin_layout Itemize
Locali, sono gli USE flag specifici relativi ed utilizzati da un singolo
 pacchetto, una lista di USE flag locali può essere trovata in /usr/portage/prof
iles.local.desc
\end_layout

\begin_layout Standard
Per vedere la lista di USE flag completa usiamo:
\end_layout

\begin_layout Itemize
emerge –info | grep ^USE
\end_layout

\begin_layout Subsubsection
Cambiare Impostazioni su USE flag
\end_layout

\begin_layout Standard
Possiamo cambiare impostazioni per gli USE flag globalmente o per singoli
 pacchetti.
\end_layout

\begin_layout Paragraph
Configurazione Globale
\end_layout

\begin_layout Standard
To change this default setting, add or remove keywords to/from the USE variable.
 This is done globally by defining the USE variable in 
\begin_inset Quotes eld
\end_inset

/etc/portage/make.conf
\begin_inset Quotes erd
\end_inset

.
 In this variable one can add the extra USE flags required, or remove the
 USE flags that are no longer needed.
 This latter is done by prefixing the keyword with the minus-sign (-).
 
\end_layout

\begin_layout Paragraph
Configurazione per Pacchetto
\end_layout

\begin_layout Standard
ometimes users want to declare a certain USE flag for one (or a couple)
 of applications but not system-wide.
 To accomplish this, edit /etc/portage/package.use.
 This is usually a single file, but can also be a directory; see man portage
 for more information.
 The following examples assume package.use is a single file.
 Ad esempio per abilitare lo USE flag chiamato 
\begin_inset Quotes eld
\end_inset

berkdb
\begin_inset Quotes erd
\end_inset

 per il pacchetto 
\begin_inset Quotes eld
\end_inset

dev-db/mysql
\begin_inset Quotes erd
\end_inset

 eseguiamo:
\end_layout

\begin_layout Itemize
echo 
\begin_inset Quotes eld
\end_inset

dev-db/mysql berkdb
\begin_inset Quotes erd
\end_inset

 >> /etc/portage/package.use 
\end_layout

\begin_layout Standard
Similarly it is possible to explicitly disable USE flags for a certain applicati
on.
 For instance, to disable java support in PHP (but have it for all other
 packages through the USE flag declaration in make.conf): 
\end_layout

\begin_layout Itemize
echo 
\begin_inset Quotes eld
\end_inset

dev-php/php -java
\begin_inset Quotes erd
\end_inset

 >> /etc/portage/package.use
\end_layout

\begin_layout Standard
E' anche possibile definire USE flag temporanei, cioè non validi permanentemente
 per uno specifico pacchetto ma solo per la momentanea sessione, questo
 può avvenire attraverso la ridefinizione della variabile USE da un terminale
 con:
\end_layout

\begin_layout Itemize
USE=
\begin_inset Quotes erd
\end_inset

-flag1 flag2
\begin_inset Quotes erd
\end_inset

 //i flag menzionati sono fittizi
\end_layout

\begin_layout Standard
Esiste una certa precedenza quando viene ispezionata la configurazione degli
 USE flag, nell'installazione di un pacchetto:
\end_layout

\begin_layout Itemize
Default USE setting dichiatati nei make.defaults file del nostro profilo
\end_layout

\begin_layout Itemize
user-defined USE settings in /etc/portage/make.conf
\end_layout

\begin_layout Itemize
user-defined USE setting in /etc/portage/package.use
\end_layout

\begin_layout Itemize
user-defined USE setting definiti come variabile d'ambiente nella sessione
 corrente del terminale in uso
\end_layout

\begin_layout Standard
Quando avvengono cambi agli USE flag, il sistema deve essere aggiornato
 in modo appropriato per includere il supporto per il nuovo flag, questo
 avviene con:
\end_layout

\begin_layout Itemize
emerge –update –deep –newuse @world
\end_layout

\begin_layout Subsection
Portage Quick Tutorial
\end_layout

\begin_layout Standard
In questa sezione impariamo ad usare una distro molto flessibile (una delle
 mie preferite, al punto da dedicarle un'intera sezione).
 Gentoo Linux ha un gestore di pacchetti chiamato portage che comprende
 diversi tool, il suo cavallo di battaglia è emerge, vediamo alcuni comandi:
\end_layout

\begin_layout Itemize
emerge –sync //aggiorna il repository utilizzando rsync, quindi un servizio
 TCP sulla porta 873, questo repository è aggiornato ogni 30 minuti, ed
 è più veloce rispetto al metodo http
\end_layout

\begin_layout Itemize
emerge-webrsync //aggiorna il repository fetchando online il tree, questo
 snapshot del repository viene fatto una volta al giorno, è più lento rispetto
 al metodo rsync ma utilizza le chiavi gpg, ed è vantaggioso se utilizzato
 ad esempio quando un firewall blocca rsync
\end_layout

\begin_layout Itemize
emerge nomePacchetto //installa il pacchetto menzionato
\end_layout

\begin_layout Standard
quando sta installando un pacchetto, questo viene compilato 
\begin_inset Quotes eld
\end_inset

di default
\begin_inset Quotes erd
\end_inset

, e siccome a volte la compilazione potrebbe portar via molto tempo, possiamo
 renderci conto dei progressi eseguendo un:
\end_layout

\begin_layout Itemize
tail -f /var/log/emerge.log //mostra il progresso della compilazione in corso
\end_layout

\begin_layout Standard
possiamo anche vedere le alcune informazioni sullo scaricamento dei pacchetti
 piuttosto che della compilazione eseguendo:
\end_layout

\begin_layout Itemize
less /var/log/emerge-fetch.log //visualizza informazioni sullo scaricamento
 dei pacchetti
\end_layout

\begin_layout Itemize
emerge –ask nomePacchetto //visualizza informazioni sul pacchetto, diminutivo
 di -a
\end_layout

\begin_layout Itemize
emerge –info //mostra tutte le opzioni di configurazione, come USE flags
 utilizzati, opzioni di compilazione
\end_layout

\begin_layout Itemize
emerge –search 
\begin_inset Quotes eld
\end_inset

pdf
\begin_inset Quotes erd
\end_inset

 //cerca nel repository tutti i programmi che hanno nel nome la stringa
 menzionata, alternativa è 
\begin_inset Quotes eld
\end_inset

-s
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
ls /usr/portage/package-cat/package-name/ //elenca tutte le versioni disponibili
 per l'installazione di un pacchetto, quest'operazione è più comodamente
 fatta con l'uso di 
\begin_inset Quotes eld
\end_inset

eix
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
emerge –searchdesc 
\begin_inset Quotes eld
\end_inset

multimedia player
\begin_inset Quotes erd
\end_inset

 //cerca nel repository tutti i programmi che hanno nella descrizione la
 stringa menzionata, alternativa è 
\begin_inset Quotes eld
\end_inset

-S
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
emerge nomePacchetto –autounmask-write //inserisce le modifiche necessarie
 per i flag nel file package.use, dopo dovremo solo eseguire 
\begin_inset Quotes eld
\end_inset

dispatch-conf
\begin_inset Quotes erd
\end_inset

 per rendere effettive le modifiche
\end_layout

\begin_layout Itemize
emerge –pretend 
\begin_inset Quotes eld
\end_inset

vifm
\begin_inset Quotes erd
\end_inset

 //visualizza le dipendenze del programma selezionato con i diversi USE
 flag, l'alternativa è il flag
\begin_inset Quotes eld
\end_inset

-p
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
emerge -pv 
\begin_inset Quotes eld
\end_inset

vifm
\begin_inset Quotes erd
\end_inset

 //visualizza oltre alle dipendenze anche la dimensione dei file scaricati,
 ad esempio possiamo da qui visualizzare se la documentazione è stata scaricata
 andando ad ispezionare gli USE Flag disponibili, infatti la documentazione
 corrisponde allo use flag 
\begin_inset Quotes eld
\end_inset

doc
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
emerge –fetchonly nomePacchetto //in questo caso vengono scaricati solo
 i sorgenti
\end_layout

\begin_layout Itemize
emerge –unmerge nomePacchetto //rimuove il pacchetto ma lascia le sue dipendenze
 e anche i file di configurazione, il flag corrispettivo è 
\begin_inset Quotes eld
\end_inset

-C
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
emerge –update –deep –newuse @world //aggiorna dopo aver alterato le impostazion
i degli USE flag, l'alternativa è usare i flag 
\begin_inset Quotes eld
\end_inset

-uDN
\begin_inset Quotes erd
\end_inset

, è sconsigliato aggiornare senza l'opzione deep, anche se in realtà gli
 aggiornamenti delle dipendenze necessarie vengono fatti lo stesso anche
 senza l'opzione deep, ma deep è per aggiornare le dipendenze anche quando
 non è richiesto
\end_layout

\begin_layout Itemize
emerge -uDNp @world //Lists packages which have an update available.
 Note: Some provide special commands to limit the output to certain installation
 sources, others use options.
 
\end_layout

\begin_layout Itemize
emerge –resume –exclude packageName //in questo caso se ad esempio abbiamo
 problemi con portage, nel caso in cui ad esempio un pacchetto all'interno
 di un aggiornamento di sistema mi da problemi, in questo caso non solo
 possiamo dire ad emerge di continuare da dove aveva avuto problemi, ma
 anche di escludere il pacchetto che da problemi, magari prima di eseguirlo
 possiamo considerare di installare una versione nota stabile di quel pacchetto
\end_layout

\begin_layout Itemize
emerge -ep world //Display a list of all packages in all installation sources
 that are handled by the packages management.
 Some tools provide options or additional commands to limit the output to
 a specific installation source.
 
\end_layout

\begin_layout Itemize
CONFIG_PROTECT=
\begin_inset Quotes erd
\end_inset

-*
\begin_inset Quotes erd
\end_inset

 && emerge -aC nomePacchetto //rimuove il pacchetto con tutti i relativi
 file di configurazione
\end_layout

\begin_layout Itemize
find /etc -type f -exec qfile -o {} + // in questo caso possiamo ricercare
 file che non appartengono a nessun pacchetto in modo da poterli eliminare,
 attenzione ai falsi positivi
\end_layout

\begin_layout Itemize
emerge –unmerge –depclean nomePacchetto //rimuove il pacchetto con tutte
 le sue dipendenze
\end_layout

\begin_layout Itemize
emerge –depclean //rimuove le dipendenze orfane, è consigliabile utilizzarlo
 dopo un aggiornamento del sistema, è simile ad 
\begin_inset Quotes eld
\end_inset

apt-get autoremove
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
emerge nomePacchetto –oneshot //in questo caso il pacchetto non viene incluso
 all'interno dell'insieme @world, utile in quanto ad esempio vogliamo tenere
 in questo insieme solo le applicazioni utente, e non anche quelle di sistema
 come portage, o altre librerie magari che ci servono per il development,
 ad esempio per un ipotetico aggiornamento di portage, eseguiamo 
\begin_inset Quotes eld
\end_inset

emerge -u1 nomePacchetto
\begin_inset Quotes erd
\end_inset

 //questo indica appunto col flag 
\begin_inset Quotes eld
\end_inset

1
\begin_inset Quotes erd
\end_inset

 abbreviazione di 
\begin_inset Quotes eld
\end_inset

–oneshot
\begin_inset Quotes erd
\end_inset

 di non aggiungere portage all'insieme @world
\end_layout

\begin_layout Subsubsection
Ricerca di informazioni su un pacchetto o su USE flags
\end_layout

\begin_layout Standard
Un programma più veloce e potente di emerge per effettuare ricerche e query
 a portage è eix.
\end_layout

\begin_layout Standard
It is made to be more efficient and flexible than the emerge –search command.
 eix comes with colorized output which helps users easily find the needed
 package information.
 
\end_layout

\begin_layout Standard
Vediamo alcuni comandi:
\end_layout

\begin_layout Itemize
eix nomePacchetto //mi mostra le versioni disponibili di un pacchetto e
 i vari useflag disponibili
\end_layout

\begin_layout Itemize
update-eix //aggiorna la cache di eix
\end_layout

\begin_layout Itemize
eix-sync //questo comando esegue sia un emerge –sync che un update-eix in
 un colpo solo, utile quando dobbiamo aggiornare i repository
\end_layout

\begin_layout Itemize
eix stringa_cercata //cercare una stringa contenuta nel nome di un pacchetto
\end_layout

\begin_layout Itemize
eix -e nome_pacchetto //cercare un pacchetto con il nome esatto
\end_layout

\begin_layout Itemize
eix -S stringa_cercata //cercare una stringa nella descrizione di un pacchetto
\end_layout

\begin_layout Itemize
eix -I //elenca tutti i pacchetti installati
\end_layout

\begin_layout Itemize
eix -U use_flag //visualizza tutti i pacchetti che utilizzano la use flag
 menzionata
\end_layout

\begin_layout Itemize
eix -C nome_categoria //visualizza tutti i pacchetti della categoria menzionata
\end_layout

\begin_layout Itemize
eix lib -IU -C kde-base //ricerca tutti i pacchetti installati della categoria
 
\begin_inset Quotes eld
\end_inset

kde-base
\begin_inset Quotes erd
\end_inset

 con la USE flag 
\begin_inset Quotes eld
\end_inset

hal
\begin_inset Quotes erd
\end_inset

 abilitata e il cui nome contiene la stringa “lib”
\end_layout

\begin_layout Itemize
euse -i nomeFlag //fornisce la descrizione dei vari flag col nome menzionato
\end_layout

\begin_layout Itemize
equery f nomepacchetto //visualizza il percorso di tutti i file installati
 dal pacchetto menzionato, può essere utile per vedere le dimensioni del
 pacchetto installato, in quanto queste possono variare in funzione delle
 opzioni di compilazione selezionate, l'opzione corrispettiva è 
\begin_inset Quotes eld
\end_inset

files
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
equery files –tree nomePacchetto //richiede la struttura ad albero di ogni
 file installato dal pacchetto menazionato
\end_layout

\begin_layout Itemize
equery belongs nomeComando
\end_layout

\begin_layout Itemize
equery u nomePacchetto //mostra i vari USE flag disponibili per il pacchetto
 menzionato con la relativa descrizione (MOOLTO UTILE) per caapire cosa
 si sta includendo e cosa no, la tabella contiene due colonne 
\begin_inset Quotes eld
\end_inset

I
\begin_inset Quotes erd
\end_inset

 ed 
\begin_inset Quotes eld
\end_inset

U
\begin_inset Quotes erd
\end_inset

, I is the setting it's currently installed with, U is what it will be set
 to if you rebuild or upgrade
\end_layout

\begin_layout Itemize
qlist nomepacchetto //è un'alternativa più veloce (da verificare) al comando
 precedente
\end_layout

\begin_layout Itemize
q //mi mostra una serie di operazione disponibili sui pacchetti
\end_layout

\begin_layout Itemize
qsize nomepacchetto //mi mostra lo spazio occupato dal pacchetto menzionato
\end_layout

\begin_layout Itemize
e-file determinatoComando //mi mostra in quale pacchetto è contenuto il
 comando menzionato, il programma e-file è contenuto nel pacchetto app-portage/p
fl
\end_layout

\begin_layout Itemize
equery d -a xorg-server //elenca tutti i pacchetti installati che hanno
 come dipendenza 
\begin_inset Quotes eld
\end_inset

d
\begin_inset Quotes erd
\end_inset

 il pacchetto 
\begin_inset Quotes eld
\end_inset

xorg-server
\begin_inset Quotes erd
\end_inset

, mentre col flag 
\begin_inset Quotes eld
\end_inset

-a
\begin_inset Quotes erd
\end_inset

 elenca tutti i pacchetti nel repository che hanno quella dipendenza, e
 ci potrebbe mettere un bel po'
\end_layout

\begin_layout Standard
Talvolta durante l'operazione di installazione i pacchetti di gentoo potrebbero
 dare problemi con i cosiddetti 
\begin_inset Quotes eld
\end_inset

USE
\begin_inset Quotes erd
\end_inset

 flag, in questo caso, dobbiamo innanzitutto verificare di aver selezionato
 il profilo corretto attraverso:
\end_layout

\begin_layout Itemize
eselect profile list
\end_layout

\begin_layout Itemize
eselect profile set 8 //imposta il profilo numero 8
\end_layout

\begin_layout Standard
e poi nonostante il profilo sia impostati molti altri flag dovranno essere
 settati manualmente, per farlo possiamo utilizzare emerge direttamente,
 andando ad utilizzare il comando:
\end_layout

\begin_layout Itemize
emerge nomePacchetto –autounmask-write //viene creato un file di configurazione
 atto a contenere il flag necessario all'installazione del pacchetto, il
 pacchetto non viene installato, dovremo prima confermare la configurazione
 col comando 
\begin_inset Quotes eld
\end_inset

dispatch-conf
\begin_inset Quotes erd
\end_inset

 e poi reinstallarlo normalmente con 
\begin_inset Quotes eld
\end_inset

emerge nomepacchetto
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Il file /etc/portage/make.conf contiene configurazioni globali per quanto
 riguarda il processo di compilazione come ad esempio anche gli 
\begin_inset Quotes eld
\end_inset

USE
\begin_inset Quotes erd
\end_inset

 flag globali, infatti se uno USE flag viene spesso richiesto, è buona norma
 inserirlo tra quelli globali.
\end_layout

\begin_layout Subsubsection
equery
\end_layout

\begin_layout Standard
equery is a tool to make several common Portage operations simpler.
 Among other operations, it can display package dependencies, metadata,
 and installed files.
 
\end_layout

\begin_layout Itemize
equery which firefox-bin //mi mostra dov'è situato l'ebuild del comando
 firefox-bin
\end_layout

\begin_layout Itemize
equery uses packageName //mi mostra gli attuali use flag utilizzati per
 il pacchetto menzionato
\end_layout

\begin_layout Itemize
equery size packageName //mi mostra lo spazio su disco occupato dal pacchetto
\end_layout

\begin_layout Itemize
equery list '*' //mi elenca tutti i pacchetti installati sul sistema
\end_layout

\begin_layout Itemize
equery list amarok //mi elenca la versione attualmente installata del pacchetto
\end_layout

\begin_layout Itemize
equery depends packageName //mi elenca i pacchetti che dipendono dal pacchetto
 menzionato
\end_layout

\begin_layout Itemize
equery hasuse qt4 //mi elenca tutti i pacchetti che hanno come use flag
 qt4
\end_layout

\begin_layout Itemize
equery uses packageName //mi elenca quali use flag sono attualmente attivi
 per il pacchetto menzionato
\end_layout

\begin_layout Itemize
equery belongs commandName //mi indica a quale pacchetto appartiene un determina
to comando che è già installato sul sistema, per cercare file o comandi
 che non sono ancora installati bisogna installare pfl, ed usare 
\begin_inset Quotes eld
\end_inset

e-file
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
equery check packageName //verifica i checksum per un dato pacchetto
\end_layout

\begin_layout Itemize
equery –help //mi elenca le varie opzioni disponibili
\end_layout

\begin_layout Subsubsection
pfl
\end_layout

\begin_layout Standard
Il programma pfl fa riferimento al sito web 
\begin_inset CommandInset href
LatexCommand href
name "Portage File Dist"
target "http://www.portagefilelist.de/"

\end_inset

.
\end_layout

\begin_layout Itemize
e-file nomeComandoOnomeFile //ricerca i pacchetti anche non installati che
 contengono uno specifico comando/file
\end_layout

\begin_layout Subsubsection
Overlays
\end_layout

\begin_layout Standard
Gli overlays sono repository secondary dove possiamo reperire ebuilds che
 non sono disponibili nel ports tree principale\SpecialChar endofsentence
 Per utilizzare gli overlay,
 possiamo eseguire:
\end_layout

\begin_layout Itemize
emerge layman //installa layman, il pacchetto che gestisce i repository
 secondari
\end_layout

\begin_layout Standard
una volta installato dobbiamo avvertire emerge della sua presenza, questo
 è possibile eseguendo
\end_layout

\begin_layout Itemize
echo "source /var/lib/layman/make.conf" >> /etc/portage/make.conf //copia
 impostazioni di configurazione per gli overlay, in questo modo possiamo
 installare i pacchetti dei repo non ufficiali con emerge, se emerge trova
 pacchetti con lo stesso nome in più repo, installa quello più recente
\end_layout

\begin_layout Standard
vediamo alcuni esempi di comandi layman:
\end_layout

\begin_layout Itemize
layman -L //elenca la lista dei repository non ufficiali
\end_layout

\begin_layout Itemize
layman -a open-overlay //installa il repository chiamato 
\begin_inset Quotes eld
\end_inset

open-overlay
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
layman -l //elenca la lista dei repository non ufficiali installati sulla
 macchina
\end_layout

\begin_layout Itemize
layman -S //aggiorna i repository non ufficiali già installati, cioè quelli
 che visualizzo con 
\begin_inset Quotes eld
\end_inset

-l
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
layman -s nomeRepo //aggiorna solo lo specifico repository menzionato
\end_layout

\begin_layout Subsubsection
eselect
\end_layout

\begin_layout Standard
eselect is the Gentoo's multi-purpose configuration and management tool,
 vediamo alcuni esempi:
\end_layout

\begin_layout Itemize
eselect news list //elenca le news
\end_layout

\begin_layout Itemize
eselect news read 2 //legge la news numero 2
\end_layout

\begin_layout Itemize
eselect kernel list //elenca i kernel
\end_layout

\begin_layout Itemize
eselect kernel set 2 //imposta come kernel di default il numero 2
\end_layout

\begin_layout Itemize
eselect profile list //mostra la lista profili, un profilo corrisponde ad
 un insieme di USE flag di default, l'insieme dei programmi macherati 
\begin_inset Quotes eld
\end_inset

masks
\begin_inset Quotes erd
\end_inset

, ed il gruppo di pacchetti @system
\end_layout

\begin_layout Standard
generalmente per eselect ci basta inserire:
\end_layout

\begin_layout Itemize
eselect //visualizza la lista dei moduli disponibili 
\end_layout

\begin_layout Standard
e per capire cosa posso fare con un modulo inserisco:
\end_layout

\begin_layout Itemize
eselct nomeModulo help //ad esempio 
\begin_inset Quotes eld
\end_inset

eselect news help
\begin_inset Quotes erd
\end_inset

 mi fornirà la lista delle operazioni possibili
\end_layout

\begin_layout Subsubsection
eclean
\end_layout

\begin_layout Standard
By default, 
\end_layout

\begin_layout Itemize
source files are located in the 
\begin_inset Quotes eld
\end_inset

/usr/portage/distfiles
\begin_inset Quotes erd
\end_inset

 directory
\end_layout

\begin_layout Itemize
binary packages are located in the /usr/portage/packages directory
\end_layout

\begin_layout Standard
The locations for each can be changed by altering the DISTDIR and the PKGDIR
 variables respectively in /etc/portage/make.conf.
 Both locations can grow quite big if not periodically cleaned; this is
 the reason eclean was created.
 
\end_layout

\begin_layout Itemize
eclean distfiles //ripulisce la cartella dove vengono salvati i sorgenti,
 posso anche usare il comando più breve 
\begin_inset Quotes eld
\end_inset

eclean-dist
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
eclean -d distfile //ripulisce in modo destructive lasciando solo le versioni
 correnti del portage tree installate
\end_layout

\begin_layout Itemize
eclean packages //ripulisce la cartella dove vengono salvati i precompilati,
 posso anche usare il comando più breve 
\begin_inset Quotes eld
\end_inset

eclean-pkg
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
E' consigliabile se si ha molto poco spazio effettuare un clean al mese
 circa.
\end_layout

\begin_layout Subsubsection
Pacchetti Precompilati
\end_layout

\begin_layout Standard
Gentoo permette all'utente di installare pacchetti precompilati, ad esempio
 possiamo addirittura settare un server ftp dove teniamo i precompilati,
 supponiamo questo sia al'indirizzo 
\begin_inset Quotes eld
\end_inset

ftp://buildhost/gentoo
\begin_inset Quotes erd
\end_inset

, allora a questo punto possiamo impostare come variabile all'interno di
 
\begin_inset Quotes eld
\end_inset

/etc/portage/make.conf
\begin_inset Quotes erd
\end_inset

, la stringa:
\end_layout

\begin_layout Itemize
PORTAGE_BINHOST=
\begin_inset Quotes erd
\end_inset

ftp://buildhost/gentoo
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
ora da una macchina su cui è stato impostato questo indirizzo possiamo eseguire:
\end_layout

\begin_layout Itemize
emerge –usepkg –getbinpkg nomePacchetto //per provare prima a reperire il
 precompilato e solo se questo non è disponibile scaricarlo e installarlo
\end_layout

\begin_layout Standard
per pacchettizare un pacchetto già installato eseguiamo:
\end_layout

\begin_layout Itemize
quickpkg nomePacchetto //crea un pacchetto del precompilato il pacchetto
 menzionato
\end_layout

\begin_layout Standard
per pacchettizzare un programma non ancora installato ed installarlo eseguiamo:
\end_layout

\begin_layout Itemize
emerge –buildpkg nomePacchetto //installa il pacchetto menzionato e ne crea
 anche una pacchetto precompilato
\end_layout

\begin_layout Itemize
emerge –buildpkgonly nomePacchetto //crea il pacchetto precompilato del
 nome pacchetto menzionato senza installare nessun pacchetto
\end_layout

\begin_layout Standard
Possiamo inoltre impostare che di default per ogni pacchetto installato
 venga creato l'eseguibile, questo avviene attraverso l'attivazione della
 feature 
\begin_inset Quotes eld
\end_inset

buildpkg
\begin_inset Quotes erd
\end_inset

, infatti ci basterà aggiungere la stringa 
\begin_inset Quotes eld
\end_inset

buildpkg
\begin_inset Quotes erd
\end_inset

 alla variabile FEATURES in /etc/portage/make.conf.
\end_layout

\begin_layout Subsubsection
Licenze
\end_layout

\begin_layout Standard
Possiamo decidere di installare pacchetti anche in base alla licenza, questo
 è impostabile attraverso il file 
\begin_inset Quotes eld
\end_inset

/etc/portage/make.conf
\begin_inset Quotes erd
\end_inset

, con:
\end_layout

\begin_layout Itemize
ACCEPT_LICENSE=
\begin_inset Quotes erd
\end_inset

* -@EULA
\begin_inset Quotes erd
\end_inset

 //in questo caso accettiamo tutti i pacchetti esclusi quelli con EULA
\end_layout

\begin_layout Standard
E' possibile oltre ad impostare la variabile ACCEPT_LICENSE come configurazione
 globale, creare configurazioni per pacchetto ad esempio specificando i
 file relativi ad ogni pacchetto, inserendo una stringa nel file /etc/portage/pa
ckage.license.
\end_layout

\begin_layout Standard
Ad esempio:
\end_layout

\begin_layout Itemize
app-crypt/truecrypt truecrypt-2.7 //questo se messo nel file /etc/portage/package.
license, mi permette di installare tutte le versioni di truecrypt che hanno
 la licenza 
\begin_inset Quotes eld
\end_inset

truecrypt-2.7
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Subsubsection
Dove posso trovare le licenze ? 
\end_layout

\begin_layout Standard
Le licenze sono salvate singolarmente in /usr/portage/licenses/, mentre
 i gruppi di licenze in 
\begin_inset Quotes eld
\end_inset

/usr/portage/profiles/license_groups
\begin_inset Quotes erd
\end_inset

.
 La prima voce in maiuscolo è il nome del gruppo di licenze mentre ogni
 voce successiva rappresenta le singole licenze.
 Inoltre è utile ricordare che i gruppi di licenze sono contrassegnate dal
 simbolo 
\begin_inset Quotes eld
\end_inset

@
\begin_inset Quotes erd
\end_inset

, ad esempio, possiamo trovare un esempio di /etc/portage/make.conf dove
 andiamo ad abilitare il gruppo licenze 
\begin_inset Quotes eld
\end_inset

FREE
\begin_inset Quotes erd
\end_inset

, quindi avremo:
\end_layout

\begin_layout Itemize
ACCEPT_LICENSE=
\begin_inset Quotes erd
\end_inset

-* @FREE
\begin_inset Quotes erd
\end_inset

 //abilito il gruppo di licenze free, cioè quelle definite free dall'FSF
 e dall'OSI.
\end_layout

\begin_layout Subsubsection
Modifiche agli USE Flag
\end_layout

\begin_layout Standard
A volte capita installando nuovo software, che per essere installato o il
 software stesso o almeno una delle dipendenze, richieda la modifica degli
 USE flag, per mettere a posto questo problema abbiamo a disposizione due
 soluzioni:
\end_layout

\begin_layout Itemize
modificare il file delle configurazioni globali 
\begin_inset Quotes eld
\end_inset

/etc/portage/make.conf
\begin_inset Quotes erd
\end_inset

, aggiungendo il flag necessario nella voce relativa agli USE flags
\end_layout

\begin_layout Itemize
modificare il file 
\begin_inset Quotes eld
\end_inset

/etc/portage/package.use
\begin_inset Quotes erd
\end_inset

 inserendo singolarmente pacchetto per pacchetto gli use flag necessari
\end_layout

\begin_layout Subsubsection
Aggiornare il sistema
\end_layout

\begin_layout Standard
Per aggiornare il sistema eseguiamo un aggiornamento dei repository con:
\end_layout

\begin_layout Itemize
emerge –sync //aggiorna il portage tree, se si usa eix, è più comodo usare
 eix-sync
\end_layout

\begin_layout Standard
e poi aggiorniamo tutti i pacchetti con:
\end_layout

\begin_layout Itemize
emerge –update –ask @world //questo attraverso l'opzione 
\begin_inset Quotes eld
\end_inset

–ask
\begin_inset Quotes erd
\end_inset

 mi avviserà anche dei pacchetti che verranno aggiornati, ma verranno aggiornati
 solo i programmi elencati in /var/lib/portage/world, e non tutte le loro
 dipendenze
\end_layout

\begin_layout Standard
nel caso volessimo aggiornare anche le dipendenze allora eseguiamo:
\end_layout

\begin_layout Itemize
emerge –update –deep @world //aggiorna anche le dipendenze dei pacchetti
 
\end_layout

\begin_layout Standard
ma anche in questo caso non stiamo aggiornando tutte le dipendenze, infatti
 esistono altri tipi di dipendenze chiamate 
\begin_inset Quotes eld
\end_inset

build dependencies
\begin_inset Quotes erd
\end_inset

 che hanno la necessità di esistere durante il processo di compilazione
 e building del programma, una volta che il programma è stato compilato
 non sono più necessarie, per aggiornare queste dipendenze eseguiamo:
\end_layout

\begin_layout Itemize
emerge –update –deep –with-bdeps=y @world
\end_layout

\begin_layout Standard
se dall'ultimo aggiornamento delle modifiche agli USE flag sono avvenuti,
 allora è consigliato utilizzare:
\end_layout

\begin_layout Itemize
emerge –update –deep –with-bdeps=y –newuse @world //l'opzione 
\begin_inset Quotes eld
\end_inset

–newuse
\begin_inset Quotes erd
\end_inset

 si assicura di installare le applicazione precedentemente installate includendo
 i nuovi USE flag 
\end_layout

\begin_layout Section
Debian
\end_layout

\begin_layout Standard
Debian ha tre maggiori distribuzioni:
\end_layout

\begin_layout Itemize
Stable
\end_layout

\begin_layout Itemize
Testing
\end_layout

\begin_layout Itemize
Unstable (sempre chiamata sid)
\end_layout

\begin_layout Standard
Per capire che versione stiamo runnando facciamo:
\end_layout

\begin_layout Itemize
lsb_release -a
\end_layout

\begin_layout Standard
However some systems might have sources.list files with multiple entries
 corresponding to different distributions.
 This could happen if the administrator is tracking different packages from
 different Debian distributions.
 This is frequently referred to as apt-pinning.
 These systems might run a mixture of distributions.
 
\end_layout

\begin_layout Standard
Gli autori di un pacchetto possiamo trovarli in 
\begin_inset Quotes eld
\end_inset

/usr/share/doc/PACKAGE/copyright
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Per compilare programmi abbiamo bisogno del pacchetto build-essential, possiamo
 anche aver bisogno per alcuni pacchetti di autoconf o gettext.
\end_layout

\begin_layout Standard
Per compilarmi un programma posso eseguire, anche se le dipendenze in realtà
 vengono installate e non compilate (da verificare):
\end_layout

\begin_layout Itemize
apt-get build-dep foo;apt-get source –build foo
\end_layout

\begin_layout Standard
Le librerie sono installate in appositi package denominati 
\begin_inset Quotes eld
\end_inset

package-dev
\begin_inset Quotes erd
\end_inset

, infatti se mi serve la libreria libx.so molto probabilmente la troverò
 nel package 
\begin_inset Quotes eld
\end_inset

libx-dev
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Le pagine di man per altre lingue, sono disponibili col pacchetto 
\begin_inset Quotes eld
\end_inset

manpages-LANG
\begin_inset Quotes erd
\end_inset

 ad esempio per le pagine in italiano il pacchetto è 
\begin_inset Quotes eld
\end_inset

manpages-it
\begin_inset Quotes erd
\end_inset

 e così via; Inoltre l'utente deve settare la variabile LC_MESSAGES in modo
 appropriato per vedere i man nella lingua scelta.
\end_layout

\begin_layout Subsection
Pacchetti
\end_layout

\begin_layout Standard
Packages generally contain all of the files necessary to implement a set
 of related commands or features.
 There are two types of Debian packages:
\end_layout

\begin_layout Itemize
Binary packages, which contain executables, configuration files, man/info
 pages, copyright information, and other documentation.
 These packages are distributed in a Debian-specific archive format (see
 What is the format of a Debian binary package?, Section 7.2); they are usually
 distinguished by having a '.deb' file extension.
 Binary packages can be unpacked using the Debian utility dpkg (possibly
 via a frontend like aptitude); details are given in its manual page.
\end_layout

\begin_layout Itemize
Source packages, which consist of a .dsc file describing the source package
 (including the names of the following files), a .orig.tar.gz file that contains
 the original unmodified source in gzip-compressed tar format and usually
 a .diff.gz file that contains the Debian-specific changes to the original
 source.
 The utility dpkg-source packs and unpacks Debian source archives; details
 are provided in its manual page.
 (The program apt-get can get used a frontend for dpkg-source.) 
\end_layout

\begin_layout Standard
The Debian binary package file names conform to the following convention:
 <foo>_<VersionNumber>-<DebianRevisionNumber>_<DebianArchitecture>.deb
\end_layout

\begin_layout Standard
Ai pacchetti possono essere associati diversi flag, questi sono chiamati
 "want" flags tell what the user wanted to do with a package (as indicated
 either by the user's actions in the "Select" section of dselect, or by
 the user's direct invocations of dpkg).
\end_layout

\begin_layout Standard
Their meanings are:
\end_layout

\begin_layout Itemize
unknown - the user has never indicated whether he wants the package
\end_layout

\begin_layout Itemize
install - the user wants the package installed or upgraded
\end_layout

\begin_layout Itemize
remove - the user wants the package removed, but does not want to remove
 any existing configuration files.
\end_layout

\begin_layout Itemize
purge - the user wants the package to be removed completely, including its
 configuration files.
\end_layout

\begin_layout Itemize
hold - the user wants this package not to be processed, i.e., he wants to
 keep the current version with the current status whatever that is.
 
\end_layout

\begin_layout Subsection
Compilare pacchetti
\end_layout

\begin_layout Standard
How do I build binary packages from a source package?
\end_layout

\begin_layout Standard
The preferred way to do this is by using various wrapper tools.
 We'll show how it's done using the devscripts tools.
 Install this package if you haven't done so already.
\end_layout

\begin_layout Standard
Now, first get the source package:
\end_layout

\begin_layout Itemize
apt-get source foo
\end_layout

\begin_layout Standard
and change to the source tree:
\end_layout

\begin_layout Itemize
cd foo-*
\end_layout

\begin_layout Standard
Then install needed build-dependencies (if any):
\end_layout

\begin_layout Itemize
sudo apt-get build-dep foo
\end_layout

\begin_layout Standard
Then create a dedicated version of your own build (so that you won't get
 confused later when Debian itself releases a new version)
\end_layout

\begin_layout Itemize
dch -l local 'Blah blah blah'
\end_layout

\begin_layout Standard
And finally build your package
\end_layout

\begin_layout Itemize
debuild -us -uc
\end_layout

\begin_layout Standard
If everything worked out fine, you should now be able to install your package
 by running
\end_layout

\begin_layout Itemize
sudo dpkg -i ../*.deb
\end_layout

\begin_layout Standard
If you prefer to do things manually, and don't want to use devscripts, follow
 this procedure:
\end_layout

\begin_layout Standard
You will need all of foo_*.dsc, foo_*.tar.gz and foo_*.diff.gz to compile the
 source (note: there is no .diff.gz for some packages that are native to Debian).
\end_layout

\begin_layout Standard
Once you have them (How do I install a source package?, Section 7.13), if
 you have the dpkg-dev package installed, the following command:
\end_layout

\begin_layout Itemize
dpkg-source -x foo_version-revision.dsc
\end_layout

\begin_layout Standard
will extract the package into a directory called foo-version.
\end_layout

\begin_layout Standard
If you want just to compile the package, you may cd into foo-version directory
 and issue the command
\end_layout

\begin_layout Itemize
dpkg-buildpackage -rfakeroot -b
\end_layout

\begin_layout Standard
to build the package (note that this also requires the fakeroot package),
 and then
\end_layout

\begin_layout Itemize
dpkg -i ../foo_version-revision_arch.deb
\end_layout

\begin_layout Standard
to install the newly-built package(s).
 
\end_layout

\begin_layout Subsection
Installare grossi gruppi di pacchetti
\end_layout

\begin_layout Standard
Possiamo usare tasksel, per installare grossi gruppi di pacchetti, come
 ad esempio la suite di KDE, o GNOME, molto utile nel momento in cui dobbiamo
 installare DE.
\end_layout

\begin_layout Itemize
sudo tasksel
\end_layout

\begin_layout Subsection
Tenere aggiornare i repository regolarmente
\end_layout

\begin_layout Standard
You can use cron-apt, this tool updates the system at regular interval by
 using a cron job.
 By default it just updates the package list and download new packages without
 installing.
 
\end_layout

\begin_layout Subsection
Tenere aggiornati i repository di più macchine
\end_layout

\begin_layout Standard
If you have more than one Debian machine on your network, it is useful to
 use apt-proxy to keep all of your Debian systems up-to-date.
\end_layout

\begin_layout Standard
apt-proxy reduces the bandwidth requirements of Debian mirrors by restricting
 the frequency of Packages, Releases and Sources file updates from the back
 end and only doing a single fetch for any file, independently of the actual
 request it from the proxy.
 apt-proxy automatically builds a Debian HTTP mirror based on requests which
 pass through the proxy.
\end_layout

\begin_layout Standard
For more details, see the apt-proxy homepage at http://apt-proxy.sourceforge.net/
\end_layout

\begin_layout Standard
Of course, you can get the same benefit if you are already using a standard
 caching proxy and all your systems are configured to use it.
 
\end_layout

\begin_layout Subsection
Using dpkg-divert
\end_layout

\begin_layout Standard
How do I override a file installed by a package, so that a different version
 can be used instead?
\end_layout

\begin_layout Standard
Suppose a sysadmin or local user wishes to use a program "login-local" rather
 than the program "login" provided by the Debian login package.
\end_layout

\begin_layout Standard
Do not:
\end_layout

\begin_layout Standard
Overwrite /bin/login with login-local.
\end_layout

\begin_layout Standard
The package management system will not know about this change, and will
 simply overwrite your custom /bin/login whenever login (or any package
 that provides /bin/login) is installed or updated.
\end_layout

\begin_layout Standard
Rather, do
\end_layout

\begin_layout Standard
Execute:
\end_layout

\begin_layout Itemize
dpkg-divert –divert /bin/login.debian /bin/login
\end_layout

\begin_layout Standard
in order to cause all future installations of the Debian login package to
 write the file /bin/login to /bin/login.debian instead.
\end_layout

\begin_layout Standard
Then execute:
\end_layout

\begin_layout Itemize
cp login-local /bin/login
\end_layout

\begin_layout Standard
to move your own locally-built program into place.
\end_layout

\begin_layout Standard
Run 
\end_layout

\begin_layout Itemize
dpkg-divert –list 
\end_layout

\begin_layout Standard
to see which diversions are currently active on your system.
\end_layout

\begin_layout Standard
Details are given in the manual page dpkg-divert(8).
 
\end_layout

\begin_layout Subsection
Alternative a categorie di programmi
\end_layout

\begin_layout Standard
Possiamo browsare la directory /etc/alternatives, varie categorie di programmi,
 e utilizzare il comando:
\end_layout

\begin_layout Itemize
update-alternatives –display x-window-manager //mostra le alternative, della
 categoria x-window-manager, le alternative mostrate sono quelle installate
 sul sistema
\end_layout

\begin_layout Itemize
update-alternatives –config x-window-manager //mi permette di cambiare window
 manager con una procedura guidata
\end_layout

\begin_layout Standard
se un'alternativa non compare tra le alternative possiamo usare:
\end_layout

\begin_layout Itemize
update-alternatives –install /usr/bin/x-window-manager 
\backslash
 x-window-manager /usr/local/bin/wmaker-cvs 50 //in questo caso, l'ultimo
 attributo è la priorità, una priorità più alta significa che questo window
 manager sarà più probabilmente settato come window manager di default
\end_layout

\begin_layout Standard
per rimuovere un'alternativa eseguiamo:
\end_layout

\begin_layout Itemize
update-alternatives –remove x-window-manager /usr/local/bin/wmaker-cvs //rimuove
 un'alternativa
\end_layout

\begin_layout Subsection
Fixare il sistema dopo aver rimosso dei pacchetti
\end_layout

\begin_layout Standard
In this case, look for /var/log/apt/history.log, look for the time around
 which your system was broken.
 Copy the removed packages which would be in the format of:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

libapt-inst1.5:amd64 (0.9.7.9+deb7u5, 0.9.7.9+deb7u6), apt-utils:amd64 (0.9.7.9+deb7u5,
 0.9.7.9+deb7u6).
\end_layout

\end_inset


\end_layout

\begin_layout Standard
e poi li reinstalliamo con un classico:
\end_layout

\begin_layout Itemize
sudo apt-get install <listaPacchetti>
\end_layout

\begin_layout Subsection
Repository non fidati e chiavi GPG
\end_layout

\begin_layout Standard
Può capitare cambiando i repository di incappare in questo errore:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

W: GPG error: http://http.kali.org /kali Release: The following signatures
 couldn't be verified because the public key is not available: NO_PUBKEY
 ED444FF07D8D0BF6
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In questo cass d'uso ho utilizzato un debootstrap per creare un ambiente
 debian in una distro debian, e nel sottoambiente ho voluto impostare i
 repository di kali una distribuzione linux derivata da debian (cambiano
 solo i repo) incentrata sui penetration test, per risolvere questo problema
 ci basta eseguire:
\end_layout

\begin_layout Itemize
gpg –keyserver pgpkeys.mit.edu –recv-key ED444FF07D8D0BF6 //questo pgpkeys.mit.edu
 è un server in cui sono presenti moltissime chiavi, quindi probabilmente
 ci ritroveremo spesso ad usarlo
\end_layout

\begin_layout Itemize
gpg -a –export ED444FF07D8D0BF6 > nomeChiave.txt
\end_layout

\begin_layout Itemize
sudo apt-key add nomeChiave.txt
\end_layout

\begin_layout Subsubsection
Gestione delle chiavi gpg su Debian
\end_layout

\begin_layout Standard
Possiamo gestire le chiavi su sistemi Debian o Debian based con i seguenti
 comandi:
\end_layout

\begin_layout Itemize
apt-key list //questo mostra l'intera lista di chiavi
\end_layout

\begin_layout Itemize
apt-key del "C23F 55C5" //questo cancella ad esempio una chiave, per l'id
 della chiave prendiamo gli ultimi 8 caratteri del fingerprint che vediamo
 in apt-key list, oppure a volte abbiamo un identificativo in apt-key list
 come 
\begin_inset Quotes eld
\end_inset

pub 1024D/437D05B5 2004-09-12
\begin_inset Quotes erd
\end_inset

 in questo caso l'id della chiave è 
\begin_inset Quotes eld
\end_inset

437D05B5
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Subsection
Supporto per i PPA
\end_layout

\begin_layout Standard
Molte volte si cita come svantaggio di Debian rispetto alle distro Ubuntu
 based, l'assenza di PPA, cioè repository secondari, in realtà questi si
 possono utilizzare, è molto semplice, basterà seguire i seguenti passi:
\end_layout

\begin_layout Enumerate
andare sul sito del PPA desiderato e scegliere una versione a caso di Ubuntu
 e copiare le stringhe relative al repository (in realtà ci basterebbe solo
 quella del sorgente 
\begin_inset Quotes eld
\end_inset

deb-src
\begin_inset Quotes erd
\end_inset

, una volta copiate queste due stringhe mettiamole all'interno di /etc/apt/sourc
es.list
\end_layout

\begin_layout Enumerate
aggiungiamo la chiave GPG del PPA con 
\begin_inset Quotes eld
\end_inset

apt-key adv –keyserver keyserver.ubuntu.com –recv-keys <stringa_dopo_lo_slash_sott
o_la_voce_signing_key_sul_sito_del_ppa>
\end_layout

\begin_layout Enumerate
apt-get update
\end_layout

\begin_layout Enumerate
apt-get source -b nomePacchetto //questo compila il pacchetto, potrebbe
 darmi problemi di compilazione, devo installare i pacchetti necessari che
 mancano al processo di compilazione, questo creerà un paio di pacchetti
 
\begin_inset Quotes eld
\end_inset

.deb
\begin_inset Quotes erd
\end_inset

 solitamente
\end_layout

\begin_layout Enumerate
dpkg -i nomePacchetto.deb //questo installa il programma, anche qui potrei
 avere problemi di dipendenze, anche in questo caso andrò ad installarle
\end_layout

\begin_layout Section
Audio
\end_layout

\begin_layout Standard
Per gestire l'output ho trovato i comandi utili:
\end_layout

\begin_layout Itemize
amixer -q set Master 10%+ //incremento il livello di volume del 10%, il
 flag 
\begin_inset Quotes eld
\end_inset

-q
\begin_inset Quotes erd
\end_inset

 (quiet) serve a sopprimere l'output)
\end_layout

\begin_layout Itemize
amixer -q set Master 10%- //decremento il livello di volume del 10% 
\end_layout

\begin_layout Itemize
amixer -q set Master mute //muto l'audio
\end_layout

\begin_layout Itemize
amixer -q set Master unmute //unmuto l'audio
\end_layout

\begin_layout Itemize
amixer get Master //mi fornisce il livello di volume attuale
\end_layout

\begin_layout Itemize
alsamixer //visualizzo i livelli di volume dell'audio e posso modificarli
 attraverso un'interfaccia TUI
\end_layout

\begin_layout Section
Tmp Filesystem
\end_layout

\begin_layout Standard
The cleaning of /tmp is done by the upstart script /etc/init/mounted-tmp.conf.
 The script is run by upstart everytime /tmp is mounted.
 Practically that means at every boot.
 The script does roughly the following: if a file in /tmp is older than
 $TMPTIME days it will be deleted.
 The default value of $TMPTIME is 0, which means every file and directory
 in /tmp gets deleted.
 $TMPTIME is an environment variable defined in /etc/default/rcS.
\end_layout

\begin_layout Standard
Notice that we can create temporary files with mktemp, for example: 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

my_tmp_file=$(mktemp)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
and write to it with:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

echo "ciaooo" > "$my_tmp_file"
\end_layout

\end_inset


\end_layout

\begin_layout Standard
remove it with: 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

rm "$my_tmp_file"
\end_layout

\end_inset


\end_layout

\begin_layout Standard
we can even create a temporary directory:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

my_tmp_dir=$(mktemp -d)
\end_layout

\end_inset


\end_layout

\begin_layout Section
Note sui Laptop (e alcuni PC)
\end_layout

\begin_layout Subsection
Backlight
\end_layout

\begin_layout Standard
Su alcuni laptop la gestione del backlight potrebbe non funzionare bene,
 in questi casi è consigliabile modificare dei parametri con cui lanciamo
 il nostro sistema operativo da grub, nello specifico andiamo a modificare
 il file /etc/default/grub (su molte distro è questo) la linea che dice
 
\begin_inset Quotes eld
\end_inset

GRUB_CMDLINE_LINUX_DEFAULT
\begin_inset Quotes erd
\end_inset

, infatti questa voce dovrà essere qualcosa di simile a questo:
\end_layout

\begin_layout Itemize
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash acpi_osi=Linux acpi_backlight=vendor"
 //imposta la backlight in modo che venga gestita da specifiche del produttore,
 nota che i parametri quiet e splash possono essere tolti per fornire un
 boot e uno shutdown verbose, nel caso dovessimo avere problemi al boot
 o allo shutdown
\end_layout

\begin_layout Standard
se questo non funziona possiamo provare con:
\end_layout

\begin_layout Itemize
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash acpi_osi="
\end_layout

\begin_layout Standard
oppure altre volte con ad esempio i driver nouveau potrebbe funzionare una
 cosa del tipo:
\end_layout

\begin_layout Itemize
GRUB_CMDLINE_LINUX_DEFAULT="nouveau.modeset=0 rd.driver.blacklist=nouveau acpi_back
light=vendor quiet splash"
\end_layout

\begin_layout Standard
una volta effettuata una di queste modifiche, dobbiamo aggiornare la configurazi
one di grub, possiamo farlo con:
\end_layout

\begin_layout Itemize
sudo update-grub //aggiorna la configurazione di grub
\end_layout

\begin_layout Standard
E' inoltre utile sapere che di default avremo una certa luminosità all'avvio
 della macchina, comunque questo valore è settabile tramite l'aggiunta di
 uno script che parte all'avvio che esegue:
\end_layout

\begin_layout Itemize
cat /sys/class/backlight/acpi_video0/max_brightness > /sys/class/backlight/acpi_
video0/brightness
\end_layout

\begin_layout Subsection
Distro che non eseguono Boot
\end_layout

\begin_layout Standard
A volte potrebbe capitare di avere delle distro che non eseguono correttamente
 il boot, ad esempio si fermano sul logo della distro al boot, in questo
 caso il motivo molto probabilmente è legato alla scheda video, possiamo
 impostare da grub come opzione al kernel la voce:
\end_layout

\begin_layout Itemize
nomodeset
\end_layout

\begin_layout Standard
quindi da grub ci basterà schiacciare 
\begin_inset Quotes eld
\end_inset

e
\begin_inset Quotes erd
\end_inset

 una volta selezionata la voce di boot interessata della distro e nella
 riga che inizia per 
\begin_inset Quotes eld
\end_inset

linux
\begin_inset Quotes erd
\end_inset

 aggiungere in append l'opzione 
\begin_inset Quotes eld
\end_inset

nomodeset
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
You may want to disable KMS for various reasons, such as getting a blank
 screen or a "no signal" error from the display, when using the Catalyst
 driver, etc.
 To disable KMS add nomodeset as a kernel parameter.
 See Kernel parameters for more info.
 A volte è necessario anche aggiungere altre opzioni oltre a nomodeset,
 in modo daindirizzare direttamente i nostri driver, come:
\end_layout

\begin_layout Itemize
nomodeset i915.modeset=0 nouveau.modeset=0
\end_layout

\begin_layout Subsection
ACPI and DSDT
\end_layout

\begin_layout Standard
In computing, the Advanced Configuration and Power Interface (ACPI) specificatio
n provides an open standard that the operating systems can use for computer
 hardware discovery, configuration, power management, and monitoring.
 Internally, ACPI exports the available functionalities by providing certain
 instruction lists as part of the system firmware, which the operating system
 kernel interprets and executes to perform desired operations, using a form
 of embedded virtual machine.
 First released in December 1996, ACPI defines platform-independent interfaces
 for hardware discovery, configuration, power management and monitoring,
 and is designed to replace Advanced Power Management (APM), the MultiProcessor
 Specification and the Plug and Play BIOS (PnP) Specification.
 ACPI brings the power management under the control of the operating system,
 as opposed to the previous BIOS-central system that relied on platform-specific
 firmware to determine power management and configuration policies.
 The specification is central to Operating System-directed configuration
 and Power Management (OSPM), a system implementing ACPI which removes device
 management responsibilities from legacy firmware interfaces.
 Intel, Microsoft and Toshiba originally developed the standard, while HP
 and Phoenix also participated later.
\end_layout

\begin_layout Standard
ACPI can typically be configured from within the operating system.
 This is unlike APM where configuration often involves rebooting and entering
 the BIOS configuration screens to set parameters.
\end_layout

\begin_layout Standard
ACPI has several different software components:
\end_layout

\begin_layout Itemize
a subsystem which controls hardware states and functions that may have previousl
y been in the BIOS configuration
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
These states include:
\end_layout

\begin_layout Itemize
thermal control
\end_layout

\begin_layout Itemize
motherboard configuration
\end_layout

\begin_layout Itemize
power states (sleep, suspend)
\end_layout

\end_deeper
\begin_layout Itemize
a policy manager, which is software that sits on top of the operating system
 and allows user input on the system policies
\end_layout

\begin_layout Itemize
the ACPI also has device drivers that control/monitor devices such as a
 laptop battery, SMBus (communication/transmission path) and EC (embedded
 controller).
\end_layout

\begin_layout Standard
ACPI is to laptop users what oxygen is to mankind.
 BIOS, by itself, provides very basic support for all the hardware typically
 found inside a laptop.
 It cannot, for example, handle what happens on opening/closing the laptop
 lid, plugging in/out the the AC adapter, pressing the brightness keys etc.
 Sleep and hibernate are two essential features for any laptop user which
 are too complex for BIOS to handle.
 All these laptop-specific tasks are instead handled by ACPI.
 The biggest advantage of ACPI is that it is OS-agnostic.
 So, ACPI features that work flawlessly on Windows can be almost always
 expected to work on Linux (the almost part will be explained in a moment).
\end_layout

\begin_layout Standard
DSDT (Differentiated System Description Table) is a table that describes
 the ACPI properties and functions of all your hardware.
 If certain ACPI feature is missing or functioning improperly on your laptop,
 you can safely put the blame on a badly coded DSDT.
 DSDT is written in a language known as ASL (ACPI Source Language) that
 looks at lot like C.
 Just like C, it needs to compiled before it can be used by the system.
 This is where the problem creeps in.
 ASL compilers are provided by Microsoft and Intel.
 Like all things Microsoft, their compiler is far too lenient when it comes
 to ASL syntax compared to Intel’s.
 Hence, DSDTs compiled using MS compiler are generally buggier and more
 problematic than Intel-compiled ones.
 Windows includes all sorts of hacks to mask the ineffectiveness of the
 MS compiler while Linux typically suffers in some way or the other (laptop
 not sleeping/hibernating, fan spinning constantly, brightness keys not
 working etc.).
\end_layout

\begin_layout Standard
Lament not, you can extract the DSDT of your system, edit it to fix the
 errors, and replace the original DSDT with the fixed one to resolve most
 issues.
\end_layout

\begin_layout Standard
Un pacchetto utile per l'acpi, è il pacchetto 
\begin_inset Quotes eld
\end_inset

acpi
\begin_inset Quotes erd
\end_inset

, questo ci permette di vedere informazioni sulla batteria, eccetera.
\end_layout

\begin_layout Standard
Oppure sui sistemi linux un sistema per il power management è 
\begin_inset Quotes eld
\end_inset

acpid
\begin_inset Quotes erd
\end_inset

, che contiene l'eseguibile 
\begin_inset Quotes eld
\end_inset

acpi_listen
\begin_inset Quotes erd
\end_inset

 che ci permette di ascoltare gli eventi dell'acpi.
\end_layout

\begin_layout Subsubsection
Working with the DSDT
\end_layout

\begin_layout Standard
The first thing to do is to grab the latest copy of the Intel ASL Compiler
 from your distro repositories or the source code from the download section
 of the acpica website, or by searching 
\begin_inset Quotes eld
\end_inset

dsdt
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

acpica-tools
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

acpi
\begin_inset Quotes erd
\end_inset

 from the software repository.
\end_layout

\begin_layout Standard
We can extract the DSDT of our system with:
\end_layout

\begin_layout Itemize
sudo cat /sys/firmware/acpi/tables/DSDT > dsdt.aml
\end_layout

\begin_layout Standard
questo file 
\begin_inset Quotes eld
\end_inset

dsdt.aml
\begin_inset Quotes erd
\end_inset

 però sarà per noi illegibile, dobbiamo quindi decompilarlo attraverso il
 pacchetto installato per il dsdt in precedenza, attraverso il comando:
\end_layout

\begin_layout Itemize
iasl -d dsdt.aml //decompila il file 
\begin_inset Quotes eld
\end_inset

dsdt.aml
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
This will generate a dsdt.dsl file that you can open in any text editor and
 start editing.
 But it’s a better idea to recompile the file to see if it produces any
 errors, or if there are any errors with the compiling tools.
\end_layout

\begin_layout Itemize
iasl -tc dsdt.dsl //compila il file dsdt.dsl
\end_layout

\begin_layout Subsubsection
Risparmiare potenza e allungare la durata della batteria
\end_layout

\begin_layout Standard
Un tool utile a questo scopo è 
\begin_inset Quotes eld
\end_inset

powertop
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Section
Audio
\end_layout

\begin_layout Itemize
aplay -l //visualizza le interfacce audio disponibili, solitamente ne abbiamo
 una a parte e se c'è una porta hdmi, questa costituisce una vera e propria
 scheda audio a parte, attaccata alla scheda video.
\end_layout

\begin_layout Section
Bash Shell Scripting
\end_layout

\begin_layout Standard
In questa sezione vediamo lo shell scripting.
 Diamo innanzitutto una carrellata di variabili d'ambiente che possono essere
 utili nell shell scripting.
\end_layout

\begin_layout Itemize
$PWD //la directory corrente
\end_layout

\begin_layout Itemize
$IFS //contiene il carattere utilizzato come separatore, rappresenta come
 la shell separa i parametri e i valori in genere, di default è assegnato
 al carattere 
\begin_inset Quotes eld
\end_inset

spazio
\begin_inset Quotes erd
\end_inset

 (space)
\end_layout

\begin_layout Itemize
$PS1 //il prompt visualizzato dalla shell
\end_layout

\begin_layout Itemize
$CDPATH //è una variabile d'ambiente che può contenere directory aggiuntive
 che vengono considerate sempre nel momento in cui eseguiamo 
\begin_inset Quotes eld
\end_inset

cd
\begin_inset Quotes erd
\end_inset

, ad esempio se accediamo spesso alla directory 
\begin_inset Quotes eld
\end_inset

/etc
\begin_inset Quotes erd
\end_inset

 in quanto nella directory 
\begin_inset Quotes eld
\end_inset

/etc
\begin_inset Quotes erd
\end_inset

 sono contenute le directory 
\begin_inset Quotes eld
\end_inset

/etc/x
\begin_inset Quotes erd
\end_inset

 ed 
\begin_inset Quotes eld
\end_inset

/etc/y
\begin_inset Quotes erd
\end_inset

 che sono di nostro interesse, allora possiamo eseguire 
\begin_inset Quotes eld
\end_inset

export CDPATH=/etc
\begin_inset Quotes erd
\end_inset

 a questo punto in qualasiasi directory ci dovessimo trovare, possiamo eseguire
 semplicemente un 
\begin_inset Quotes eld
\end_inset

cd x
\begin_inset Quotes erd
\end_inset

 per accedere alla directory /etc/x ed 
\begin_inset Quotes eld
\end_inset

cd y
\begin_inset Quotes erd
\end_inset

 per accedere alla directory 
\begin_inset Quotes eld
\end_inset

/etc/y
\begin_inset Quotes erd
\end_inset

, è anche utilizzata per impostare la directory a cui andiamo quando eseguiamo
 
\begin_inset Quotes eld
\end_inset

cd
\begin_inset Quotes erd
\end_inset

, che di default oggigiorno è la 
\begin_inset Quotes eld
\end_inset

home
\begin_inset Quotes erd
\end_inset

 dell'utente
\end_layout

\begin_layout Itemize
$PS2 //il secondo prompt visualizzato dalla shell, quello comumente indicato
 con 
\begin_inset Quotes eld
\end_inset

>
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
$$ //il pid della shell attuale, in uno script è il PID dello script
\end_layout

\begin_layout Itemize
$SHELL //il tipo di shell utiizzata
\end_layout

\begin_layout Itemize
$LD_LIBRARY_PATH //il percorso delle librerie
\end_layout

\begin_layout Itemize
$EDITOR //il tipo di editor che viene aperto in automatico quando richiesto
\end_layout

\begin_layout Itemize
$PATH //il percorso da dove vengono presi gli eseguibili per essere lanciati
 come comandi
\end_layout

\begin_layout Itemize
$RANDOM //se stampata, mostra un valore casuale generato dalla bash
\end_layout

\begin_layout Itemize
$# //(utile negli script) il numero di parametri passati ad uno script
\end_layout

\begin_layout Itemize
$0 //(utile negli script) nome dello script
\end_layout

\begin_layout Itemize
$@ //(utile negli script) una variabile unica contenente la lista di parametri
 passati allo script, usa come separatore lo 
\begin_inset Quotes eld
\end_inset

spazio
\begin_inset Quotes erd
\end_inset

, questo è preferibile rispetto alla versione 
\begin_inset Quotes eld
\end_inset

$*
\begin_inset Quotes erd
\end_inset

, in quanto questa dipende da IFS
\end_layout

\begin_layout Itemize
$* //(utile negli script) una variabile unica contenente la lista di parametri
 passati allo script, usa come separatore il carattere nella variabile 
\begin_inset Quotes eld
\end_inset

IFS
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
$1, $2, ...
 //(utile negli script), è il parametro passato, ad esempio $1, è il primo
 parametro passato, $2 il secondo parametro passato e così via
\end_layout

\begin_layout Subsection
Stringhe
\end_layout

\begin_layout Standard
Vediamo alcune operazioni sulle stringhe in Bash.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

var=ciao
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#stampa "ciao"
\end_layout

\begin_layout Plain Layout

echo  $var 	
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#uguale al precedente, stampa "ciao"
\end_layout

\begin_layout Plain Layout

echo "$var"	
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#stampa "$var", gli apici singoli sono diversi dagli apici doppi
\end_layout

\begin_layout Plain Layout

echo '$var'	
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#stampa solo il primo carattere, cioè "c"
\end_layout

\begin_layout Plain Layout

echo "${var::1}" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#stampa solo i primi due caratteri, posso leggerlo come "stampa fino al
 carattere 2", quindi "ci"
\end_layout

\begin_layout Plain Layout

echo "${var::2}" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#stampa tutta la stringa senza l'ultimo carattere
\end_layout

\begin_layout Plain Layout

echo "${var::(-1)}" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#stampa tutta la stringa senza gli ultimi due caratteri
\end_layout

\begin_layout Plain Layout

echo "${var::(-2)}" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#stampa tutta la stringa senza l'ultimo carattere
\end_layout

\begin_layout Plain Layout

echo "${var:0:-1}"  
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#stampa solo i caratteri dal secondo al penultimo
\end_layout

\begin_layout Plain Layout

echo "${var:1:-1}" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#in questo modo concateno le stringhe
\end_layout

\begin_layout Plain Layout

var_seconda=($var$var) 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#stampa la stringa senza gli ultimi 4 caratteri
\end_layout

\begin_layout Plain Layout

echo "${var::-4}"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#stampa gli ultimi 3 caratteri della stringa, quindi "iao"
\end_layout

\begin_layout Plain Layout

echo ${var:(-3)}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#stampa i caratteri dal 3 alla fine quindi "ao"
\end_layout

\begin_layout Plain Layout

echo ${var:3}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#per ricavare la lunghezza di una stringa eseguiamo
\end_layout

\begin_layout Plain Layout

length=${#var}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#salva l'output di un programma/comando in una variabile
\end_layout

\begin_layout Plain Layout

output=$(comando -arg1 23 -opz1)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Conditionals
\end_layout

\begin_layout Standard
Ci sono due modi per effettuare test, 
\end_layout

\begin_layout Itemize
il comando test
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
come ad esempio: if test -f nome.txt
\end_layout

\end_deeper
\begin_layout Itemize
il comando [ //che per convenzione di leggibilità viene aggiunto il carattere
 ] alla fine del conditional
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
come ad esempio: if [ -f nome.txt ]
\end_layout

\end_deeper
\begin_layout Standard
Vediamo un esempio di blocco if
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

if [ -f fred.c ]
\end_layout

\begin_layout Plain Layout

then
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

elif
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

else
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

fi
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

##versione alternativa su una sola linea
\end_layout

\begin_layout Plain Layout

#dobbiamo specificare il ; se non mettiamo il then 
\end_layout

\begin_layout Plain Layout

# su una nuova linea
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if [ -f fred.c ]; then
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

elif
\end_layout

\begin_layout Plain Layout

	wdaddwdwa
\end_layout

\begin_layout Plain Layout

else
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

endif
\end_layout

\end_inset


\end_layout

\begin_layout Standard
i tipi di condizioni che possiamo usare col comando 
\begin_inset Quotes eld
\end_inset

test
\begin_inset Quotes erd
\end_inset

, sono 3:
\end_layout

\begin_layout Itemize
string comparison
\end_layout

\begin_layout Itemize
arithmetic comparison
\end_layout

\begin_layout Itemize
file conditionals
\end_layout

\begin_layout Standard
The following table describes these condition types:
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
String Comparison
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Result
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
string1==string2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
true if the strings are equal
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
string1 != string2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
true if the strings are not equal
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-n string
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
true if the string is not null
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-z string
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
true if the string is null (an empty string)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Arithmetic Comparison
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Result
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
expression1 -eq expression2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
vera se le espressioni sono uguali
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
expression1 -ne expression2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
vera se le espressioni non sono uguali
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
expression1 -gt expression2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
vera se expression1 è maggiore dell'altra
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
expression1 -ge expression2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
vera se expression1 è maggiore o uguale dell'altra
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
expression1 -lt expression2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
vera se expression1 è minore dell'altra
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
expression1 -le expression2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
vera se expression1 minore o uguale di expression2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
! expression
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
vera se l'espressione è falsa, e viceversa
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="10" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
File Conditionals
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Result
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-d file
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
vera se il file è una directory, o se la directory esiste
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-e file
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
vera se il file esiste, nota che storicamente l'opzione 
\begin_inset Quotes eld
\end_inset

-e
\begin_inset Quotes erd
\end_inset

 non è portable, quindi si usa 
\begin_inset Quotes eld
\end_inset

-f
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-f file
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
vera se il file è un file regolare (esiste)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-g file
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
vera se il set-group-id (SGID) è settato su un file
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-r file
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
vera se il file è readable
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-s file
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
vera se il file ha dimensioni diverse da zero
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-u file
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
vera se il set-user-id SUID è settato sul file
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-w file
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
vera se il file è writable
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-x file
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
vera se il file è executable
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Tipi di condizioni
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
è da ricordare che uno script termina correttamente con 
\begin_inset Quotes eld
\end_inset

exit 0
\begin_inset Quotes erd
\end_inset

, mentre si usa un numero diverso da zero per segnalare una terminazione
 unsuccessful dello script.
\end_layout

\begin_layout Standard
Inoltre è convenzione racchiudere le stringhe sempre tra 
\begin_inset Quotes eld
\end_inset


\begin_inset Quotes erd
\end_inset

 doppi apici, anche se contenute in variabili, in quanto l'assenza di questi
 ultimi potrebbe dare problemi, quindi dobbiamo usare 
\begin_inset Quotes eld
\end_inset

$miaStringa
\begin_inset Quotes erd
\end_inset

 e non $miaStringa.
\end_layout

\begin_layout Subsection
Cicli for
\end_layout

\begin_layout Standard
La struttura base di un ciclo for è:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#!/bin/sh
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

for variable in values
\end_layout

\begin_layout Plain Layout

do 
\end_layout

\begin_layout Plain Layout

	statements
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

done
\end_layout

\begin_layout Plain Layout

exit 0
\end_layout

\end_inset


\end_layout

\begin_layout Standard
vediamo un esempio pratico:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#!/bin/sh
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

for foo in ciao1 ciao2 32 6 lol
\end_layout

\begin_layout Plain Layout

do 
\end_layout

\begin_layout Plain Layout

	echo $foo
\end_layout

\begin_layout Plain Layout

done
\end_layout

\begin_layout Plain Layout

exit 0
\end_layout

\end_inset


\end_layout

\begin_layout Standard
in questa caso vengono stampate le stringhe mostrate dopo 
\begin_inset Quotes eld
\end_inset

in
\begin_inset Quotes erd
\end_inset

.
 Vediamo un altro esempio, con una notazione 
\begin_inset Quotes eld
\end_inset

one-line
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#!/bin/sh
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#this is wrong...
 we should not use ls, since it is an interactive tool i should use "f*.sh"
\end_layout

\begin_layout Plain Layout

#the correct form is
\end_layout

\begin_layout Plain Layout

##for file in f*.sh do ; echo "$file
\end_layout

\begin_layout Plain Layout

for file in $(ls f*.sh); do
\end_layout

\begin_layout Plain Layout

	echo $file
\end_layout

\begin_layout Plain Layout

done
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

exit 0
\end_layout

\end_inset


\end_layout

\begin_layout Standard
quello compreso tra $() viene eseguito come comando e preso l'output.
\end_layout

\begin_layout Standard
Vediamo un esempio di ciclo in stile C:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for i in {1..5} 
\end_layout

\begin_layout Plain Layout

do    
\end_layout

\begin_layout Plain Layout

	echo "Welcome $i times" 
\end_layout

\begin_layout Plain Layout

done
\end_layout

\end_inset


\end_layout

\begin_layout Standard
un'altro esempio, potrebbe essere:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

# in questo caso specifichiamo anche lo step da usare
\end_layout

\begin_layout Plain Layout

for i in {1..10..2} 
\end_layout

\begin_layout Plain Layout

do    
\end_layout

\begin_layout Plain Layout

	echo "Welcome $i times" 
\end_layout

\begin_layout Plain Layout

done
\end_layout

\end_inset


\end_layout

\begin_layout Standard
possiamo eseguire cicli infiniti con:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for (( ; ; ))
\end_layout

\begin_layout Plain Layout

do    
\end_layout

\begin_layout Plain Layout

	echo "infinite loops [ hit CTRL+C to stop]" 
\end_layout

\begin_layout Plain Layout

done
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Cicli while
\end_layout

\begin_layout Standard
La struttura base di un ciclo while è:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#!/bin/sh
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

echo "Enter Password"
\end_layout

\begin_layout Plain Layout

read trythis
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

while [ "$trythis" != "secret" ];do
\end_layout

\begin_layout Plain Layout

	echo "Sorry, try again"
\end_layout

\begin_layout Plain Layout

	read trythis
\end_layout

\begin_layout Plain Layout

done
\end_layout

\begin_layout Plain Layout

exit 0
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Ciclo Until
\end_layout

\begin_layout Standard
La struttura base di un ciclo until è:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#!/bin/sh
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

until condizione
\end_layout

\begin_layout Plain Layout

do
\end_layout

\begin_layout Plain Layout

	statements
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

done
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

exit 0
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Un esempio di base è:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#!/bin/sh
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

until who | grep "$1" > /dev/null #in questo caso viene fatto un un do fino
 a che  non c'è l'utente indicato come parametro nella lista degli account
 loggati, la parte ">/dev/null" serve solo per redirigere l'output di alcuni
 comandi
\end_layout

\begin_layout Plain Layout

do
\end_layout

\begin_layout Plain Layout

	statements
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

done
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

exit 0
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Case Switch
\end_layout

\begin_layout Standard
La struttura base di un case switch è:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#!/bin/sh
\end_layout

\begin_layout Plain Layout

##N.B.: Attenzione a come vengono usate le wildcard 
\end_layout

\begin_layout Plain Layout

##nei case switch, perchè in realtà solo la 
\end_layout

\begin_layout Plain Layout

##prima opzione di una wildcard verrà 
\end_layout

\begin_layout Plain Layout

##presa in considerazione
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

echo "Is it morning ? Please answer yes or no"
\end_layout

\begin_layout Plain Layout

read timeofday
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

case "$timeofday" in
\end_layout

\begin_layout Plain Layout

	yes) echo "Good Morning";;
\end_layout

\begin_layout Plain Layout

	no ) echo "Good Afternoon";;
\end_layout

\begin_layout Plain Layout

	y  ) echo "Good Morning";;
\end_layout

\begin_layout Plain Layout

	n  ) echo "Good Afternoon";;
\end_layout

\begin_layout Plain Layout

	*  ) echo "Sorry, answer not recognized";;
\end_layout

\begin_layout Plain Layout

esac
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

exit 0
\end_layout

\end_inset


\end_layout

\begin_layout Standard
vediamo un'alternativa struttura di uno switch case:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#!/bin/sh
\end_layout

\begin_layout Plain Layout

##N.B.: Attenzione a come vengono usate le wildcard 
\end_layout

\begin_layout Plain Layout

##nei case switch, perchè in realtà solo la 
\end_layout

\begin_layout Plain Layout

##prima opzione di una wildcard verrà 
\end_layout

\begin_layout Plain Layout

##presa in considerazione
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

echo "Is it morning ? Please answer yes or no"
\end_layout

\begin_layout Plain Layout

read timeofday
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

case "$timeofday" in
\end_layout

\begin_layout Plain Layout

	yes | Y | Yes | YES) echo "Good Morning";;
\end_layout

\begin_layout Plain Layout

	n* | N* ) echo "Good Afternoon";;
\end_layout

\begin_layout Plain Layout

	*  ) echo "Sorry, answer not recognized";;
\end_layout

\begin_layout Plain Layout

esac
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

##in questo caso le wildcard funzionano
\end_layout

\begin_layout Plain Layout

##correttamente, l'unico problema è che 
\end_layout

\begin_layout Plain Layout

##stringhe come never o Never
\end_layout

\begin_layout Plain Layout

##avranno la stessa valenza di "no" ad esempio
\end_layout

\begin_layout Plain Layout

exit 0
\end_layout

\end_inset


\end_layout

\begin_layout Standard
una struttura alternativa di uno switch case in cui vengono specificate
 più istruzioni all'interno di un case è:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#!/bin/sh
\end_layout

\begin_layout Plain Layout

##N.B.: Attenzione a come vengono usate le wildcard 
\end_layout

\begin_layout Plain Layout

##nei case switch, perchè in realtà solo la 
\end_layout

\begin_layout Plain Layout

##prima opzione di una wildcard verrà 
\end_layout

\begin_layout Plain Layout

##presa in considerazione
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

echo "Is it morning ? Please answer yes or no"
\end_layout

\begin_layout Plain Layout

read timeofday
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

case "$timeofday" in
\end_layout

\begin_layout Plain Layout

	[yY] | [yY][eE][sS]) 
\end_layout

\begin_layout Plain Layout

		echo "Good Morning";;
\end_layout

\begin_layout Plain Layout

		echo "Up bright and early this morning"
\end_layout

\begin_layout Plain Layout

		;;
\end_layout

\begin_layout Plain Layout

	[nN]*) 
\end_layout

\begin_layout Plain Layout

		echo "Good Afternoon"
\end_layout

\begin_layout Plain Layout

		;;
\end_layout

\begin_layout Plain Layout

	*) 
\end_layout

\begin_layout Plain Layout

		echo "Sorry, answer not recognized"
\end_layout

\begin_layout Plain Layout

		echo "Please answer yes or no"
\end_layout

\begin_layout Plain Layout

		exit 1
\end_layout

\begin_layout Plain Layout

		;;
\end_layout

\begin_layout Plain Layout

esac
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

##in questo caso le wildcard funzionano
\end_layout

\begin_layout Plain Layout

##correttamente, l'unico problema è che 
\end_layout

\begin_layout Plain Layout

##stringhe come never o Never
\end_layout

\begin_layout Plain Layout

##avranno la stessa valenza di "no" ad esempio
\end_layout

\begin_layout Plain Layout

exit 0
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Liste AND e liste OR
\end_layout

\begin_layout Standard
Possiamo concatenare comandi a livello condizionale, ad esempio:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#!/bin/sh
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

##Esempio Lista AND
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if [ -f file_one ] && echo "ciao" && [ -f file_two]
\end_layout

\begin_layout Plain Layout

then
\end_layout

\begin_layout Plain Layout

	echo "in if"
\end_layout

\begin_layout Plain Layout

fi
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

##Esempio Lista OR
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if [ -f file_one ] || echo "ciao" || [ -f file_two ]
\end_layout

\begin_layout Plain Layout

then 
\end_layout

\begin_layout Plain Layout

	echo "The first one is executed"
\end_layout

\begin_layout Plain Layout

fi
\end_layout

\begin_layout Plain Layout

exit 0
\end_layout

\end_inset


\end_layout

\begin_layout Standard
l'esempio con la lista AND, esegue i vari comandi da sinistra a destra solo
 se lìultimo eseguito è vero, cioè se la prima condizione è vera, allora
 viene eseguita la seconda (echo è sempre vero), se la seconda è vera viene
 eseguita la terza, nel caso una condizione non fosse vera, allora l'istruzione
 successiva non viene eseguita e l'intero if risulterebbe falso.
\end_layout

\begin_layout Standard
Mentre nel caso di lista OR, in pratica viene eseguito il primo comando
 vero e tutti gli altri vengono scartati dopo che è stato eseguito il primo
 comando vero.
\end_layout

\begin_layout Subsection
Operazioni matematiche
\end_layout

\begin_layout Standard
Per effettuare operazioni matematiche utilizziamo generalmente bc, infatti
 la bash shell può effettuare operazioni matematiche nativamente solo con
 numeri interi, per operazioni più complesse siamo costretti ad usare bc,
 vediamo alcuni esempi:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#effettuo il calcolo 1/3
\end_layout

\begin_layout Plain Layout

echo "1/3" | bc -l; 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#oppure
\end_layout

\begin_layout Plain Layout

a=2; 
\end_layout

\begin_layout Plain Layout

b=5; 
\end_layout

\begin_layout Plain Layout

res=$(bc -l <<< "$a * 3.4 + 4 / $b") 
\end_layout

\begin_layout Plain Layout

#l'operatore "<<<" serve a redirigere nello standard input del programma
 avviato
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#setta la precisione del risultato a 2 cifredopo la virgola
\end_layout

\begin_layout Plain Layout

echo "scale=2; 3/8" | bc
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#radice quadrata
\end_layout

\begin_layout Plain Layout

echo "sqrt(100)" | bc
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#elevamento a potenza
\end_layout

\begin_layout Plain Layout

echo "10^10" | bc
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
vediamo ora alcuni esempi di operazioni con interi supportate nativamente
 dalla bash:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#operazioni con numeri interi di bash
\end_layout

\begin_layout Plain Layout

A=$(( B * C ))
\end_layout

\begin_layout Plain Layout

B=$(( 1 + 5 / (59 *3) ))
\end_layout

\end_inset

Possiamo lanciare anche bc da terminale eseguendo:
\end_layout

\begin_layout Itemize
bc -l //il flag 
\begin_inset Quotes eld
\end_inset

-l
\begin_inset Quotes erd
\end_inset

 ci permette di avere numeri con la virgola, altrimenti nel caso non venisse
 abilitato, all'interno di bc, dovremmo eseguire 
\begin_inset Quotes eld
\end_inset

scale=5
\begin_inset Quotes erd
\end_inset

 ad esempio per impostare il numero di cifre dopo la virgola a 5
\end_layout

\begin_layout Subsection
Funzioni
\end_layout

\begin_layout Standard
Possiamo definire funzioni shell in questo modo:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

nome_funzione() {
\end_layout

\begin_layout Plain Layout

	statements
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

##se nessun return è usato, viene usato come valore 
\end_layout

\begin_layout Plain Layout

##di return dell'ultimo comando eseguito
\end_layout

\end_inset


\end_layout

\begin_layout Standard
è utile ricordare che possiamo fare prototipi di funzioni dalla shell anche
 solo eseguendo dalla command-line:
\end_layout

\begin_layout Itemize
nome_funzione() {
\end_layout

\begin_layout Itemize
istruzione1
\end_layout

\begin_layout Itemize
istruzione2
\end_layout

\begin_layout Itemize
#commento
\end_layout

\begin_layout Itemize
...
\end_layout

\begin_layout Itemize
istruzioneN
\end_layout

\begin_layout Itemize
} //questo indica la fine del programma
\end_layout

\begin_layout Standard
e per visualizzare un funzione possiamo eseguire:
\end_layout

\begin_layout Itemize
declare -f nome_funzione //questo mostrerà il codice della funzione
\end_layout

\begin_layout Standard
il comando declare è molto utile anche nel caso volessimo salvare funzioni
 create sul momento e metterle in un file, andando a redirigere l'output
 nel file di configurazione della shell o nel file in cui andiamo a salvare
 le funzioni builtin.
\end_layout

\begin_layout Subsubsection
arr pag81 continuare dal libro beginning linux programming
\end_layout

\begin_layout Subsection
Array
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

arr=(Hello world) #definisco un array con due elementi stringa
\end_layout

\begin_layout Plain Layout

arr2=(`echo {0..9}{0..9}{0..9}{0..9}`)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

arr[0]=Hello
\end_layout

\begin_layout Plain Layout

arr[1]=world
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

echo ${arr[0]} ${arr[1]} //stampa i vettori
\end_layout

\end_inset


\end_layout

\begin_layout Standard
vediamo un altro esempio:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

DIGIT_CODE_ARRAY=(`echo {0..9}{0..9}{0..9}{0..9}`)
\end_layout

\begin_layout Plain Layout

password="UoMYTrfrBFHyQXmg6gzctqAwOmw1IohZ"
\end_layout

\begin_layout Plain Layout

number_combo=${#DIGIT_CODE_ARRAY[@]}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# use for loop read all combos
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

for (( i=0; i<${number_combo}; i++ )); 
\end_layout

\begin_layout Plain Layout

do       
\end_layout

\begin_layout Plain Layout

	echo "$password ${DIGIT_CODE_ARRAY[$i]}" 
\end_layout

\begin_layout Plain Layout

done
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Interazione con finestre grafiche, ovvero xdotool (o xdo)
\end_layout

\begin_layout Standard
Vediamo un esempio di script che seleziona una finestra il cui titolo contiene
 la stringa 
\begin_inset Quotes eld
\end_inset

stringInAWindow
\begin_inset Quotes erd
\end_inset

 (questo potrebbe anche non essere il titolo completo della finestra), la
 attiva e poi preme la combinazione di tasti 
\begin_inset Quotes eld
\end_inset

space+z
\begin_inset Quotes erd
\end_inset

 all'infinito:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

xdotool search "stringInAWindow" windowactivate; while true; do xdotool
 key space+z; done
\end_layout

\end_inset


\end_layout

\begin_layout Standard
altro esempio, in cui attiviamo una finestra e premiamo la combinazione
 Ctrl+q:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

xdotool search "giuseppe" windowactivate && xdotool key ctrl+q
\end_layout

\end_inset


\end_layout

\begin_layout Standard
per i tasti f1-f12 usiamo:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

xdotool search "giuseppe" windowactivate && xdotool key alt+f4 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
possiamo mandare stringhe, ad esempio:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

xdotool type 'ab cd'
\end_layout

\end_inset

 in questo caso stiamo mandando 
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

 poi 
\begin_inset Quotes eld
\end_inset

b
\begin_inset Quotes erd
\end_inset

 poi 
\begin_inset Quotes eld
\end_inset

spazio
\begin_inset Quotes erd
\end_inset

 poi 
\begin_inset Quotes eld
\end_inset

c
\begin_inset Quotes erd
\end_inset

 e poi 
\begin_inset Quotes eld
\end_inset

d
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Possiamo mandare ue tasti con:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

xdotool key a b
\end_layout

\end_inset

 in questo caso mandiamo a e poi b.
\end_layout

\begin_layout Standard
Per mandare caratteri distanziati da 1ms, facciamo:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

xdotool type --delay 1 'abc'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Possiamo anche aspettare che un'applicazione sia prima partita prima di
 lanciargli comandi, ad esempio:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

google-chrome & xdotool search --sync --onlyvisible --class "google-chrome"x-ter
minal-emulator
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Snippet di Codice Utili
\end_layout

\begin_layout Subsubsection
Check per super-user (i.e., sei root ?)
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#Il valore UID per l'utente root è 0
\end_layout

\begin_layout Plain Layout

If [ $UID -ne 0 ]; then 
\end_layout

\begin_layout Plain Layout

	echo Non root user.
 Please run as root.
 
\end_layout

\begin_layout Plain Layout

else 
\end_layout

\begin_layout Plain Layout

	echo Root user 
\end_layout

\begin_layout Plain Layout

fi
\end_layout

\end_inset


\end_layout

\begin_layout Section
Linux per Applicazioni Embedded
\end_layout

\begin_layout Subsection
Creare un Initial Ram File System con sistema di base
\end_layout

\begin_layout Standard
Per creare un initial ram filesystem con file di base eseguiamo:
\end_layout

\begin_layout Itemize
mkdir rootfs
\end_layout

\begin_layout Itemize
cd rootfs
\end_layout

\begin_layout Itemize
mkdir bin dev etc home lib proc sbin sys tmp usr usr/{bin,lib,sbin} var
 var/log //creazione delle directory di base
\end_layout

\begin_layout Standard
possiamo poi pensare ad esempio di copiare busybox all'interno del nostro
 initramfs, e poi una volta fatto dovremo copiare le librerie, l'insieme
 minimo è:
\end_layout

\begin_layout Itemize
ld-linux
\end_layout

\begin_layout Itemize
libc
\end_layout

\begin_layout Itemize
libm
\end_layout

\begin_layout Standard
nel dubbio cerchiamo la libreria dell'architettura interessata ad esempio
 nel caso dell'armhf cerchiamo, ld-linux-armhf.so.3, libc.so, libm.so.
 Se voglio risparmiare spazio posso usare 
\begin_inset Quotes eld
\end_inset

strip
\begin_inset Quotes erd
\end_inset

, col comando file possiamo capire se un file è già stato strippato o meno,
 possiamo eseguire strip su arm ad esempio con:
\end_layout

\begin_layout Itemize
arm-linux-gnueabihf-strip libc.so
\end_layout

\begin_layout Standard
e possiamo eseguirla per tutte le librerie, nel caso non volessimo avere
 problemi con le librerie possiamo copiare tutta la directory delle librerie,
 con lo strip si riesce a risparmiare il 20% dello spazio.
 Esistono inoltre alcuni device di base di cui abbiamo bisogno per avviare
 una shell, questi possiamo crearli con:
\end_layout

\begin_layout Itemize
sudo mknod -m 666 dev/null c 1 3
\end_layout

\begin_layout Itemize
sudo mknod -m 600 dev/console c 5 1
\end_layout

\begin_layout Standard
ora una volta che abbiamo creato il nostro rootfs possiamo creare l'initial
 ram disk con:
\end_layout

\begin_layout Itemize
cd rootfs
\end_layout

\begin_layout Itemize
find .
 | cpio -H newc -ov –owner root:root > ../initramfs.cpio
\end_layout

\begin_layout Itemize
cd ..
\end_layout

\begin_layout Itemize
gzip initramfs.cpio
\end_layout

\begin_layout Standard
ora questo file 
\begin_inset Quotes eld
\end_inset

initramfs.cpio.gz
\begin_inset Quotes erd
\end_inset

 è già leggibile da qemu, comunque possiamo creare un initramfs da bootare
 su un device reale con:
\end_layout

\begin_layout Itemize
mkimage -A arm -O linux -T ramdisk -d initramfs.cpio.gz uRamdisk
\end_layout

\begin_layout Standard
A questo punto se volessimo risparmiare spazio dobbiamo considerare una
 delle seguenti opzioni:
\end_layout

\begin_layout Itemize
fare il kernel più piccolo lasciando fuori qualche modulo in più
\end_layout

\begin_layout Itemize
fare busybox più piccolo lasciando qualche utility fuori in più
\end_layout

\begin_layout Itemize
usare uClibc o musl libc al posto di glibc
\end_layout

\begin_layout Itemize
compilare busybox staticamente, (attuabile solo nel caso in cui ci devono
 girare pochissimi programmi sul sistema embedded)
\end_layout

\begin_layout Standard
per effettuare il boot di un initramfs ad esempio con Qemu considerando
 una board beaglebone:
\end_layout

\begin_layout Itemize
QEMU_AUDIO_DRV=none 
\backslash
 qemu-system-arm -m 256M -nographic -M vexpress-a9 -kernel zImage -append
 "console=ttyAMA0 rdinit=/bin/sh" -dtb vexpress-v2p-ca9.dtb -initrd initramfs.cpio.
gz
\end_layout

\begin_layout Subsection
Cross Compilare Busybox per arm
\end_layout

\begin_layout Standard
Quando dobbiamo cross compilare è sempre buona norma quando si impostano
 configurazioni di default come 
\begin_inset Quotes eld
\end_inset

defconfig
\begin_inset Quotes erd
\end_inset

 prima specificare l'architettura, il modo corretto ad esempio per cross
 compilare busybox è:
\end_layout

\begin_layout Itemize
make distclean
\end_layout

\begin_layout Itemize
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- defconfig //carichiamo
 le impostazioni di default
\end_layout

\begin_layout Itemize
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- menuconfig //per cambiare
 le impostazioni che vogliamo
\end_layout

\begin_layout Itemize
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- //compiliamo
\end_layout

\begin_layout Itemize
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- install CONFIG_PREFIX=/home/exp
ort/rootfs //installiamo nella directory che desideriamo
\end_layout

\begin_layout Subsection
Comunicazione in Seriale
\end_layout

\begin_layout Standard
Possiamo connetterci ad un dispositivo seriale, attraverso:
\end_layout

\begin_layout Itemize
screen /dev/ttyUSB0 115200 //in pratica /dev/ttyUSB0 è un dispositivo d'esempio
 a cui connetterci e 115200 e la velocità della seriale
\end_layout

\begin_layout Standard
altri programmi alternativi sono:
\end_layout

\begin_layout Itemize
gtkterm -p /dev/ttyUSB0 -s 115200
\end_layout

\begin_layout Standard
oppure possiamo provare minicom e picocom.
\end_layout

\begin_layout Standard
N.B.: Se abbiamo un device esterno, come ad esempio una electronic board,
 un SoC (System on a Chip) o un device con interfaccia seriale in genere
 (cioè piedini TX,RX e GND) dobbiamo utilizzare un circuito FTDI per interfaccia
rci.
 Da provare è anche 
\begin_inset Quotes eld
\end_inset

stty
\begin_inset Quotes erd
\end_inset

 ad esempio stty -F /dev/ttyAMA0 9600 ma è da verificare.
\end_layout

\begin_layout Standard
Vediamo un esempio per leggere da seriale con minicom:
\end_layout

\begin_layout Itemize
minicom -b 115200 -o -D /dev/ttyUSB0 //in questo caso leggiamo da ttyUSB0
 alla velocità di 115200
\end_layout

\begin_layout Standard
attenzione è buona norma ben configurare minicom, possiamo accedere al menu
 delle opzioni premendo:
\end_layout

\begin_layout Itemize
Ctrl+A, e poi Z
\end_layout

\begin_layout Standard
da qui possiamo entrare nella configurazione con 
\begin_inset Quotes eld
\end_inset

o
\begin_inset Quotes erd
\end_inset

 e qui assicuriamoci che da entrambi i lati della comunicazione sia impostata
 la stessa velocità in 
\begin_inset Quotes eld
\end_inset

baud
\begin_inset Quotes erd
\end_inset

 e che:
\end_layout

\begin_layout Itemize
la voce 
\begin_inset Quotes eld
\end_inset

Hardware Flow Control
\begin_inset Quotes erd
\end_inset

 sia impostata su 
\begin_inset Quotes eld
\end_inset

No
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
la voce 
\begin_inset Quotes eld
\end_inset

Software Flow Control
\begin_inset Quotes erd
\end_inset

 sia impostata su 
\begin_inset Quotes eld
\end_inset

Yes
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
possiamo anche salvare le impostazioni come dfl, in questo modo il setting
 sarà permanente.
\end_layout

\begin_layout Standard
In pratica l'Hardware Flow Control uses extra wires on the serial port,
 beyond just GND, TX and RX, a formal "serial port" like the 9 pin RS232
 port on old computers includes control lines like "Data Terminal Ready
 indicator", so hardware flow control is telling the computer to expect
 those extra signals
\end_layout

\begin_layout Subsection
GPIO Pins
\end_layout

\begin_layout Standard
GPIO mean "General Purpose Input/Output" and is a special pin present in
 some chip that can be set as input or output and used to move a signal
 high or low (in output mode) or to get the signal current status (in input
 mode).
 Usually these pin are directly managed by kernel modules but there are
 an easy way to manage these pins also from user space.
\end_layout

\begin_layout Standard
Standard Linux kernel have inside a special interface allow to access to
 GPIO pins.
 Once executed kernel menuconfig you can easily verify is this interface
 is active in your kernel and, in case, enable them.
 The kernel tree path is the following:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Device Drivers  ---> GPIO Support  ---> /sys/class/gpio/...
 (sysfs interface)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If not, enable this feature and recompile the kernel before continue to
 read.
 The interface to allow working with GPIO is at the following filesystem
 path:
\end_layout

\begin_layout Itemize
/sys/class/gpio
\end_layout

\begin_layout Standard
Basically if you want to work with a particular GPIO you must first to reserve
 it, set the input/output direction and start managing it.
 Once you reserved the GPIO and finished to use you need to free it for
 allow other modules or process to use them.
 This rule is valid in both cases you want to use GPIO from kernel level
 or user level.
 From the user level side this "operation" for reserve the GPIO is called
 "export" the GPIO.
 For make this export operation you simply need to echo the GPIO number
 you are interested to a special path as follow (change XX with the GPIO
 number you need):
\end_layout

\begin_layout Itemize
echo XX > /sys/class/gpio/export
\end_layout

\begin_layout Standard
if the operation is successful (the possible case of operation failed is
 explained below) a new "folder" will show up in the GPIO interface path
 as example below:
\end_layout

\begin_layout Itemize
/sys/class/gpio/gpioXX/
\end_layout

\begin_layout Standard
This new "folder" will allow you to work with the GPIO you just reserved.
 In particular if you want to set the in/out direction you simply need to
 execute the following echo commands: 
\end_layout

\begin_layout Itemize
echo "out" > /sys/class/gpio/gpioXX/direction
\end_layout

\begin_layout Standard
or 
\end_layout

\begin_layout Itemize
echo "in" > /sys/class/gpio/gpioXX/direction
\end_layout

\begin_layout Standard
In case you set out direction you can directly manage the value of GPIO.
 You can make this operation by executing additional echo commands like:
\end_layout

\begin_layout Itemize
echo 1 > /sys/class/gpio/gpioXX/value
\end_layout

\begin_layout Standard
or
\end_layout

\begin_layout Itemize
echo 0 > /sys/class/gpio/gpioXX/value
\end_layout

\begin_layout Standard
Since GPIO is a single pin the possible states allowed are high (1) and
 low (0).
 In case you set in direction you can read the current pin value by using
 the following command:
\end_layout

\begin_layout Itemize
cat /sys/class/gpio/gpioXX/value
\end_layout

\begin_layout Standard
Once finished to use your GPIO you can free it by make the same echo command
 but to different path:
\end_layout

\begin_layout Itemize
echo XX > /sys/class/gpio/unexport
\end_layout

\begin_layout Standard
In case of GPIO folder not showed after export operation is very likely
 that the GPIO is already reserved by some module.
 For verify the current reserved GPIO map you must first verify if in your
 kernel is enabled the following feature:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Kernel configuration ---> Kernel hacking ---> Debug FS
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As usual, if not enabled, enable it and recompile the kernel.
 The next step is to launch the following command line for mount debugfs:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

mount -t debugfs none /sys/kernel/debug
\end_layout

\end_inset


\end_layout

\begin_layout Standard
and dump the current GPIO configuration by using:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

cat /sys/kernel/debug/gpio
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The output will show you the current list og reserved GPIO.
 Una libreria molto comoda per gestire il GPIO è 
\begin_inset Quotes eld
\end_inset

WiringPI
\begin_inset Quotes erd
\end_inset

, inoltre ha diversi binding per vari linguaggi di programmazione.
\end_layout

\begin_layout Part
TO ADD
\end_layout

\begin_layout Itemize
cgroups
\end_layout

\begin_layout Itemize
lxc
\end_layout

\begin_layout Itemize
network namespace
\end_layout

\begin_layout Itemize
xen
\end_layout

\begin_layout Itemize
active directory
\end_layout

\begin_layout Itemize
dpms
\end_layout

\begin_layout Itemize
xrandr
\end_layout

\begin_layout Itemize
xsetroot or hsetroot
\end_layout

\begin_layout Itemize
power management (section)
\end_layout

\begin_layout Itemize
Xclip
\end_layout

\begin_layout Itemize
cross compiling
\end_layout

\begin_layout Itemize
xev
\end_layout

\begin_layout Itemize
xdotool
\end_layout

\begin_layout Itemize
xset, with this we can control leds on computers/laptops or even mouse speed,
 the keyboard repeat delay and rate and if the repeat is enabled or not
\end_layout

\begin_layout Itemize
tunctl
\end_layout

\begin_layout Itemize
bridge ethernet
\end_layout

\begin_layout Itemize
xmodmap to remap the keys
\end_layout

\begin_layout Itemize
acpid
\end_layout

\begin_layout Itemize
ulimit: Commands and resources ulimit -n //view number of processes change
 /etc/security/limits.conf or /etc/security/limits.d/90-xxxxx.conf, ulimit
 -a views the list of all the limits on the machine
\end_layout

\begin_layout Itemize
audio (utile pavucontrol)
\end_layout

\begin_layout Itemize
sysctl (used mostly on bsd systems, even for laptop features such as lid
 closing/opening events)
\end_layout

\begin_layout Itemize
strace, ftrace
\end_layout

\begin_layout Itemize
bash scripting
\end_layout

\begin_layout Itemize
tun/tap
\end_layout

\begin_layout Itemize
setterm //to manage screen blanking in pure terminal environments
\end_layout

\begin_layout Itemize
gcore //check the content of the program in memory
\end_layout

\begin_layout Itemize
apt-pinning
\end_layout

\begin_layout Itemize
dget and backporting packages in debian
\end_layout

\begin_layout Itemize
come aprire un file di man tipo 
\begin_inset Quotes eld
\end_inset

pagina.1
\begin_inset Quotes erd
\end_inset

 con man
\end_layout

\begin_layout Itemize
MULTIMEDIA: Convert (Swiss Army Knife for Images) and Sox (Swiss Army Knife
 for Audio)
\end_layout

\begin_layout Itemize
imagemagick, convert or compare:
\end_layout

\begin_deeper
\begin_layout Itemize
compare image1.jpg image2.jpg //gives us the difference between images
\end_layout

\end_deeper
\begin_layout Itemize
fortune | cowsay -f dragon-and-cow | lolcat //o al posto di fortune un echo
 
\begin_inset Quotes eld
\end_inset

ciao
\begin_inset Quotes erd
\end_inset

, anche figlet funziona bene, tipo 'echo 
\begin_inset Quotes eld
\end_inset

ciao
\begin_inset Quotes erd
\end_inset

 | figlet'
\end_layout

\begin_layout Section*
Licenza
\end_layout

\begin_layout Standard
Il testo completo della licenza può essere trovato qui, 
\begin_inset CommandInset href
LatexCommand href
name "Licenza GFDL"
target "https://www.gnu.org/licenses/fdl.html"

\end_inset

.
\end_layout

\end_body
\end_document
